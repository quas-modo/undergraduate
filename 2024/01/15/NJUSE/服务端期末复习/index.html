<!-- build time:Wed Oct 16 2024 13:55:46 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/undergraduate/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/undergraduate/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Carpe diem" href="https://quas-modo.github.io/undergraduate/rss.xml"><link rel="alternate" type="application/atom+xml" title="Carpe diem" href="https://quas-modo.github.io/undergraduate/atom.xml"><link rel="alternate" type="application/json" title="Carpe diem" href="https://quas-modo.github.io/undergraduate/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/undergraduate/css/app.css?v=0.2.5"><meta name="keywords" content="服务端开发"><link rel="canonical" href="https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><title>服务端期末复习 - 服务端开发 - NJUSE | quas-modo = Carpe diem = pluck the day</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">服务端期末复习</h1><div class="meta"><span class="item" title="创建时间：2024-01-15 12:10:11"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-01-15T12:10:11+08:00">2024-01-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/undergraduate/" rel="start">quas-modo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (2).jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (3).jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/krenz-cushart-steampunk-color5-final.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/krenz-cushart-10.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (1).jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/undergraduate/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/undergraduate/categories/NJUSE/" itemprop="item" rel="index" title="分类于 NJUSE"><span itemprop="name">NJUSE</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/undergraduate/categories/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="item" rel="index" title="分类于 服务端开发"><span itemprop="name">服务端开发</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/undergraduate/images/avatar.png"><meta itemprop="name" content="quas-modo"><meta itemprop="description" content="pluck the day, notes/thoughts/nonsense"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Carpe diem"></span><div class="body md" itemprop="articleBody"><p>南京大学软件学院服务端开发期末整理。</p><p><span id="more"></span></p><h1 id="多选题"><a class="anchor" href="#多选题">#</a> 多选题</h1><h2 id="核心技术"><a class="anchor" href="#核心技术">#</a> 核心技术</h2><ol><li>DI（Dependency Injection）<ol><li>保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，<strong>由抽象接口来注入依赖的实际对象</strong></li></ol></li><li>AOP（Aspect Oriented Programming）<ol><li>通过<strong>预编译方式</strong>和<strong>运行期间动态代理</strong>实现程序功能的统一维护的一种技术</li><li>利用 AOP 可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li></ol></li></ol><h2 id="依赖注入"><a class="anchor" href="#依赖注入">#</a> 依赖注入</h2><h2 id="aop"><a class="anchor" href="#aop">#</a> AOP</h2><h3 id="横切关注点类型"><a class="anchor" href="#横切关注点类型">#</a> 横切关注点类型</h3><p>日志、安全、事务、缓存（可选：继承、委托）</p><h3 id="advice注解类型"><a class="anchor" href="#advice注解类型">#</a> Advice 注解类型</h3><ul><li>@Before</li><li>@After：不区分是否正常结束</li><li>@AfterReturning</li><li>@AfterThrowing</li><li>@Around：结合前面所有类型，around 可以是综合，之前、之后、结束、抛异常之后。</li></ul><p><strong>被切方法成功运行之后会执行</strong>：After、AfterReturning、Around</p><h3 id="aspectj可以实现"><a class="anchor" href="#aspectj可以实现">#</a> AspectJ 可以实现</h3><ol><li>指定在哪些方法上切入</li><li>获取参数</li><li>限定包路径</li><li>限定 bean 名称，白名单或黑名单</li><li>限定在特定注解上切入</li></ol><h2 id="spring-mvc"><a class="anchor" href="#spring-mvc">#</a> Spring MVC</h2><h3 id="谁有component的效果"><a class="anchor" href="#谁有component的效果">#</a> 谁有 @Component 的效果？</h3><p><code>@Controller</code> 、 <code>@Service</code> 和 <code>@Repository</code> 三个注解本身有 <code>@Component</code> 的实例化效果。</p><h3 id="重定向"><a class="anchor" href="#重定向">#</a> 重定向</h3><p>控制器处理完成后可以返回逻辑视图名，也可以重定向到其他 url</p><ul><li>http 状态码：302 FOUND<ul><li>HTTP 状态码 302 表示 “Found”（或者有时被称为 “Temporary Redirect” 临时重定向）。当一个 Web 服务器返回这个状态码时，它通常是在告诉客户端，请求的资源暂时被移动到了一个不同的 URI（统一资源标识符）。</li></ul></li><li>控制器 <code>return redirect:&lt;url&gt;</code></li></ul><h3 id="spring-mvc获取参数的几种方式"><a class="anchor" href="#spring-mvc获取参数的几种方式">#</a> Spring MVC 获取参数的几种方式</h3><ol><li>表单 (form) 参数，转成 model<ol><li>成员类型可能要自己实现 Converter 进行转换</li><li>可以用 <code>@Valid</code> 校验</li><li>form 是 html 里定义的</li></ol></li><li>路径参数<ol><li><code>@PathVariable</code></li><li>例： <code>/book/&#123;id&#125;</code></li></ol></li><li>请求参数 / 查询参数<ol><li><code>@RequestParam</code></li><li>例： <code>/challenge?model=2</code></li></ol></li><li>json 请求体<ol><li><code>@RequestBody</code> ，会用到 HttpMessageConverter 消息转换器</li><li>Rest API</li></ol></li></ol><h2 id="spring-data-jdbcjpa"><a class="anchor" href="#spring-data-jdbcjpa">#</a> Spring Data JDBC/JPA</h2><h3 id="数据表创建和初始化"><a class="anchor" href="#数据表创建和初始化">#</a> 数据表创建和初始化</h3><p>三种方式，java 代码初始化有两种。</p><ol><li>表</li><li>commandlinerunner</li><li>applicationrunner</li></ol><p>三种方式关于 id 字段的处理：第一种方法需要主动地获取数据库新的 id 是什么，但二 / 三种没有需要</p><h4 id="脚本"><a class="anchor" href="#脚本">#</a> 脚本</h4><p>schema.sql 表创建</p><p>data.sql 数据初始化</p><p><strong>java 代码初始化</strong></p><p>CommandLineRunner 接口</p><p>ApplicationRunner 接口</p><h3 id="异常体系"><a class="anchor" href="#异常体系">#</a> 异常体系</h3><ul><li>SQLException<ul><li>发现异常很难恢复</li><li>难以确定异常类型</li></ul></li><li>Hibernate 异常<ul><li>定义了许多具体异常，方便定位</li><li>对业务对象侵入</li></ul></li><li>Spring 提供与平台无关的异常<ul><li><code>DataAccessException</code></li><li>具体异常，方便定位</li><li>隔离具体数据库</li></ul></li></ul><h2 id="springdata-mongodbredis"><a class="anchor" href="#springdata-mongodbredis">#</a> SpringData MongoDB\Redis</h2><h3 id="nosql特点"><a class="anchor" href="#nosql特点">#</a> Nosql 特点</h3><p>键值对存储、列存储、文档存储、图形数据库</p><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY0MDg0M2M5N2NlNTBjNzc5M2Y1M2U5NzM4YTE0YjhfVlJmbDlwOG1wcjFmZWpCTjF6Q1dVazI0bHRqSkQ1dXFfVG9rZW46TnhRZ2JjOWpzb0Q0cDB4Mk9RbWNPUWVwbkJqXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h3 id="mongodb特点"><a class="anchor" href="#mongodb特点">#</a> MongoDB 特点</h3><p>基于分布式文件存储的开源数据库系统，类似 json 格式存储</p><p>MongoDB Shell 是 MongoDB 自带的交互式 Javascript shell, 用来对 MongoDB 进行操作和管理的交互式环境</p><h3 id="mongodb概念"><a class="anchor" href="#mongodb概念">#</a> MongoDB 概念</h3><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTliZWYwYmUzMWEwMGUxYmY5YzY4ZjJkMjJkYjI0M2VfTFExcm9ia0VrakMwRDRweG9LaEE1c3N2R0VoOEFYd1FfVG9rZW46QjluVGJkRXg0bzU2Zm14NVhrZWNYVnhSbnVjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h3 id="redis特点"><a class="anchor" href="#redis特点">#</a> Redis 特点</h3><ul><li>分布式存储</li><li><strong>内存数据库</strong>，存在内存里，常用于作缓存</li><li>可以<strong>持久化</strong>，但不太重要，不是主要用途</li><li>可以<strong>集群式部署</strong><ul><li>主从复制，主机写，从机并发读</li></ul></li><li>key-value 的<strong> Hash 表</strong>结构，区分大小写</li></ul><h3 id="redis数据类型"><a class="anchor" href="#redis数据类型">#</a> Redis 数据类型</h3><ol><li>String</li><li>List</li><li>Hash</li><li>Set</li></ol><h3 id="redis指定序列化器"><a class="anchor" href="#redis指定序列化器">#</a> Redis 指定序列化器</h3><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJjNzUwZjQzZjM2ZjlkN2FjYWM4ZjQyZTJkMzdkYTFfOUJUU1BHN3NiWDNZb3lXSEVKU051Z1hnZFBPV1hOQ0RfVG9rZW46QjZMYWJNd081b2dLNUJ4T1pCT2NPTjVmblFiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><p>mongodb 没有这个要求，因为它会把所有值都转成 json 串。</p><p>redis 默认使用 JDK 序列化，但 JSON 序列化更常用。</p><h2 id="spring-security"><a class="anchor" href="#spring-security">#</a> Spring Security</h2><p>划分为两类：</p><ol><li><strong>针对客户 web 请求权限控制</strong></li><li><strong>针对方法级的权限控制</strong></li></ol><h3 id="实现方法级别的安全"><a class="anchor" href="#实现方法级别的安全">#</a> 实现方法级别的安全</h3><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQyNTMyZTBiZWNmN2VlMDk0ZWFhOGMyZDZjMTA2MmVfejVyRnl1blI0MkRYYnIzWWhjOVkzNDZhdUVIemdiUkNfVG9rZW46RmsxeGJzc0ZJbzBwMGp4VktSamNkZWs0bmlYXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h3 id="获取当前登录的用户"><a class="anchor" href="#获取当前登录的用户">#</a> 获取当前登录的用户</h3><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE2MDNjMTllZWU0MjQ3MTFiOGU3YWIwOThkNGQyZDRfMkt0Z1BBWmQxclh4MHVyMHBjcFlZNFJpM1Z1MkhibmdfVG9rZW46VDFCQ2J2Qnhjb2Q4MFp4OENZZmM0ak1vbkxiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="配置属性"><a class="anchor" href="#配置属性">#</a> 配置属性</h2><h3 id="actuator"><a class="anchor" href="#actuator">#</a> Actuator</h3><ul><li>提供许多<strong>端点 (endpoints)</strong>, 监测程序运行情况<ul><li>/actuator，查询所有暴露端点</li><li><strong>/actuator/configprops</strong>，查询配置属性</li><li>/actuator/health，健康检查</li><li>/actuator/beans，包含 bean 依赖关系</li></ul></li><li>想要获得更多端点如何配置： <code>include: &quot;*&quot;</code> 暴露所有端口，否则只暴露 <code>/actuator/health</code></li></ul><h2 id="rest-api"><a class="anchor" href="#rest-api">#</a> Rest API</h2><ul><li>HTTP 协议的四个操作方式的动词：GET、POST、PUT、DELETE<ul><li><strong>CRUD：Create、Read、Update、Delete</strong></li><li>GET: Read</li><li>POST: Create</li><li>PUT: Update</li><li>DELETE: Delete</li></ul></li></ul><h3 id="requestmapping"><a class="anchor" href="#requestmapping">#</a> RequestMapping/</h3><p>实现控制器的时候 RequestMapping 可以加在？类、方法上面</p><h3 id="restcontroller"><a class="anchor" href="#restcontroller">#</a> RestController</h3><p>在 Controller 类中：</p><pre><code class="language-Plain">@RestController  
</code></pre><p>等价于：</p><pre><code class="language-Plain">@Controller  
@ResponseBody  
</code></pre><p>想要某个方法返回的<strong> Java 对象转成 json 格式串</strong>： <code>@ResponseBody</code> 注解加在特定函数上</p><h3 id="响应头与响应体"><a class="anchor" href="#响应头与响应体">#</a> 响应头与响应体</h3><ul><li>状态行：由 <strong>HTTP 协议版本、状态码、状态码描述</strong>三部分构成，它们之间由空格隔开。</li></ul><h2 id="oauth2"><a class="anchor" href="#oauth2">#</a> OAuth2</h2><p>解决分布式系统中，权限控制的问题</p><h2 id="消息中间件"><a class="anchor" href="#消息中间件">#</a> 消息中间件</h2><h3 id="定义"><a class="anchor" href="#定义">#</a> 定义</h3><ul><li>提供消息服务的应用程序</li><li>主要用于组件之间的解耦，消息的发送者服务知道消息使用者的存在，反之依然</li></ul><p>消息代理 broker：</p><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg4NTg1ZjI3MTI3YjM0YjUxNWU5MDYzNzZjY2RjMjdfRjhidzJ1TU04b3RTUmFZbjg1UWJmS0dQNXc2NFUxQkdfVG9rZW46TzRPMWJ0R1NSb0hDSlB4eGo5Z2M2dUpIbnpoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h3 id="jms"><a class="anchor" href="#jms">#</a> JMS</h3><ul><li>Java Message Service<ul><li>Jms 规定了<strong> ConnectionFactory、Connection、Session</strong> 等接口 / 类</li></ul></li></ul><h3 id="activemq"><a class="anchor" href="#activemq">#</a> ActiveMQ</h3><p>支持协议</p><ul><li>JMS</li><li>AMQP: Advanced Message Queueing Protocol</li><li>MQTT: Message Queuing Telemetry Transport</li></ul><p>支持 Native 内存模式和 JVM 内存模式</p><ul><li>Native 可以绕过 JVM，加快访问</li></ul><p>消息持久化</p><p>分布式架构</p><h4 id="关键概念"><a class="anchor" href="#关键概念">#</a> 关键概念</h4><ul><li>Message：类似广播，生产端</li><li>Destination：队列或主题。消费端<ul><li>三种指定方式：<ul><li>application.yml（default-destination）</li><li>@Bean（Destination 对象）</li><li>直接 String 指定</li></ul></li></ul></li></ul><h3 id="接收模式"><a class="anchor" href="#接收模式">#</a> 接收模式</h3><p><strong>拉取和推送都需要消息转换器做反序列化。</strong></p><h4 id="351-拉取模式-pull-model"><a class="anchor" href="#351-拉取模式-pull-model">#</a> 3.5.1. 拉取模式 pull model</h4><p>JmsTemplate 支持</p><p>访问 URL</p><h4 id="352-推送模式-push-model"><a class="anchor" href="#352-推送模式-push-model">#</a> 3.5.2. 推送模式 push model</h4><p>需要<strong>定义消息监听器</strong></p><p>@JmsListener</p><h3 id="rabbitmq"><a class="anchor" href="#rabbitmq">#</a> RabbitMQ</h3><p><strong>实现 AMQP 协议</strong>。</p><h4 id="概念"><a class="anchor" href="#概念">#</a> 概念</h4><ul><li>ConnectionFactory、Connection、Channel</li><li>Exchange：<ul><li>Default、Direct、Topic、Fanout、Headers、Dead letter</li></ul></li><li>Queue</li><li><strong>Routing key</strong>：exchange 根据 routing key 确定消息发往哪个队列<ul><li><strong>JMS 里没有这个概念</strong></li></ul></li><li><strong>Binding key</strong></li></ul><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVkZDE0OWRkMDVjMWFmYjZjMDFlZGIzZmRkOTQ2N2JfRWhtV3JOZG9tMlAxanFhOUF5U0hnSzlJMXdoUUFVUGdfVG9rZW46QU9QcmI3WW5tb0lqM0R4TFcxZWNmMzVlbjVnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><p>一些 gpt 解释：</p><ol><li>connectionFactory: 这是一个创建连接到 RabbitMQ 服务器的工厂类。它封装了与 RabbitMQ 服务器连接所需的配置信息，如主机名、端口、用户名和密码。</li><li>Connection: 这是客户端和 RabbitMQ 服务器之间的网络连接。ConnectionFactory 用于创建这个连接。</li><li>Channel: 一旦建立了连接，Channel 就是在这个连接上进行通信的途径。可以将其视为连接内的一个轻量级会话。在 RabbitMQ 中，几乎所有的操作都是通过 Channel 来完成的，如声明队列、交换机或发布消息等。</li><li>Exchange: 交换机是 RabbitMQ 的一个消息路由机制。它指定消息应该如何路由到不同的队列。RabbitMQ 提供了几种类型的交换机：<ol><li>Default Exchange: 默认交换机是一个直接交换机，用于路由特定 Routing Key 的消息。</li><li>Direct Exchange: 直接交换机将消息路由到具有特定 Routing Key 的队列。</li><li>Topic Exchange: 主题交换机基于模式匹配 Routing Key 来路由消息。</li><li>Fanout Exchange: 扇出交换机将收到的消息广播到它所知道的所有队列。</li><li>Headers Exchange: 头交换机基于消息头信息而不是 Routing Key 来路由消息。</li><li>Dead Letter Exchange: 死信交换机用于处理无法正常处理的消息，如被拒绝或超时的消息。</li></ol></li></ol><h2 id="如何查看镜像中的网卡信息和ip地址"><a class="anchor" href="#如何查看镜像中的网卡信息和ip地址">#</a> 如何查看镜像中的网卡信息和 ip 地址</h2><p>docker run --rm -it busybox</p><p>cat /etc/hosts</p><p>ip a</p><h2 id="integration"><a class="anchor" href="#integration">#</a> Integration</h2><h3 id="service-activators"><a class="anchor" href="#service-activators">#</a> Service activators</h3><ul><li>MessageHandler<ul><li>处理完流就截止</li></ul></li><li>GenericHandler<ul><li>有返回值</li></ul></li></ul><h3 id="gateways"><a class="anchor" href="#gateways">#</a> Gateways</h3><p>只需要写一个接口。 Gateways 是<strong>应用程序代码和消息系统之间的桥梁</strong>。它们抽象了消息发送和接收的细节，使得应用程序代码可以通过方法调用的方式与消息系统交互，而无需直接使用消息 API。这样可以使应用程序代码保持简洁，同时也便于测试。</p><ul><li>单向网关</li><li>双向网关<ul><li>requets channel 输入</li><li>repley channel 获得返回值（Spring 会在这个管道上一直等，同步）\</li></ul></li></ul><h3 id="channel-adapters"><a class="anchor" href="#channel-adapters">#</a> Channel adapters</h3><p>Adapters 则是用于将<strong>消息从一种格式转换为另一种格式</strong>，或者从一种传输协议转换为另一种传输协议。Inbound 把外部系统的消息格式转为 spring integration 消息，outbound 把 spring integration 消息转为外部系统消息。 例如，JMS 适配器可以将 JMS 消息转换为 Spring Integration 通用消息，HTTP 适配器可以将 HTTP 请求和响应转换为 Spring Integration 消息。</p><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcyMGY0ZjBkMDhlNjEwOWFjMmZhNmQxOTRkZTFkNzhfaE9xMVRhNmk3TGtLZGV1N3FYSndZalRNdlhramRkZmdfVG9rZW46RnNnZWJrRENlb1ZtQnB4S1FwNGNFYnYxbjhiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="反应式编程"><a class="anchor" href="#反应式编程">#</a> 反应式编程</h2><h3 id="操作类型"><a class="anchor" href="#操作类型">#</a> 操作类型</h3><p>创建、组合、过滤、转换、逻辑</p><h2 id="webflux"><a class="anchor" href="#webflux">#</a> WebFlux</h2><h3 id="使用函数式编程范式来定义控制器"><a class="anchor" href="#使用函数式编程范式来定义控制器">#</a> 使用函数式编程范式来定义控制器</h3><p>HandlerFunction 表示处理接收到的请求并生成响应的函数</p><p>RouterFunction 替代了 @RequestMapping 注解。它用于将接收到的请求路由到处理函数</p><h3 id="函数式编程模型涉及的4个类型"><a class="anchor" href="#函数式编程模型涉及的4个类型">#</a> 函数式编程模型涉及的 4 个类型</h3><p>RequestPredicate</p><p>RouterFunction</p><p>ServerRequest</p><p>ServerResponse</p><h1 id="简答题"><a class="anchor" href="#简答题">#</a> 简答题</h1><h2 id="bean的三种注入方式"><a class="anchor" href="#bean的三种注入方式">#</a> Bean 的三种注入方式</h2><h3 id="构造方法"><a class="anchor" href="#构造方法">#</a> 构造方法</h3><ul><li>在构造函数上使用 @Autowired 注解，用于自动注入构造函数参数所需要的 Bean。<strong>如果构造函数只有一个参数，则可以省略 @Autowired 注解。</strong></li></ul><p this.mydao="">@Autowired public MyService(MyDao myDao)</p><h3 id="setter方法"><a class="anchor" href="#setter方法">#</a> setter 方法</h3><p this.orderrepo="">public void setOrderRepo(OrderRepository orderRepo)</p><p>也可以加 <code>Autowired</code> 自动注入.</p><p this.orderrepo="">@Autowired public void setOrderRepo(OrderRepository orderRepo)</p><h3 id="属性字段下加autowired"><a class="anchor" href="#属性字段下加autowired">#</a> 属性字段下加 <code>@Autowired</code></h3><p>@Autowired</p><p>private MyBean myBean;</p><h2 id="spring配置方案"><a class="anchor" href="#spring配置方案">#</a> <strong>Spring 配置方案</strong></h2><ol><li>自动化配置</li><li>javaconfig - 第三方库</li><li>XML 配置</li><li>混合配置</li></ol><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY4ZDBkMGMwOTEyNGZhZjBmYzJkYWJjNGI2ZWZhN2JfdlkwNmp4c3NYN1o0UFJGcndjQjFNZnk1WGFlVDhXZGtfVG9rZW46QjJ1RmJVWUx3bzBic0p4VUNlU2N4cWxrbmJoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><ol><li>自动配置<ol><li>组件扫描 component scanning<ul><li><code>@Configuration</code> 配置类</li><li><code>@ComponentScan</code> 从当前包递归找加了注解 <code>@Component</code> 的类，并把它们都实例化出来。表示要在那些包路径下搜索。</li></ul></li><li>自动装配 autowiring <code>@Autowired</code><ul><li>用在构造器</li><li>用在属性 setter 方法</li><li>用在（私有）属性</li><li><code>required=false</code><ul><li>在 Spring 框架中使用 <code>@Autowired</code> 注解时， <code>required=false</code> 这一属性表示如果 Spring 容器中没有找到匹配的 bean 来注入，那么它将允许这个属性保持未设置状态，即不会抛出异常。</li></ul></li></ul></li><li>需要实例化的 Bean： <code>@Component</code><ul><li>默认是<strong>单实例模式</strong>，在 Spring 上下文永远只有一个实例</li><li>可以<strong>参数指定多实例</strong>，比如 <code>@Component(&quot;soundsystem&quot;)</code></li></ul></li></ol></li><li>Javaconfig<ol><li>应用场景：自动化配置行不通，如第三方库</li><li>注解<ul><li><code>@Configuration</code></li><li><code>@Bean(name=“..”)</code></li></ul></li><li>注入<ul><li>调用方法</li><li>通过方法参数自动装配（其他配置类，其他方法创建的 Bean）</li></ul></li><li>注意与业务逻辑和领域代码分开：只用于创建，不会把业务逻辑放进来</li></ol></li><li>Xml<ol><li>格式： <code>&lt;beans&gt;&lt;bean&gt;</code></li><li><strong>无类型检查</strong></li><li>构造器注入<ul><li>constructor-arg</li><li>c - 命名空间</li><li>注入字面量值</li><li>注入集合</li></ul></li><li>属性注入<ul><li>p - 命名空间</li><li>util - 命名空间</li></ul></li><li>建议：强依赖使用构造器注入</li></ol></li><li>混合配置<ol><li>在根配置类中导入其他配置类。</li><li>JavaConfig 导入<ul><li><code>@import(配置类,class,...)</code></li><li><code>@importResource(xml文件)</code></li></ul></li><li>XML 导入<ul><li>&lt;import resource=“xml 文件”/&gt;</li><li>&lt;bean class=“配置类”/&gt;</li></ul></li></ol></li></ol><h2 id="aop解决什么问题开发要点是什么"><a class="anchor" href="#aop解决什么问题开发要点是什么">#</a> AOP 解决什么问题？开发要点是什么？</h2><ul><li>通过<strong>预编译方式</strong>和<strong>运行期间动态代理</strong>实现程序功能的统一维护的一种技术</li><li>利用 AOP 可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li></ul><p>AOP 面向接口的编程，增强模块化，将影响多个模块但又与业务逻辑不直接相关的问题提取出（安全、日志、事务、缓存等），实现横切关注点，提高代码的可维护性和可读性，降低耦合</p><p>开发要点：定义通知 Advice、切点 Pointcut、Aspect 等，确定在何时、何处切入，完成什么操作</p><ol><li><strong>通知 Advice</strong>：切面要做什么以及何时做<ol><li>时间：方法前 / 后…</li></ol></li><li><strong>切点 Pointcut</strong>：指定在何处切<ol><li>Spring 只支持在方法的前后切</li><li>写<strong>切点表达式</strong>指定逻辑</li></ol></li><li><strong>切面 Aspect</strong>：Advice 和 Pointcut 的结合<ol><li>包含切的所有逻辑</li></ol></li><li><strong>连接点 Join point</strong>：方法、字段修改、构造方法</li><li><strong>引入 introduction</strong>：引入新的行为和状态<ol><li>给对象加入新的方法 / 状态，但不需要实现新的子类。在原来的对象上动态加入新的方法 / 状态。</li><li>引入方式<ul><li>创建需要增加的接口和实现类</li><li>新建一个切面类，加 <code>@Aspect</code></li><li>在里面定义一个新增实现类的 <code>static</code> 接口，加上 <code>@DeclareParents</code> 注解</li><li>实例化切面类 Bean</li></ul></li></ol></li><li><strong>织入 Weaving</strong>：切面应用到目标对象的过程</li></ol><h2 id="spring-web-开发框架的分层"><a class="anchor" href="#spring-web-开发框架的分层">#</a> Spring Web 开发框架的分层</h2><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA5YjMyODU3NGM5ODU4MzZkNTQ1ZTM2M2UyZjBlNGJfeFRPMjVlUmlMMFRmZm5aUllldHBqMGx3Q1ljU2JtTTBfVG9rZW46Q0lONWJGWWprb3hPZ2J4ZzNleWNNOHNxblFiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="web框架请求的处理过程"><a class="anchor" href="#web框架请求的处理过程">#</a> Web 框架请求的处理过程</h2><h3 id="客户端请求参数分类"><a class="anchor" href="#客户端请求参数分类">#</a> 客户端请求参数分类</h3><ol><li>路径参数， <code>@PathVariable</code></li><li>请求参数（查询参数）， <code>@RequestParam</code></li><li>表单参数，应用于前后端不分离的传统场景，默认，对应 model 对象，可以使用 <code>@Valid</code> 校验</li><li><code>json</code> 请求体，应用于前后端分离的场景，使用 <code>@RequestBody</code> 把 <code>json</code> 格式转成 java 对象； <code>@ResponseBody</code> ，把 java 对象转成 <code>json</code> 格式</li></ol><h3 id="处理流程"><a class="anchor" href="#处理流程">#</a> 处理流程</h3><ol><li>控制器根据 url 捕获请求，控制器解析并获取参数，同时将转向业务层进行处理</li><li>涉及到数据的持久化则访问数据访问层，访问完毕后返回业务层，业务层处理完毕将结果数据返回到控制器</li><li>控制器的响应处理：<ol><li>前后端分离：返回 Java 对象，同时加上 <code>@ResponseBody</code> 注解，表示返回的对象将被自动转换为 JSON 或其他格式。前端处理数据并渲染到页面上。</li><li>前后端不分离：控制器将数据赋值给 model 的属性，并返回视图名；根据视图名做视图解析，找到模板路径；通过第三方页面渲染，将 model 数据渲染到最终页面中，返回 html 格式文件。</li></ol></li></ol><p>在类的上方加注解 <code>@RestController</code> 。</p><h2 id="mvc架构"><a class="anchor" href="#mvc架构">#</a> MVC 架构</h2><p><strong>M</strong>odel-<strong>V</strong>iew-<strong>C</strong>ontroller</p><p>MVC 模式用于前后端不分离的开发场景</p><ul><li>模型 model：处理业务逻辑；存储、读取、处理数据</li><li>控制器 controller：处理用户输入，处理客户端的请求；返回数据（model）</li><li>视图 view：显示内容，model 和 view 结合</li></ul><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJhMTQ3NjE1YTRmZTk0NWMwMTJkN2RmMTI3YzA4ZmZfU2pRTE1aMTZDbHI3Y1lZcFBEUjVCQ25BN2VKT1R4SnVfVG9rZW46TWw4V2JCODJJb3pDM214UDRlQWN5Wm5YbmtjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="spring-mvc的请求过程"><a class="anchor" href="#spring-mvc的请求过程">#</a> Spring MVC 的请求过程</h2><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc1ZDQ1MTAxMDU5YjVmNDQ0YjQ1NGQ4ZTMyMWEyYTRfdG9XbnpDZWxFbDVCM2dzUk96NHNJYUlybWFPSzVkY3VfVG9rZW46THNsRWI1Wml1b01yaXd4WmpDa2NFTG1FbkRUXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><p>客户端请求在<strong>后端的处理过程</strong>，非常重要。 <strong>核心 DispatcherServlet</strong>，是 Spring 自己实现的 Servlet 容器。</p><ol><li>Web 容器开发的基本单元是 Servlet，请求 request 先到 servlet。</li><li>spring 框架做参数解析，使用 handler mapping 根据 url 把请求转到对应的 controller。</li><li>controller 处理请求和请求参数，把结果传给业务层</li><li>业务层处理业务逻辑，业务层访问数据层；业务层把处理结果返回控制器</li><li>控制器把结果返回给 servlet</li><li>servlet 拿到了数据和逻辑视图名，找到视图解析器的第三方库</li><li>视图解析器渲染视图</li></ol><h2 id="关系型数据访问层开发的三种方法区别-相同点"><a class="anchor" href="#关系型数据访问层开发的三种方法区别-相同点">#</a> 关系型数据访问层开发的三种方法区别、相同点</h2><ol><li>使用 jdbcTemplate 简化 JDBC 访问（spring-boot-starter-jdbc）</li><li>Spring Data JDBC（spring-boot-starter-data-jdbc）</li><li>Spring Data JPA（spring-boot-starter-data-jpa）</li></ol><p>区别：</p><ol><li>数据表生成：1、2 需要 scheme.sql 脚本，3 不需要（根据领域类自动生成）</li><li>数据 model 的定义：<ol><li>领域类注解：1 不需要为领域类加注解，2、3 要为领域类加注解（提供领域类和表结构的映射关系）<ol><li>2：@Table， @Column，@Id</li><li>3: @Entity， @Id</li></ol></li><li>ID 字段的处理：1 需要手动获取数据库生成的 Id，2、3 不需要</li></ol></li><li>数据库访问层接口 / 自定义查询：<ol><li>1 需要自己实现接口；</li><li>2、3 不需要，2、3 都继承自 CrudRepository 接口，且可以自定义查询：<ol><li>2、3 都可以使用 @Querry 定义查询逻辑</li><li>但 3 还可以使用基于方法名的<strong> DSL 自定义</strong>查询，JPA 在自定义逻辑上更加灵活</li><li><code>List&lt;TacoOrder&gt; findByDeliveryZip(String deliveryZip);</code></li></ol></li></ol></li><li>包路径：2、3 为领域类添加持久化的注解包路径不一样<ol><li>JPA 中的规范注解都来自 <code>javax.persisitence.*</code> ，因为不是 Spring 自己实现</li><li>@Table，对象会基于领域类的名称映射到数据库的表上</li><li>@Id<ul><li>有两个来自不同包的 @Id，注意区别</li></ul></li><li>@Column</li></ol></li></ol><table><thead><tr><th><strong>特点</strong></th><th></th><th><strong>jdbcTemplate</strong></th><th><strong>Spring Data JDBC</strong></th><th><strong>Spring Data JPA</strong></th></tr></thead><tbody><tr><td>数据表生成</td><td></td><td>需要 scheme.sql 脚本</td><td>需要 scheme.sql 脚本</td><td>不需要</td></tr><tr><td>数据 model 的定义</td><td>领域类注解（提供领域类和表结构的映射关系）</td><td>不需要</td><td>需要</td><td>需要</td></tr><tr><td>ID 字段的处理</td><td>手动生成</td><td>不需要</td><td>不需要</td><td></td></tr><tr><td>数据库访问层接口 / 自定义查询</td><td>接口</td><td>自己实现</td><td>继承自 CrudRepository 接口</td><td>继承自 CrudRepository 接口</td></tr><tr><td>@Querry 定义</td><td></td><td></td><td>基于方法名的 DSL 自定义查询</td><td></td></tr><tr><td>包路径</td><td></td><td></td><td></td><td>JPA 中的规范注解都来自 <code>javax.persisitence.*</code></td></tr></tbody></table><h2 id="给了spring框架开发人员还要做什么"><a class="anchor" href="#给了spring框架开发人员还要做什么">#</a> 给了 Spring 框架，开发人员还要做什么？</h2><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJkMjBiMjYyMDVlNjU1OGQ4NzkxNzhjODI2ZmYxMDBfRWZOU2FaWHRZUWU1OVN1a2xGenc0UTRFTWthWmF6TE1fVG9rZW46RjRiS2JYVkxXb0VPeWF4TThlZGM5RTBabmZjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><ol><li>实现接口<ol><li><code>UserDetailsService</code> 接口：给 Spring 框架提供用户详细信息。用户信息注册、存储和查询。<ul><li>这里用到之前讲到数据访问层实现技术。</li><li>和 spring security 解耦，只需要提供用户信息但不关心怎么实现。被 Spring Security 调用</li></ul></li></ol></li><li>实现密码加密 / 解密<ol><li>PasswordEncoder 加密和解密的过程，springboot 提供了若干个</li><li>Bean 对象</li></ol></li><li>(optional) 实现登录页面<ol><li>有默认页面，也可以自己实现</li><li><code>/login</code> , Spring 已经自动实现了对应的 <code>Controller</code></li></ol></li><li>调用<strong> HTTPSecurity 进行权限设置</strong>，分为两种：<ol><li><code>SecurityFilterChain</code> 实现，基于注入的 <code>httpSecurity</code> 对象</li><li>继承父类 <code>WebSecurityConfigurerAdapter</code> ，实现 <code>configure</code> 方法</li></ol></li></ol><p>PasswordEncoder：密码不能明文存储，需要加密后再存到数据库里</p><ul><li>需要定义 <code>Bean</code></li></ul><p>框架帮我们做了哪些事情：</p><ol><li>实现用户登录控制器（get、post）</li><li>请求重定向到用户登录页面<ol><li>eg. 用户未登录时，访问 URL，服务端重定向到登录页面</li></ol></li><li>通过 Filter 对设定的权限进行控制（自己只需要做权限的设定即可）</li></ol><h2 id="用户信息存储"><a class="anchor" href="#用户信息存储">#</a> 用户信息存储</h2><ul><li>内存用户存储<ul><li>小型应用</li></ul></li><li>JDBC 用户存储<ul><li>持久化数据</li></ul></li><li>LDAP（Lightweight Directory Access Protocol） 用户存储<ul><li>轻量级目录访问协议，适用于大型企业，支持复杂查询和目录结构</li></ul></li></ul><h2 id="属性来源"><a class="anchor" href="#属性来源">#</a> 属性来源</h2><p>不仅仅是 Spring Boot 需要的属性，也包含我们自己定义的属性。</p><p>常见的是第一个和第四个，第二个和第三个偶尔用</p><ol><li><strong>配置文件</strong> <code>application.yml</code> 、 <code>application.properties</code> ，两个文件可以混用<ol><li><code>server.port = 8090</code></li></ol></li><li><strong>命令行参数</strong> <code>commandLineArgs</code> ，在程序中直接获取<ol><li><code>java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar -- server.port=8081</code></li></ol></li><li><strong>JVM 系统参数</strong> <code>-D</code><ol><li><code>java -Dserver.port=8091 -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</code></li></ol></li><li><strong>操作系统环境变量</strong><ol><li><code>set SERVER_PORT=8082、java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</code></li></ol></li></ol><h2 id="接口设计的关键要求"><a class="anchor" href="#接口设计的关键要求">#</a> 接口设计的关键要求</h2><p>接口设计的关键要求：</p><ol><li>使用标准动词：GET\POST\PUT\DELETE，映射到 CRUD</li><li>使用 URI 来传达意图，URI 用名词不用动词，表明单复数 tacos</li><li>请求和响应使用 json，基本上大家都是用 json 标准，方便与第三方交流和解决问题</li><li>HTTP 状态码表示结果：200、201（created）等</li></ol><h2 id="oauth2流程图"><a class="anchor" href="#oauth2流程图">#</a> OAuth2 流程图</h2><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE5MDBhYTQwMjVmOWFiZWQ0ZGI1NTNlMGE4YjhlOGNfUEJmczBTT0RwZzFqSVo5NXpkRkh0TWM4bExMNWttM3NfVG9rZW46TG9ROWJuQnNYbzhRRjF4d0c0YmNEU2NYbndkXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><p>主体对象：</p><ol><li>Authserver 授权服务器：授权、认证</li><li>Authorization server 资源服务器</li><li>Client application 客户端应用程序</li><li>User 用户</li></ol><p>过程：</p><p>其中使用<strong>授权码授权模式</strong></p><ol><li>用户使用第三方的应用程序，也就是客户端应用程序</li><li>客户端发现用户未登录，把用户请求<strong>重定向</strong>到授权服务器<ol><li>授权服务器会维护合法的重定向地址，用于校验</li></ol></li><li>授权服务器向用户索取用户名密码</li><li>用户名密码匹配，则授权服务器请求用户授权</li><li><strong>授权服务器给客户端程序返回 code</strong>，重定向回到应用程序<ol><li>code 需要经过浏览器</li></ol></li><li><strong>客户端应用程序用 code 向授权服务器索取 token</strong><ol><li>用 code 交换 token</li><li>token 不过浏览器，在应用程序服务端和授权服务器之间处理</li></ol></li><li>客户端在请求头带上 token 调用资源服务器的 API</li><li>资源服务器验证 token，返回结果<ol><li>授权服务器会用<strong>私钥</strong>给 token 签名，资源服务器用<strong>公钥</strong>验证 token 是否合法</li><li>第一次，资源服务器向授权服务器索取公钥，验证 Token 合法性</li><li>Token 未过期时，不用再次索取公钥</li><li>Token 过期时，才会重新索取公钥</li></ol></li><li>客户端程序把结果返回给用户</li></ol><p>补充：</p><p>密码没有在浏览器来回传送，但是如果没有密码即使拿到 code 也没用</p><p>用 code 向授权服务器换取 token 才需要密码</p><h2 id="rabbitmq组成"><a class="anchor" href="#rabbitmq组成">#</a> RabbitMQ 组成</h2><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NDg5MTZlMGVlYWI0OWI1ODJkMWEyOTI0MjJjOTA0YmZfaTE2Qk82UzduSloyTXc4N01iTUcwWmhPbEgxM0M4Ym1fVG9rZW46V2Q3b2JzV2hCb0FNdDF4V0E1VGNQZlNNblBoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><ul><li>ConnectionFactory、Connection、Channel</li><li>Exchange：<ul><li>Default、Direct、Topic、Fanout、Headers、Dead letter</li></ul></li><li>Queue</li><li><strong>Routing key</strong>：exchange 根据 routing key 确定消息发往哪个队列<ul><li><strong>JMS 里没有这个概念</strong></li></ul></li><li><strong>Binding key</strong></li></ul><h2 id="reactive-programming反应式编程解决什么问题"><a class="anchor" href="#reactive-programming反应式编程解决什么问题">#</a> Reactive Programming 反应式编程解决什么问题？</h2><ul><li>IO 密集型场景</li><li>同步阻塞模型，阻塞线程多，CPU 利⽤率不⾼，性能下降 —— 轮询解决</li><li>管理多线程，意味着更⾼的复杂性</li></ul><h2 id="java的stream和反应式流的区别"><a class="anchor" href="#java的stream和反应式流的区别">#</a> Java 的 Stream 和反应式流的区别</h2><p>Java 的 stream 通常都是同步的，并且只能处理有限的数据集，本质上来说，它们只是使⽤函数来对集合进⾏迭代的⼀种⽅式</p><p>JDK9 中的 Flow API 对应反应式流</p><h2 id="反应式流规范定义的4个接口"><a class="anchor" href="#反应式流规范定义的4个接口">#</a> 反应式流规范定义的 4 个接口</h2><ul><li>org.reactivestrea</li><li>ms.*</li></ul><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA0YzcwNjU1Mzc3ZDA2YmU4YjU4MDkyMWQyMjg3M2JfWlFtaGo2NTY4amRRbE41OXBaSU1CRjFTd29OTVBUbHpfVG9rZW46TkdwR2J0Q2dhbzhSZGR4WUREcGN6bHE1bkJnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><ul><li>Publisher：数据发布者<ul><li>subscribe</li></ul></li><li>Subscriber：数据订阅者<ul><li>onSubscribe 第一次建立连接时调用</li><li>onNext</li><li>onError</li><li>onComplete</li><li>消费者：如果⽣产者产⽣数据的速度⾮常快，消费者会来不及处理，⽤回压来调节，根据消费者的速度来发送数据。</li></ul></li><li>Processor：处理器，既是数据的消费者，也是数据的发布者</li><li>Subscription：协调者，在 Publisher 和 Subscriber 之间传递消息<ul><li>request</li><li>cancel</li></ul></li></ul><p>每个环节可能会在不同的线程⾥处理，处理过程是异步的。</p><p>消费者驱动，消费者去请求发布者才会发布数据</p><h2 id="spring-integration集成流解决什么问题"><a class="anchor" href="#spring-integration集成流解决什么问题">#</a> Spring Integration 集成流解决什么问题</h2><p>提供了一系列的组件和配置选项，用于在应用程序中实现消息传递和集成模式。</p><p>解耦合、异步处理、轻量级集成</p><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJmNWE4MzA2MTdhNDc2YjQ1YTE5MTNhNTEyZTQ3NjZfYkRwQ1RJd0N0NUdobE8xYnd5NmRka1dxZ1N3blFMWTBfVG9rZW46RGFBbmJBcFYxb1pDVnd4a2R2WmNjaDBubldkXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFmZTYxMjhkZDdhMzczOTU3ZTU3MzU0ZjIzMmEwOTBfbDd3VWZPMml0UDNobHpzUFV5THBHN3VobkxJRHRERXVfVG9rZW46Tnh0VmJQc09Qb1AzSGV4aGQyNWN1UGtMbmpoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="mapflatmap"><a class="anchor" href="#mapflatmap">#</a> map/flatMap</h2><ul><li>map：<ul><li>同步</li><li>返回具体值</li></ul></li><li><strong>flatMap</strong>：<ul><li>异步</li><li>转换出来的<strong>返回结果还是一个流（Mono/Flux）</strong></li><li>可以<strong>并发处理</strong>，指定用哪个并发模型处理<ul><li>多个流并发处理结果合并成一个流，但结果顺序不可控</li></ul></li><li><strong>扁平化</strong></li></ul></li><li><strong>并发模型（Schedulers 方法）</strong><ul><li>.immediate()</li><li>.single()</li><li>.newSingle()</li><li>.elastic()</li><li>.parallel()</li><li><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYyMDkyZjNkNTVkNjk3ZGQ4NTg2NDU4ZTI1ODdjNDlfR0dRNmlQOEdTaWZQT2ZWdjNLb0VsYnEyQlJuRzdNOFJfVG9rZW46QkoxNWJ5S0NWb2MyZUt4eU1KQWMwVzhubmUwXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></li><li></li></ul></li></ul><h2 id="docker的三部分"><a class="anchor" href="#docker的三部分">#</a> docker 的三部分</h2><p>容器：一个轻量化的虚拟机</p><ul><li>哪三部分？<ul><li>docker engine：服务端，管理一系列资源的生命周期，包括容器 containers、images 和 volumns</li><li>Client：一个命令行程序，和 docker daemon 交互</li><li>Registry：镜像仓库，上传和下载镜像 images</li></ul></li><li>每一部分由哪些部分构成？</li></ul><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ1ODkxOWQ2YjFkZWRiMGQzMGM2YmI4MjQzNTRhZDJfY1FEamZkNzBMbXVZeld5Zk9oejBLSFFBMlF2VjJzNm9fVG9rZW46UUJRU2JJd2pVb1FqVDV4WTNRMmNsYjQ5bktmXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="容器与虚拟机的区别"><a class="anchor" href="#容器与虚拟机的区别">#</a> 容器与虚拟机的区别</h2><p>容器是在 Linux 内核实现的轻量级资源隔离机制</p><p>虚拟机是操作系统级别的资源隔离，容器本质上是进程级的资源隔离</p><h2 id="pod-container与node之间的关系"><a class="anchor" href="#pod-container与node之间的关系">#</a> Pod container 与 node 之间的关系</h2><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg2MTgzNTg3YzQxZTBmNzU1MmNmZWI4ZDJiYzU3ZWRfN3M2TEJaeFpQVjN5MHNHV3lNTExZNnVPVllxWkZjMHpfVG9rZW46Vzh6UWJuS0lIb0hoYm14Z0k3d2NRMmhPbmZmXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><h2 id="spring-mvc与spring-webflux的共性与不同"><a class="anchor" href="#spring-mvc与spring-webflux的共性与不同">#</a> Spring MVC 与 Spring WebFlux 的共性与不同</h2><ul><li>不同<ul><li>MVC：依赖多线程处理</li><li>WebFlux：在事件轮询中处理请求<ul><li>可以使用纯粹的函数式编程实现 Controller</li></ul></li></ul></li><li>共性<ul><li>WebFlux 也可以使用 Controller、RequestMapping 等注解<ul><li>WebFlux 的参数和返回值可能是流</li></ul></li></ul></li></ul><p><img data-src="https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=N2VkNWZjNmQ2YWUyODUyNjM5ZTkyMWNhYTAxMWYwOGJfUkpWV29ud0F5NjV6SHBCYmFQNEJFTFh4TjJBQXVOSmdfVG9rZW46SWxkc2JLY2Jnb3J5RUt4MTZJOWNyNnc1bmtnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA" alt="img"></p><div class="tags"><a href="/undergraduate/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag"><i class="ic i-tag"></i> 服务端开发</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-01-15 12:35:46" itemprop="dateModified" datetime="2024-01-15T12:35:46+08:00">2024-01-15</time> </span><span id="2024/01/15/NJUSE/服务端期末复习/" class="item leancloud_visitors" data-flag-title="服务端期末复习" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/undergraduate/images/wechatpay.jpg" alt="quas-modo 微信支付"><p>微信支付</p></div><div><img data-src="/undergraduate/images/alipay.jpg" alt="quas-modo 支付宝"><p>支付宝</p></div><div><img data-src="/undergraduate/images/paypal.png" alt="quas-modo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>quas-modo <i class="ic i-at"><em>@</em></i>Carpe diem</li><li class="link"><strong>本文链接：</strong> <a href="https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="服务端期末复习">https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/服务端期末复习/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;quasdo.oss-cn-hangzhou.aliyuncs.com&#x2F;img&#x2F;wenjun-lin-asset (4).jpg" title="软件测试期末复习"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 软件测试</span><h3>软件测试期末复习</h3></a></div><div class="item right"><a href="/undergraduate/2024/01/15/NJUSE/%E4%BA%BA%E6%9C%BA2023%E5%9B%9E%E5%BF%86/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;quasdo.oss-cn-hangzhou.aliyuncs.com&#x2F;img&#x2F;wenjun-lin-chinese-shadow-puppetry.jpg" title="人机交互-2023fall回忆"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 人机交互</span><h3>人机交互-2023fall回忆</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%80%89%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">多选题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.</span> <span class="toc-text">核心技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aop"><span class="toc-number">1.3.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">横切关注点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#advice%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">Advice 注解类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aspectj%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">AspectJ 可以实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-mvc"><span class="toc-number">1.4.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%81%E6%9C%89component%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.4.1.</span> <span class="toc-text">谁有 @Component 的效果？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-mvc%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">Spring MVC 获取参数的几种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-data-jdbcjpa"><span class="toc-number">1.5.</span> <span class="toc-text">Spring Data JDBC&#x2F;JPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.1.</span> <span class="toc-text">数据表创建和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">异常体系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springdata-mongodbredis"><span class="toc-number">1.6.</span> <span class="toc-text">SpringData MongoDB\Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.1.</span> <span class="toc-text">Nosql 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">MongoDB 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.3.</span> <span class="toc-text">MongoDB 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.4.</span> <span class="toc-text">Redis 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.</span> <span class="toc-text">Redis 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%8C%87%E5%AE%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">1.6.6.</span> <span class="toc-text">Redis 指定序列化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-security"><span class="toc-number">1.7.</span> <span class="toc-text">Spring Security</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%89%E5%85%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">实现方法级别的安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E7%9A%84%E7%94%A8%E6%88%B7"><span class="toc-number">1.7.2.</span> <span class="toc-text">获取当前登录的用户</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.</span> <span class="toc-text">配置属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#actuator"><span class="toc-number">1.8.1.</span> <span class="toc-text">Actuator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rest-api"><span class="toc-number">1.9.</span> <span class="toc-text">Rest API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#requestmapping"><span class="toc-number">1.9.1.</span> <span class="toc-text">RequestMapping&#x2F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restcontroller"><span class="toc-number">1.9.2.</span> <span class="toc-text">RestController</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-number">1.9.3.</span> <span class="toc-text">响应头与响应体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oauth2"><span class="toc-number">1.10.</span> <span class="toc-text">OAuth2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.11.</span> <span class="toc-text">消息中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jms"><span class="toc-number">1.11.2.</span> <span class="toc-text">JMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activemq"><span class="toc-number">1.11.3.</span> <span class="toc-text">ActiveMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">关键概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.4.</span> <span class="toc-text">接收模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#351-%E6%8B%89%E5%8F%96%E6%A8%A1%E5%BC%8F-pull-model"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">3.5.1. 拉取模式 pull model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#352-%E6%8E%A8%E9%80%81%E6%A8%A1%E5%BC%8F-push-model"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">3.5.2. 推送模式 push model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq"><span class="toc-number">1.11.5.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E4%B8%AD%E7%9A%84%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF%E5%92%8Cip%E5%9C%B0%E5%9D%80"><span class="toc-number">1.12.</span> <span class="toc-text">如何查看镜像中的网卡信息和 ip 地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#integration"><span class="toc-number">1.13.</span> <span class="toc-text">Integration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#service-activators"><span class="toc-number">1.13.1.</span> <span class="toc-text">Service activators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gateways"><span class="toc-number">1.13.2.</span> <span class="toc-text">Gateways</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-adapters"><span class="toc-number">1.13.3.</span> <span class="toc-text">Channel adapters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.14.</span> <span class="toc-text">反应式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.1.</span> <span class="toc-text">操作类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webflux"><span class="toc-number">1.15.</span> <span class="toc-text">WebFlux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.15.1.</span> <span class="toc-text">使用函数式编程范式来定义控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B6%89%E5%8F%8A%E7%9A%844%E4%B8%AA%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.15.2.</span> <span class="toc-text">函数式编程模型涉及的 4 个类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">简答题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">Bean 的三种注入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setter%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">setter 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5%E4%B8%8B%E5%8A%A0autowired"><span class="toc-number">2.1.3.</span> <span class="toc-text">属性字段下加 @Autowired</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.</span> <span class="toc-text">Spring 配置方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aop%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.</span> <span class="toc-text">AOP 解决什么问题？开发要点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-web-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E7%9A%84%E5%88%86%E5%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">Spring Web 开发框架的分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%A1%86%E6%9E%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">Web 框架请求的处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.1.</span> <span class="toc-text">客户端请求参数分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mvc%E6%9E%B6%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text">MVC 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-mvc%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">Spring MVC 的请求过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB-%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">2.8.</span> <span class="toc-text">关系型数据访问层开发的三种方法区别、相同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E4%BA%86spring%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">2.9.</span> <span class="toc-text">给了 Spring 框架，开发人员还要做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">2.10.</span> <span class="toc-text">用户信息存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%9D%A5%E6%BA%90"><span class="toc-number">2.11.</span> <span class="toc-text">属性来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B3%E9%94%AE%E8%A6%81%E6%B1%82"><span class="toc-number">2.12.</span> <span class="toc-text">接口设计的关键要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oauth2%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.13.</span> <span class="toc-text">OAuth2 流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rabbitmq%E7%BB%84%E6%88%90"><span class="toc-number">2.14.</span> <span class="toc-text">RabbitMQ 组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reactive-programming%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.15.</span> <span class="toc-text">Reactive Programming 反应式编程解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84stream%E5%92%8C%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">Java 的 Stream 和反应式流的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%B5%81%E8%A7%84%E8%8C%83%E5%AE%9A%E4%B9%89%E7%9A%844%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.17.</span> <span class="toc-text">反应式流规范定义的 4 个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-integration%E9%9B%86%E6%88%90%E6%B5%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.18.</span> <span class="toc-text">Spring Integration 集成流解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mapflatmap"><span class="toc-number">2.19.</span> <span class="toc-text">map&#x2F;flatMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E7%9A%84%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-number">2.20.</span> <span class="toc-text">docker 的三部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.21.</span> <span class="toc-text">容器与虚拟机的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod-container%E4%B8%8Enode%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.22.</span> <span class="toc-text">Pod container 与 node 之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-mvc%E4%B8%8Espring-webflux%E7%9A%84%E5%85%B1%E6%80%A7%E4%B8%8E%E4%B8%8D%E5%90%8C"><span class="toc-number">2.23.</span> <span class="toc-text">Spring MVC 与 Spring WebFlux 的共性与不同</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="bookmark" title="服务端期末复习">服务端期末复习</a></li><li><a href="/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/" rel="bookmark" title="服务端2023期末回忆">服务端2023期末回忆</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="quas-modo" data-src="/undergraduate/images/avatar.png"><p class="name" itemprop="name">quas-modo</p><div class="description" itemprop="description">notes/thoughts/nonsense</div></div><nav class="state"><div class="item posts"><a href="/undergraduate/archives/"><span class="count">85</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/undergraduate/categories/"><span class="count">27</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/undergraduate/tags/"><span class="count">23</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXMtbW9kbw==" title="https:&#x2F;&#x2F;github.com&#x2F;quas-modo"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/undergraduate/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/undergraduate/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/undergraduate/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/undergraduate/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/undergraduate/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/undergraduate/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/undergraduate/2024/01/15/NJUSE/%E4%BA%BA%E6%9C%BA2023%E5%9B%9E%E5%BF%86/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/undergraduate/2022/09/15/NJUSE/cpp/Lecture03-%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="Lecture03-结构化程序设计">Lecture03-结构化程序设计</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/undergraduate/2022/12/01/NJUSE/dataStructure/Lecture2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="Lecture2-时间复杂度">Lecture2-时间复杂度</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E9%9C%80%E6%B1%82/" title="分类于 需求">需求</a></div><span><a href="/undergraduate/2024/01/15/NJUSE/%E9%9C%80%E6%B1%82%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="需求期末复习">需求期末复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="分类于 软件测试">软件测试</a></div><span><a href="/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="软件测试期末复习">软件测试期末复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E9%9C%80%E6%B1%82/" title="分类于 需求">需求</a></div><span><a href="/undergraduate/2024/01/15/NJUSE/%E9%9C%80%E6%B1%822023%E5%9B%9E%E5%BF%86/" title="需求2023回忆">需求2023回忆</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="分类于 数据管理基础">数据管理基础</a></div><span><a href="/undergraduate/2023/06/14/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="数据管理基础期末复习">数据管理基础期末复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 服务端开发">服务端开发</a></div><span><a href="/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/" title="服务端2023期末回忆">服务端2023期末回忆</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/%E5%85%B6%E4%BB%96/" title="分类于 其他">其他</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/%E5%85%B6%E4%BB%96/%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6/" title="分类于 行业研究">行业研究</a></div><span><a href="/undergraduate/2022/10/14/NJU/%E9%83%91%E9%92%A2%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6%E8%AE%AD%E7%BB%83%E8%90%A5/20221013-%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="20221013-计算机">20221013-计算机</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/undergraduate/2022/09/15/NJUSE/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Lecture02-计算机体系结构的问题及解决方案">Lecture02-计算机体系结构的问题及解决方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/undergraduate/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/undergraduate/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/undergraduate/2022/11/15/NJUSE/COA/Lecture09-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/" title="Lecture09-外部存储器">Lecture09-外部存储器</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-quas-modo"></i> </span><span class="author" itemprop="copyrightHolder">quas-modo @ quas-modo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">411k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:14</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/01/15/NJUSE/服务端期末复习/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/undergraduate/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->