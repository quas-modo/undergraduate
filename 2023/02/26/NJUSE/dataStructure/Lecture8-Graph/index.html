<!-- build time:Mon Jan 15 2024 12:13:20 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Carpe diem" href="https://quas-modo.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Carpe diem" href="https://quas-modo.github.io/atom.xml"><link rel="alternate" type="application/json" title="Carpe diem" href="https://quas-modo.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="数据结构"><link rel="canonical" href="https://quas-modo.github.io/2023/02/26/NJUSE/dataStructure/Lecture8-Graph/"><title>Lecture8-Graph - 数据结构 - NJUSE | quas-modo = Carpe diem = pluck the day</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Lecture8-Graph</h1><div class="meta"><span class="item" title="创建时间：2023-02-26 22:01:29"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-02-26T22:01:29+08:00">2023-02-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">quas-modo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-20210203114915.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-chinese-shadow-puppetry.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (4).jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (2).jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/krenz-cushart-steampunk-color5-final.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (3).jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/NJUSE/" itemprop="item" rel="index" title="分类于 NJUSE"><span itemprop="name">NJUSE</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://quas-modo.github.io/2023/02/26/NJUSE/dataStructure/Lecture8-Graph/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="quas-modo"><meta itemprop="description" content="pluck the day, notes/thoughts/nonsense"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Carpe diem"></span><div class="body md" itemprop="articleBody"><h1 id="lecture8-图"><a class="anchor" href="#lecture8-图">#</a> Lecture8 - 图</h1><ul><li><p>考试重点</p></li><li><p>概念：选择填空为主</p></li><li><p>重点是理解</p></li><li><p>连通性、各种性质</p></li><li><p>强连通性、加权图、生成树 概念判断</p></li><li><p><strong>邻接表、邻接矩阵</strong>要求掌握</p></li><li><p>邻接二重表不考</p></li><li><p>遍历要求</p></li><li><p><strong>最小生成树算法</strong> 要求掌握重点</p><ul><li>kruskal</li><li>prim</li></ul></li><li><p><strong>最短路径</strong> 要求掌握重点</p><ul><li>Dijkstra</li><li><strong>BellmanFord</strong></li><li><strong>Floyed</strong></li></ul></li><li><p>证明都不要求</p></li><li><p>算法思想：除了动态规划不要求</p><ul><li>基本就是考考概念</li></ul></li><li><p><strong>BellmanFord 算法</strong>和<strong> Floyed 算法</strong>的算法流程要求</p></li><li><p><strong>活动网络</strong>常考</p><ul><li><p>包括拓扑排序</p></li><li><p>AOV 网络：<strong>概念</strong>多，爱出题</p><p>关键路径算法</p></li></ul></li></ul><p><strong>代码再仔细看看</strong></p><h1 id="图的定义"><a class="anchor" href="#图的定义">#</a> 图的定义</h1><ol><li><p><strong>Graph = (V, E)</strong></p><ol><li>V: nonempty finite vertice set(<strong>顶点集</strong>) 一个非空确定顶点个数的集合</li><li>E: edge set (边集)</li></ol></li><li><p>Undirected Graph 无向图</p><p>if the tuple denoting an edge is unordered, then (v1, v2) and (v2, v1) are the same edge.</p></li></ol><h2 id="有向图"><a class="anchor" href="#有向图">#</a> 有向图</h2><p>If the tuple (元组) denoting an edge is ordered, then &lt;v1,v2&gt; and &lt;v2,v1&gt; are different edges.</p><p>(如果表示的边的<strong>元组是有序</strong>的，也就是 &lt;v1,v2&gt; 和 &lt; v2,v1 &gt; 是不同的)</p><p>v1: 始点</p><p>v2: 终点</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png" alt="img"></a></p><p>In a directed graph with n nodes, the number of edges &lt;=n*(n-1). If “=” is satisfied, then it is called a complete directed graph*.</p><p>(一个有 n 个节点的有向图，其边的个数 &lt;= <em><em>n</em>(n-1)</em><em>，如果相等，则为是一个</em><em>完全有向图</em> *)</p><p>完全图 (有向完全图): 指有向图中每两个顶点都相互指向。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209141507512.png" alt="image-20221209141507512"></p><h2 id="无向图"><a class="anchor" href="#无向图">#</a> 无向图</h2><p>If the tuple denoting an edge is unordered, then (v1,v2) and (v2,v1) are the same edge.</p><p>(如果表示边的<strong>元组是无序</strong>的，则 (v1，v2) 和 (v2，v1) 是相同的边。)</p><p>In an undirected graph with n nodes, the number of edges &lt;= n*(n-1)/2. If “=” is satisfied, then it is called a complete undirect graph.</p><p>(在一个有 n 个顶点的无向图中，边的个数 &lt;= <strong>n(n-1)/2</strong>，如果刚好相等，则被称为完全无向图)</p><p>完全图 (无向完全图): 就是指每两个顶点之间都有一条边。</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/2.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/2.png" alt="img"></a></p><h2 id="其他图"><a class="anchor" href="#其他图">#</a> 其他图</h2><p>以下两种图在我们的数据结构中不进行讨论</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/3.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/3.png" alt="img"></a></p><p><strong>不考虑 自环 (ring) 和 多重边</strong> 的多重图。</p><h2 id="概念顶点的度数入度和出度"><a class="anchor" href="#概念顶点的度数入度和出度">#</a> 概念 —— 顶点的度数（入度和出度）</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214131905817.png" alt="image-20230214131905817"></p><ol><li><p>对于无向图只有度数，而对于有向图不仅仅有入度，还有出度。</p></li><li><p>degree dv of vertex v, <strong>TD(v)</strong>: is the number of edges incident on vertex v. In a directed graph :</p><p>(顶点 v 的度数为 dv，TD (V) 是顶点 v 的度数，在有向图中)</p><ol><li><p>in-degree of vertex v is the number of edges incident to v, <strong>ID(v)</strong>.</p><p>(顶点 v 的入度是指向顶点 v 的边的个数)</p></li><li><p>out-degree of vertex v is the number of edges incident from the v, <strong>OD(v)</strong>.</p><p>(顶点 v 的出度从 v 出发的边的个数)</p></li></ol></li><li><p>性质：(度数)<strong>TD(v)=ID(v)+OD(v)</strong></p><p>度数可以理解为，这个顶点的边</p></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/4.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/4.png" alt="img"></a></p><h2 id="图的性质"><a class="anchor" href="#图的性质">#</a> 图的性质</h2><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/9.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/9.png" alt="img"></a></p><p>所有的度数加起来是边的个数的两倍。</p><h2 id="子图"><a class="anchor" href="#子图">#</a> 子图</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214132334890.png" alt="image-20230214132334890"></p><p>Graph G=(V,E),G’=(V‘,E‘), if V’包含于 V, E’包含于 E, and the vertices incident on the edges in E’ are in V’, then G’ is the subgraph of G.</p><p>如果图 G 和图 G’，如果 V’包含于 V，E’包含于 E, 并且 E’中顶点的边也在 G’中，那么 G’是 G 的子图</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/5.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/5.png" alt="img"></a></p><h2 id="路径path"><a class="anchor" href="#路径path">#</a> 路径 (path)</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214132326704.png" alt="image-20230214132326704"></p><p>A sequence of vertices P=i1,i2,……ik is an i1 to ik path in the graph of graph G=(V,E) iff the edge(ij,ij+1)is in E for every j, 1 &lt;= j &lt; k.</p><p>在图 G=(V，E) 中，如果每 j 的边 (ij，ij+1) 在 E 中，1&lt;= j&lt; k，则顶点序列 P=i1，i2，…,ik 是 i1 到 ik 的路径。</p><h2 id="简单路径和环simple-path-and-cycle"><a class="anchor" href="#简单路径和环simple-path-and-cycle">#</a> 简单路径和环 (Simple path and cycle)</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214132416033.png" alt="image-20230214132416033"></p><ol><li><p>A Simple path is a path in which all vertices except possibly the first and last , are different.</p><p>(简单路径：路径除了第一个和最后一个顶点中<strong>没有出现相同</strong>的顶点)</p></li><li><p>A Simple cycle is a simple path with the same start and end vertex.</p><p>(简单回路：起点和终点相同的时候的简单路径)</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214132549580.png" alt="image-20230214132549580"></p></li></ol><h2 id="连通图和连通分量connected-graph-connected-component"><a class="anchor" href="#连通图和连通分量connected-graph-connected-component">#</a> 连通图和连通分量 (Connected graph &amp; Connected component)</h2><ol><li><p>In a undirected graph, if there is a path from vertex v1 to v2, then v1 and v2 are connected.</p><p>(在无向图中，如果 v1 到 v2 之间<strong>有一条路径</strong>，那么 v1 和 v2 是连通的)</p></li><li><p>In a undirected graph ,if two <strong>arbitrary</strong> vertices are connected, then the graph is a connected graph</p><p>(在无向图中，如果<strong>任意两个顶点是连通的，则该图是连通图</strong>)</p></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/6.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/6.png" alt="img"></a></p><p><strong>极大连通子图</strong>：就是结点个数最多的连通的子图。</p><h2 id="强联通图和强联通分量strong-connected-graph-and-strongly-connected-component"><a class="anchor" href="#强联通图和强联通分量strong-connected-graph-and-strongly-connected-component">#</a> 强联通图和强联通分量 (Strong connected graph and strongly connected component)</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214132823488.png" alt="image-20230214132823488"></p><ol><li><p>强连通图</p><p>有向图 digraph 是强连通的，当它包含从 i 到 j 和从 j 到 i 的有向路径时，对于每对不同的顶点 i 和 j</p><p>简单来说就是既要过的去，也要回得来</p></li><li><p>强连通分量</p><p>The maximum strong connected subgraph (极大强连通子图) of a non-strongly connected graph is called strongly connected conponent (强连通分量).</p><p>(一个<strong>非强连通图的最大强连通子图</strong> (South-South-PosialSuth-Posiple Fug) 称为强连通构 (Suth-Posiple Stand))</p></li></ol><h2 id="加权图network"><a class="anchor" href="#加权图network">#</a> 加权图 (Network)</h2><ol><li><p>When weights and costs are assigned to edges, the resulting data object is called <strong>weighted graph</strong> and <strong>weighted digraph.</strong></p><p>(当权值和代价分配给边时，得到的数据对象称为<strong>加权图</strong>和<strong>加权有向图</strong>。)</p></li><li><p>The term <strong>network</strong> refers to weighted connected graph and weighted connected digraph.</p><p>(<strong>加权图</strong>是用来代指加权连通图和加权连通有向图)</p></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/7.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/7.png" alt="img"></a></p><h2 id="生成树spanning-tree"><a class="anchor" href="#生成树spanning-tree">#</a> 生成树 (Spanning tree)</h2><p>A spanning tree of a connected graph is its minimum connected subgraph(<strong>极小连通子图</strong>). An n-vertex spanning tree has n-1 edges.</p><p>(连通图的<strong>生成树</strong>是其极小连通子图。n 顶点生成树有 n-1 条边。)</p><p>保持联通的最小边数的图</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/8.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/8.png" alt="img"></a></p><h1 id="adt-graph-and-digraph"><a class="anchor" href="#adt-graph-and-digraph">#</a> ADT Graph and Digraph</h1><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209142531480.png" alt="image-20221209142531480"></p><h1 id="representation-of-graphs-and-diagraphs"><a class="anchor" href="#representation-of-graphs-and-diagraphs">#</a> Representation of graphs and diagraphs</h1><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214133528703.png" alt="image-20230214133528703"></p><h2 id="adjacency-matrix-邻接矩阵"><a class="anchor" href="#adjacency-matrix-邻接矩阵">#</a> Adjacency Matrix 邻接矩阵</h2><p>graph 无向图</p><p>digraph 有向图</p><h3 id="无向图-2"><a class="anchor" href="#无向图-2">#</a> 无向图</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143030813.png" alt="image-20221209143030813"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143125763.png" alt="image-20221209143125763"></p><ol><li>无向图的邻接矩阵是一个<strong>对称矩阵</strong></li><li><strong>无向图的每个顶点的度数等于矩阵中每一行的和</strong>。</li></ol><h3 id="有向图-2"><a class="anchor" href="#有向图-2">#</a> 有向图</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143144805.png" alt="image-20221209143144805"></p><p>出度，一行的和；</p><p>入度，一列的和</p><h3 id="加权图"><a class="anchor" href="#加权图">#</a> 加权图</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143821067.png" alt="image-20221209143821067"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143829081.png" alt="image-20221209143829081"></p><h2 id="代码实现数组"><a class="anchor" href="#代码实现数组">#</a> 代码实现 —— 数组</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143933283.png" alt="image-20221209143933283"></p><p>dist 距离（权）</p><p>template&lt;class NameType, class DistType&gt; 是一种模板，意味着 class 用 NameType 和 DistType 进行定义</p><p>SeqList 是顺序表的意思</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209143953116.png" alt="image-20221209143953116"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209144000077.png" alt="image-20221209144000077"></p><h2 id="代码实现链表"><a class="anchor" href="#代码实现链表">#</a> 代码实现 —— 链表</h2><p><strong>邻接表</strong></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209144907924.png" alt="image-20221209144907924"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209144916071.png" alt="image-20221209144916071"></p><h3 id="声明"><a class="anchor" href="#声明">#</a> 声明</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145022064.png" alt="image-20221209145022064"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145032715.png" alt="image-20221209145032715"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145043254.png" alt="image-20221209145043254"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145423763.png" alt="image-20221209145423763"></p><h3 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145442706.png" alt="image-20221209145442706"></p><h3 id="找到在顶点表的位置"><a class="anchor" href="#找到在顶点表的位置">#</a> 找到在顶点表的位置</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145450950.png" alt="image-20221209145450950"></p><h3 id="给出顶点v的第一个邻接顶点的位置"><a class="anchor" href="#给出顶点v的第一个邻接顶点的位置">#</a> 给出顶点 V 的第一个邻接顶点的位置</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214134749181.png" alt="image-20230214134749181"></p><h3 id="找到下一个邻居"><a class="anchor" href="#找到下一个邻居">#</a> 找到下一个邻居</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209145509374.png" alt="image-20221209145509374"></p><h2 id="不考邻接多重表adjacency-multilist"><a class="anchor" href="#不考邻接多重表adjacency-multilist">#</a> 【不考】邻接多重表（adjacency multilist）</h2><ol><li>在无向图中，如果边数为 m, 则在邻接表表示中需 2m 个单位来存储。为了克服这一缺点，采用邻接多重表，每条边用一个结点表示.<ul><li>其中的两个结点号就是边的两个点。</li><li>path1 指向的就是同样始点 (vertex1)，顺序终点的结果。</li><li>path2 执行的是以 vertex2 为始点顺序向下的。</li></ul></li><li>Eg. 使用正常的邻接表，则右边应该有 10 个点，但是多重表就是只有 5 个表<ul><li>默认情况下边的始点的编号要小于终点的编号大小。</li></ul></li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209151914910.png" alt="image-20221209151914910"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209151930870.png" alt="image-20221209151930870"></p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/20.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/20.png" alt="img"></a></p><ol><li>邻接表和邻接多重表之间的区别在于有几个顶点，有几个边。</li><li>data 部分只记录 first-in 和 first-out，也就是第一条出边和第一条入边</li></ol><h1 id="图的遍历与连通性"><a class="anchor" href="#图的遍历与连通性">#</a> 图的遍历与连通性</h1><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209144224188.png" alt="image-20221209144224188"></p><h2 id="深度优先搜索depth-first-search"><a class="anchor" href="#深度优先搜索depth-first-search">#</a> 深度优先搜索 (Depth-first-search)</h2><h3 id="算法思想"><a class="anchor" href="#算法思想">#</a> 算法思想</h3><p>从图中某个顶点 V0 出发，访问它，然后选择一个<strong> V0</strong> 邻接到的<strong>未被访问的一个邻接点 V1</strong> 出发深度优先遍历图，当遇到一个所有邻接于它的结点都被访问过了的结点 U 时，回退到前一次<strong>刚被访问过的拥有未被访问的邻接点 W</strong>, 再从 W 出发深度遍历，…… 直到连通图中的所有顶点都被访问过为止.</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/22.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/22.png" alt="img"></a></p><p>递归方法实现 算法中用一个辅助数组<strong> visited []</strong>:</p><p>0: 未访问</p><p>1: 访问过了</p><p>我们假设图为连通图</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209153919037.png" alt="image-20221209153919037"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209153931254.png" alt="image-20221209153931254"></p><p><strong>算法分析</strong></p><p>用邻接表表示<strong> O (N+E)</strong></p><p>用邻接矩阵表示<strong> O (n<sup>2</sup>)</strong></p><h2 id="广度优先搜索breadth-search"><a class="anchor" href="#广度优先搜索breadth-search">#</a> 广度优先搜索 (Breadth search)</h2><h3 id="思想"><a class="anchor" href="#思想">#</a> 思想</h3><p>从图中某顶点 V0 出发，在访问了 V0 之后依次访问 v0 的各个未曾访问过的邻接点，然后分别从这些邻接点出发广度优先遍历图，直至图中所有顶点都被访问到为止.</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/23.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/23.png" alt="img"></a></p><p>算法同样需要一个辅助数组<strong> visited []</strong> 表示顶点是否被访问过。还需要一个队列，记正在访问的这一层和上一层的顶点。算法显然是<strong>非递归</strong>的.</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209154815385.png" alt="image-20221209154815385"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209154826520.png" alt="image-20221209154826520"></p><p><strong>算法分析</strong></p><p>用邻接表表示<strong> O (N+E)</strong></p><p>用邻接矩阵表示<strong> O (n<sup>2</sup>)</strong></p><h2 id="连通分量"><a class="anchor" href="#连通分量">#</a> 连通分量</h2><p>连通图：任意两个顶点是连通的。</p><p>以上讨论的是对一个无向的连通图或一个强连通图的有向图进行遍历，得到一棵深度优先或广度优先生成树。但当无向图（以无向图为例）为<strong>非连通图</strong>时，从图的某一顶点出发进行遍历（深度，广度）只能访问到该顶点所在的<strong>最大连通子图</strong>（即连通分量）的所有顶点。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209155103515.png" alt="image-20221209155103515"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209160239621.png" alt="image-20221209160239621"></p><p><strong>加一个循环语句即可</strong></p><h1 id="最小生成树minimum-cost-spinning-tree-mst"><a class="anchor" href="#最小生成树minimum-cost-spinning-tree-mst">#</a> 最小生成树 minimum-cost spinning tree MST</h1><h2 id="生成树"><a class="anchor" href="#生成树">#</a> 生成树</h2><h3 id="生成树的定义"><a class="anchor" href="#生成树的定义">#</a> 生成树的定义</h3><ol><li>设<strong> G =(V，E)<strong> 是一个</strong>连通</strong>的无向图 (或是强连通有向图) 从图 G 中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为 TE (G)，显然 **G‘=(V，TE)** 是 G 之子图， <strong>G‘被称为 G 的生成树 (spanning tree)</strong>，也称为一个连通图.</li><li>n 个结点的生成树有 n-1 条边。</li><li>生成树的代价 (cost)：<strong>TE (G) 上诸边的代价之和</strong></li><li>生成树不唯一</li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/24.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/24.png" alt="img"></a></p><h3 id="最小代价生成树"><a class="anchor" href="#最小代价生成树">#</a> 最小代价生成树</h3><p>各边权的<strong>总和</strong>为最小的生成树</p><h2 id="贪心grandy求解最小代价生成树"><a class="anchor" href="#贪心grandy求解最小代价生成树">#</a> 贪心 (Grandy) 求解最小代价生成树</h2><p>6 个城市已固定，现从一个城市发出信息到每一个城市如何选择或铺设通信线路，使花费 (造价) 最低。</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/25.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/25.png" alt="img"></a></p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/26.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/26.png" alt="img"></a></p><p>两个算法：Prim, Kruskal.</p><p>它们都使用了逐步求解（贪心算法）的策略。</p><h3 id="贪心策略的具体内容"><a class="anchor" href="#贪心策略的具体内容">#</a> 贪心策略的具体内容</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214163354394.png" alt="image-20230214163354394"></p><p>Grandy 策略：</p><p>设：连通网络 N={V,E}, V 中有 n 个顶点。</p><ol><li t0,t1,……,tn-1="">先构造 n 个顶点，0 条边的<strong>森林</strong> F =</li><li>每次向 F 中加入一条边。该边是一端在 F 的某棵树 Ti 上而另一端不在 Ti 上的所有边中具有最小权值的边。 这样使 F 中两棵树合并为一棵，树的棵数 - 1</li><li>重复上述操作 n-1 次</li></ol><p>去掉所有边，每次加入的边是当前最小的边，并且保证这个边不是回边。</p><h3 id="最小生成树的类声明"><a class="anchor" href="#最小生成树的类声明">#</a> 最小生成树的类声明</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209163836664.png" alt="image-20221209163836664"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209163925674.png" alt="image-20221209163925674"></p><h3 id="kruskal算法对边进行排序然后生成"><a class="anchor" href="#kruskal算法对边进行排序然后生成">#</a> Kruskal 算法 (对边进行排序，然后生成)</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214163725826.png" alt="image-20230214163725826"></p><p>把无向图的所有边排序</p><p>一开始的最小生成树为</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/28.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/28.png" alt="img"></a></p><p>在 E 中选一条代价最小的边 (u,v) 加入 T，一定要满足 (u,v) 不和 TE 中已有的边构成回路</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/29.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/29.png" alt="img"></a></p><p>一直到 TE 中加满 n-1 条边为止。</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/30.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/30.png" alt="img"></a></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209164108267.png" alt="image-20221209164108267"></p><p><strong>邻接矩阵</strong></p><h4 id="代码实现"><a class="anchor" href="#代码实现">#</a> 代码实现</h4><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209164144977.png" alt="image-20221209164144977"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209164151523.png" alt="image-20221209164151523"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221209164158409.png" alt="image-20221209164158409"></p><p>排序：建立最小堆</p><p>出堆操作：找到最小值</p><p>find 操作：？</p><p>union 操作：添加到数集中</p><h3 id="prim算法任何起点选可通达的最小权重的边"><a class="anchor" href="#prim算法任何起点选可通达的最小权重的边">#</a> Prim 算法（任何起点，选可通达的最小权重的边）</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214165855967.png" alt="image-20230214165855967"></p><p>设：原图的顶点集合 V (有 n 个) 生成树的顶点集合 U (最后也有 n 个)，一开始为空 TE 集合为 {}</p><p>步骤：</p><ol><li>U={1}<strong> 任何起始顶点</strong>，TE={}</li><li>每次生成 (选择) 一条边。这条边是所有边 (u,v) 中代价 (权) 最小的边， u∈U,v∈V-U TE=TE+[(u,v)]; U=U+[v]</li><li>当 U≠V，返回上面一个步骤</li></ol><h3 id="例子"><a class="anchor" href="#例子">#</a> 例子</h3><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/31.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/31.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/32.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/32.png" alt="img"></a></p><ol><li>一开始只考虑从 1 号顶点到其他顶点之间的边。<ul><li>泛泛而言，考虑 u 和 v 之间的边</li></ul></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/33.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/33.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/34.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/34.png" alt="img"></a></p><h3 id="最小生成树不唯一"><a class="anchor" href="#最小生成树不唯一">#</a> 最小生成树不唯一</h3><ol><li>对于一般的图来讲，最小生成树不唯一。</li><li>所以相应的 Prime 算法和 Kruskal 算法也会出现多解的情况</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214170520688.png" alt="image-20230214170520688"></p><h3 id="prim算法实例"><a class="anchor" href="#prim算法实例">#</a> prim 算法实例</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171319803.png" alt="image-20230214171319803"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171407861.png" alt="image-20230214171407861"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171416308.png" alt="image-20230214171416308"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171427973.png" alt="image-20230214171427973"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171433658.png" alt="image-20230214171433658"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171439317.png" alt="image-20230214171439317"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171444611.png" alt="image-20230214171444611"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214171452042.png" alt="image-20230214171452042"></p><h3 id="prim算法实现"><a class="anchor" href="#prim算法实现">#</a> Prim 算法实现</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214172406455.png" alt="image-20230214172406455"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214172414957.png" alt="image-20230214172414957"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214172423013.png" alt="image-20230214172423013"></p><h1 id="最短路径"><a class="anchor" href="#最短路径">#</a> 最短路径</h1><ol><li>设 G=(V,E) 是一个带权图 (有向，无向)，如果从顶点 v 到顶点 w 的一条路径为 (v,v1,v2,…,w)，其路径长度不大于从 v 到 w 的所有其它路径的长度，则该路径为从 v 到 w 的最短路径。</li><li>背景：在交通网络中，求各城镇间的最短路径。</li><li>三种算法:<ol><li>边上权值为非负情况的从一个结点到其它各结点的最短路径 (单源最短路径)(Dijkstra 算法)</li><li>边上权值为任意值的单源最短路径【边上存在负权值，但是没有负环】【不能出现小于零的环（负环），此时最小路径没有意义】</li><li>边上权值为非负情况的所有顶点之间的最短路径</li></ol></li></ol><h2 id="含非负权值的单源最短路径dijkstra"><a class="anchor" href="#含非负权值的单源最短路径dijkstra">#</a> 含非负权值的单源最短路径 (Dijkstra)</h2><p>每次从 「未求出最短路径的点」中 <strong>取出</strong> 距离距离起点 <strong>最小路径的点</strong>，以这个点为桥梁 <strong>刷新</strong>「未求出最短路径的点」的距离</p><ol><li>问题</li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/44.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/44.png" alt="img"></a></p><h3 id="贪心思想"><a class="anchor" href="#贪心思想">#</a> 贪心思想</h3><p>起点 V0，首先直接连接，不管是否直接连接。</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png" alt="img"></a></p><p>排好序后，V0-V1 10 已经是最小的了，不可能再找到更短的路径</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png" alt="img"></a></p><p>接下来，尝试 V0-v2 通过 V1 绕会不会比原来的更短 (考虑 V1-V2 直连)，V0-V4 从 V1 绕会不会比原来更短 (考虑 V2-V3 直连)，如果短则更新，此时 V0-V3 是三者中最小值，所以选择 V0-V3。</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png" alt="img"></a></p><p>尝试绕行 V3，计算直连，更新掉，然后重复</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png" alt="img"></a></p><p>红色是已经选择好的，绿色是绕行选择。</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png" alt="img"></a></p><p><strong>贪心：当前新产生的一条最短路径能否使已有路径在一步以内变短。</strong></p><p>进一步思考，就是只进行一步，不进行多步。</p><p>总体来讲：不可能走更长的路径，然后回来</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png" alt="img"></a></p><p>数值更新，路径数组对应位置更新</p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png"><img data-src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png" alt="img"></a></p><h3 id="代码实现-2"><a class="anchor" href="#代码实现-2">#</a> 代码实现</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214173554247.png" alt="image-20230214173554247"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214173607549.png" alt="image-20230214173607549"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> NumVertices <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">// 大于所有边的权重的值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">graph</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> Edge<span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> dist<span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> path<span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> S<span class="token punctuation">[</span>NumVertices<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">shortestpath</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Graph</span><span class="token double-colon punctuation">::</span><span class="token function">shortestpath</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">//v 为当前节点，dist 数组是表示距离的数组</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 遍历 n 次</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Edge<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span> i<span class="token operator">!=</span>v <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span> MAXNUM <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> v<span class="token punctuation">;</span><span class="token comment">// 如果可达，则用 path 数组记录下路径</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 如果不可达，则用 path 数组记录下不可达 (-1)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        s<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 表示访问过当前节点，并且距离为 0</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">float</span> min<span class="token operator">=</span>MAXNUM<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">int</span> u <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>  j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                    <span class="token comment">// 如果结点 j 还没有访问过，并且 dist [j] 小于最小值</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                    u <span class="token operator">=</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                    min <span class="token operator">=</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            s<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> w<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>s<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> Edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> MAXNUM <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>Edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                    <span class="token comment">//dist [u] 就是起点到 u 的距离，下面是关键条件</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                    dist<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>Edge<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                    path<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token comment">//for</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214173613313.png" alt="image-20230214173613313"></p><h2 id="边上权值为任意值的单源最短路径贝尔曼-福特bellemanford"><a class="anchor" href="#边上权值为任意值的单源最短路径贝尔曼-福特bellemanford">#</a> 边上权值为任意值的单源最短路径（贝尔曼 - 福特）BellemanFord</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214174453911.png" alt="image-20230214174453911"></p><p>distk 从<strong>源点 v</strong> 开始最多经过<strong>不构成带负长度边回路</strong>的<strong> k</strong> 条边的最短路径长度</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214174554207.png" alt="image-20230214174554207"></p><p><strong>递推公式</strong></p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/49.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/49.png" alt="img"></a></p><ol><li>更新的时候都是根据前面结果，遍历计算存储</li><li>所有<strong>第 k 步，只受第 k-1 步的影响</strong></li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214175305102.png" alt="image-20230214175305102"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span>  <span class="token class-name">Graph</span><span class="token double-colon punctuation">::</span><span class="token function">BellmanFord</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 动态规划</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 初始化 dist 距离数组</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Edge<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>v <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>MAXNUM<span class="token punctuation">)</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 初始化路径数组 </span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">else</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>u <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>u<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">!=</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token comment">// 一直算到 n-1 步</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> Edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">&lt;</span>MAXNUM <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">></span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>Edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                        dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>Edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                        path<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol><li>时间复杂度：O (n3)</li></ol><h2 id="所有顶点之间的最短路径floyed"><a class="anchor" href="#所有顶点之间的最短路径floyed">#</a> 所有顶点之间的最短路径（Floyed）</h2><ol><li>前提：各边权值<strong>均大于 0</strong> 的带权<strong>有向图</strong>。<ul><li>每个顶点到自己的代价为 0</li></ul></li><li>方法：<ol><li>把有向图的每一个顶点作为源点，重复执行 Dijkstra 算法 n 次，执行时间为 O (n<sup>3</sup>)</li><li>Floyed 方法，算法形式更简单些，但是时间仍然是 O (n<sup>3</sup>)</li></ol></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/50.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/50.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/51.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/52.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/52.png" alt="img"></a></p><ol><li>简单来说就是：每次都会选择一个<strong>中介点</strong>，然后遍历整个数组，更新相应的需要更新的数组。</li></ol><h3 id="floyed算法实现"><a class="anchor" href="#floyed算法实现">#</a> floyed 算法实现</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214193445295.png" alt="image-20230214193445295"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Graph</span><span class="token double-colon punctuation">::</span><span class="token function">Alllength</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>j<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>MAXNUM<span class="token punctuation">)</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">// 路由表</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">else</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">if</span><span class="token punctuation">(</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>path<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>矩阵S中的元素a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>表示顶点<span class="token function">i</span><span class="token punctuation">(</span>第i个顶点<span class="token punctuation">)</span>到顶点<span class="token function">j</span><span class="token punctuation">(</span>第j个顶点<span class="token punctuation">)</span>的距离。矩阵P中的元素b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>，表示顶点i到顶点j经过了b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>记录的值所表示的顶点。</pre></td></tr></table></figure><ol><li>算法复杂度：O (n3)</li><li>参考:<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQ0MjM0L2FydGljbGUvZGV0YWlscy82MDg3NTgxOA==">Floyed 算法</span></li></ol><h2 id="64-floyed算法参考"><a class="anchor" href="#64-floyed算法参考">#</a> 6.4. Floyed 算法参考</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQ0MjM0L2FydGljbGUvZGV0YWlscy82MDg3NTgxOA==">最短路径问题</span></li></ol><h1 id="活动网络-activity-network常考"><a class="anchor" href="#活动网络-activity-network常考">#</a> 活动网络 Activity Network（常考）</h1><ol><li>用顶点表示活动的网络 (AOV 网络)</li><li>用边表示活动的网络 (AOE 网络)</li><li>用顶点表示活动的网络</li></ol><h2 id="71-aov网络activity-on-vertex-network"><a class="anchor" href="#71-aov网络activity-on-vertex-network">#</a> 7.1. AOV 网络 Activity On Vertex network</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214200449558.png" alt="image-20230214200449558"></p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/53.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/53.png" alt="img"></a></p><h3 id="aov网络结构"><a class="anchor" href="#aov网络结构">#</a> AOV 网络结构</h3><ol><li><strong>图中表示课程</strong> (活动)，有向边 (弧) 表示先决条件。 若课程 i 是课程 j 的预修课程，则图中有弧 &lt; i,j&gt;</li><li>AOV 网 (<strong>Activity On Vertex network</strong>)<ul><li>用顶点表示活动，用弧表示活动间的优先关系的有向图称为 AOV 网。</li></ul></li><li>直接前驱，直接后继<ul><li>&lt;i,j&gt; 是网中一条弧，则 i 是 j 的直接前驱，j 是 i 的直接后继。</li></ul></li><li>前驱，后继<ul><li>从顶点 i-&gt; 顶点 j 有一条有向路径，则称 i 是 j 的前驱，j 是 i 的后继。</li></ul></li><li><strong>AOV 网中，不应该出现有向环</strong></li></ol><h3 id="aov图的拓扑排序"><a class="anchor" href="#aov图的拓扑排序">#</a> AOV 图的拓扑排序</h3><ol><li>有向图 G=(V,E),V 里结点的线性序列 (vi1,vi2,…,vin), 如果满足：在 G 中从结点 vi 到 vj 有一条路径，则序列中结点 Vi 必先于结点 vj ，称这样的线性序列为<strong>一拓扑序列</strong>。</li><li>不是任何有向图的结点都可以排成拓扑序列，有环图是显然没有拓扑排序的。</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214200713804.png" alt="image-20230214200713804"></p><h3 id="拓扑算法思想"><a class="anchor" href="#拓扑算法思想">#</a> 拓扑算法思想</h3><ol><li>从图中选择一个<strong>入度为 0</strong> 的结点输出之。(如果一个图中，同时存在多个入度为 0 的结点，则随便输出任意一个结点)</li><li>从图中<strong>删掉此结点及其所有的出边</strong>。</li><li>反复执行以上步骤<ol><li>直到所有结点都输出了，则算法结束</li><li><strong>如果图中还有结点，但入度不为 0</strong>，则说明有环路</li></ol></li></ol><h3 id="拓扑算法实现"><a class="anchor" href="#拓扑算法实现">#</a> 拓扑算法实现</h3><ol><li><p>具体实现算法：AOV 网用<strong>邻接表</strong>来实现</p><p>数组<strong> count</strong> 存放各顶点的<strong>入度</strong></p></li><li><p>并且为了避免每次从头到尾查找入度为 0 的顶点，建立<strong>入度为 0 的顶点栈</strong>，栈顶指针为 top，初始化时为 - 1.</p></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/66.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/66.png" alt="img"></a></p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/54.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/54.png" alt="img"></a></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214202307026.png" alt="image-20230214202307026"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214203538043.png" alt="image-20230214203538043"></p><p>没看懂，甚至可能是错的</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//AOV 网的声明</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">float</span><span class="token operator">></span> vertex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> Edge<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        vertex <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">*</span> nodeTable <span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span><span class="token operator">*</span> count <span class="token punctuation">;</span><span class="token comment">// 存放入度</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> n <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">Graph</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">int</span> vertices<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">n</span> <span class="token punctuation">(</span>vertices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            NodeTable<span class="token operator">=</span><span class="token keyword">new</span> vertex <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            count<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">topologicalorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// 拓扑排序</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Graph</span> <span class="token double-colon punctuation">::</span> <span class="token function">Topologicalsort</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> top<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//top 是当前找到的入度为 0 的点，top==-1 表示找不到入度为 0 的点</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 初始化无入度顶点</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n <span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> top <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            top <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">// 进行正式排序</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 如果 top 变为 - 1，那么显然存在回路</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            cout <span class="token operator">&lt;&lt;</span><span class="token string">"Network has a cycle"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">int</span> j <span class="token operator">=</span> top<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            top <span class="token operator">=</span> count<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            cout<span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            Edge<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token operator">*</span> l <span class="token operator">=</span> NodeTable<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">.</span>dest<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">--</span>connt<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                    <span class="token comment">// 如果完成所有节点的删除</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                    count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> top<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                    top <span class="token operator">=</span> k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="43"></td><td><pre>            l <span class="token operator">=</span> l<span class="token operator">-></span>link<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc29uZ2xpc29uZ2xpc29uZy9hcnRpY2xlL2RldGFpbHMvNDU1NDM0NTE=">https://blog.csdn.net/lisonglisonglisong/article/details/45543451</span></p><p>java 实现</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214203659497.png" alt="image-20230214203659497"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CycleFound</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">Queue</span> q<span class="token punctuation">;</span><span class="token comment">// 队列或者栈都可以</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">Vertex</span> v<span class="token punctuation">,</span> w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> each vertex v</pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span> v<span class="token punctuation">.</span>indegree <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        v <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        v<span class="token punctuation">.</span>topNum <span class="token operator">=</span> <span class="token operator">++</span>counter<span class="token punctuation">;</span><span class="token comment">//Assign next number </span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> each w adjacent <span class="token keyword">to</span> <span class="token namespace">v</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">--</span>w<span class="token punctuation">.</span>indegree <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>                q<span class="token punctuation">.</span>enqueue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span> counter <span class="token operator">!=</span> <span class="token constant">NUM_VERTICES</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CycleFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="算法复杂度分析"><a class="anchor" href="#算法复杂度分析">#</a> 算法复杂度分析</h3><ol><li>算法分析：n 个顶点，e 条边</li><li>建立链式栈 O (n)，每个结点输出一次，每条边被检查一次 O (n＋e)，所以为：O (n＋n＋e)</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214201617082.png" alt="image-20230214201617082"></p><h2 id="72-aoe网络-activity-on-edge-network"><a class="anchor" href="#72-aoe网络-activity-on-edge-network">#</a> 7.2. AOE 网络 Activity On Edge Network</h2><ol><li>用边表示活动的网络 (AOE 网络，Activity On Edge Network) 又称为<strong>事件顶点网络</strong></li><li>顶点：<ul><li>表示事件 (event)</li><li>事件 —— 状态。表示它的入边代表的活动已完成，它的出边代表的活动可以开始，如下图 v0 表示整个工程开始，v4 表示 a4，a5 活动已完成 a7，a8 活动可开始。</li></ul></li><li>有向边：表示活动<ul><li>边上的权 —— 表示完成一项活动需要的时间</li></ul></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/55.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/55.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/56.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/56.png" alt="img"></a></p><p><strong>有唯一的入度为 0 的开始节点</strong></p><p><strong>有唯一的出度为 0 的完成结点</strong></p><h3 id="关键路径"><a class="anchor" href="#关键路径">#</a> 关键路径</h3><ol><li>目的：利用事件顶点网络，研究完成整个工程需要多少时间 加快那些活动的速度后，可使整个工程提前完成。</li><li>关键路径：具有<strong>从开始顶点 (源点)-&gt; 完成顶点 (汇点) 的最长的路径</strong></li></ol><h3 id="一些定义"><a class="anchor" href="#一些定义">#</a> 一些定义</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214204156511.png" alt="image-20230214204156511"></p><ol><li><p>对于事件:</p><ol><li><p>Ve [i]－表示事件 Vi 的可能最早发生时间：定义为从源点 V0-&gt;Vi 的<strong>最长路径长度</strong>，如 Ve [4]=7 天</p></li><li><p>Vl [i]－表示事件 Vi 的允许的最晚发生时间：是在保证汇点 Vn-1 在 Ve [n-1] 时刻 (18) 完成的前提下，事件 Vi 允许发生的最晚时间＝ Ve [n-1]－ Vi-&gt;Vn－1 的最长路径长度。</p><p><strong>是从最后汇点时间长度 - 两者之间最长路径</strong></p></li></ol></li></ol><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/57.png" alt="img"></a></p><ol><li>解释:<ol><li>计算到最后汇点的总共最短时间：找到从源点到汇点的最大路径</li><li>最早 12，因为之前不能做。</li><li>最晚 12，是因为如果这时候不开始，最后完成不了。</li></ol></li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214204912475.png" alt="image-20230214204912475"></p><p>对于活动:</p><ol><li>e [k]－表示活动 ak=&lt;Vi,Vj &gt; 的可能的最早开始时间。 即等于事件 Vi 的可能最早发生时间。 e [k]=Ve [i]</li><li>l [k]－表示活动 ak= &lt;Vi,Vj&gt; 的允许的最迟开始时间 l [k]＝Vl [j]-dur (&lt;i,j&gt;);</li><li>l [k]-e [k]－表示活动 ak 的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间。 (slack time)</li><li>l [k]==e [k]－表示活动 ak 是没有时间余量的<strong>关键活动</strong></li><li>一开始的例子中<ol><li>a8 的最早可能开始时间 e [8]=Ve [4]=7</li><li>最迟允许开始时间 l [8]=Vl [7]-dur (&lt;4,7&gt;) =14-7=7, 所以 a8 是关键路径上的关键活动</li><li>a9 的最早可能开始时间 e [9]=Ve [5]=7</li><li>最迟允许开始时间 l [9]=Vl [7]-dur (&lt;5,7&gt;) =14-4=10</li></ol></li><li>所以 l [9]-e [9]=3, 该活动的时间余量为 3，即推迟 3 天或延迟 3 天完成都不 影响整个工程的完成，它不是关键活动</li></ol><h3 id="寻找关键路径的算法"><a class="anchor" href="#寻找关键路径的算法">#</a> 寻找关键路径的算法</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214205249995.png" alt="image-20230214205249995"></p><ol><li>求各事件的可能最早发生时间 从 Ve [0]=0 开始，向前推进求其它事件的 Ve Ve [i]=max {Ve [j]+dur (&lt; Vj,Vi &gt;)}, &lt;Vj,Vi &gt; 属于 S2, i=1,2,…n－1 j S2 是所有指向顶点 Vi 的有向边 &lt; Vj,Vi &gt; 的集合</li><li>求各事件的允许最晚发生时间 从 Vl [n-1]=Ve [n-1] 开始，反向递推 Vl [i]=min {Vl [j]-dur (&lt;Vi,Vj&gt;)}, &lt;Vi,Vj &gt; 属于 S1, i=n-2,n-3,…0 j S1 是所有从顶点 Vi 出发的有向边 &lt; Vi,Vj &gt; 的集合</li><li>以上的计算必须在拓扑有序及逆拓扑有序的前提下进行，求 Ve [i] 必须使 Vi 的所有前驱结点的 Ve 都求得求 Vl [i] 必须使 Vi 的所有后继结点最晚发生时间都求得。</li><li>求每条边 (活动) ak= &lt;Vi,Vj&gt; 的 e [k], l [k] e [k]=Ve [i];l [k]=Vl [j]-dur (&lt;Vi,Vj&gt; ),k=1,2,…e</li><li><strong>如果 e [k]==l [k]，则 ak 是关键活动</strong></li><li>AOE 网用邻接表来表示，并且假设顶点序列已按拓扑有序与逆拓扑有序排好。如上例:<ul><li>先正向推，然后反向推回来。(分别计算最早时间和最晚时间)</li></ul></li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214205442329.png" alt="image-20230214205442329"></p><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/58.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/58.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/59.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/59.png" alt="img"></a></p><h3 id="算法实现"><a class="anchor" href="#算法实现">#</a> 算法实现</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214205814211.png" alt="image-20230214205814211"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214205823058.png" alt="image-20230214205823058"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230214205833772.png" alt="image-20230214205833772"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Graph</span> <span class="token double-colon punctuation">::</span><span class="token function">CriticalPath</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> i <span class="token punctuation">,</span> j <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> p<span class="token punctuation">,</span> k <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> e<span class="token punctuation">,</span> l <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">float</span> <span class="token operator">*</span> Ve<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> <span class="token operator">*</span> Vl<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 初始化 Ve 数组</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        Ve<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 开始正向拓扑计算</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        Edge <span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> <span class="token operator">*</span> p<span class="token operator">=</span>NodeTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            k <span class="token operator">=</span> p<span class="token punctuation">.</span>dest<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Ve<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>p<span class="token punctuation">.</span> cost <span class="token operator">></span> Ve<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                Ve<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>Ve<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>p<span class="token punctuation">.</span>cost <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                p<span class="token operator">=</span>p<span class="token punctuation">.</span>link<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 反向 Ve 数组，初始化 Vl 数组</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        Vl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Ve<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 反向计算事件最迟开始时间</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        p<span class="token operator">=</span>NodeTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            k<span class="token operator">=</span>p<span class="token punctuation">.</span> dest<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Vl<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span>p<span class="token punctuation">.</span>cost<span class="token operator">&lt;</span>Vl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                Vl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Vl<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span>p<span class="token punctuation">.</span>cost <span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="30"></td><td><pre>                p<span class="token operator">=</span>p<span class="token punctuation">.</span> link<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token comment">// 用来比较最早开始时间和最晚开始时间，确定是否是关键路径</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        p<span class="token operator">=</span>NodeTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            k<span class="token operator">=</span> p<span class="token punctuation">.</span> dest<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            e<span class="token operator">=</span>Ve<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            l<span class="token operator">=</span>Vl<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span>p<span class="token punctuation">.</span> cost<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"&lt;"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">","</span><span class="token operator">&lt;&lt;</span>k<span class="token operator">&lt;&lt;</span><span class="token string">">"</span><span class="token operator">&lt;&lt;</span><span class="token string">"is critical Activity"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            p<span class="token operator">=</span>p<span class="token punctuation">.</span>link<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/60.png"><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/60.png" alt="img"></a></p><h1><a class="anchor" href="#">#</a></h1><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 数据结构</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-02-26 16:15:03" itemprop="dateModified" datetime="2023-02-26T16:15:03+08:00">2023-02-26</time> </span><span id="2023/02/26/NJUSE/dataStructure/Lecture8-Graph/" class="item leancloud_visitors" data-flag-title="Lecture8-Graph" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="quas-modo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="quas-modo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="quas-modo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>quas-modo <i class="ic i-at"><em>@</em></i>Carpe diem</li><li class="link"><strong>本文链接：</strong> <a href="https://quas-modo.github.io/2023/02/26/NJUSE/dataStructure/Lecture8-Graph/" title="Lecture8-Graph">https://quas-modo.github.io/2023/02/26/NJUSE/dataStructure/Lecture8-Graph/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/02/26/NJUSE/internet-computer/%E6%9C%9F%E6%9C%AB%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;quasdo.oss-cn-hangzhou.aliyuncs.com&#x2F;img&#x2F;wenjun-lin-asset (4).jpg" title="计网期末名词解释"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>计网期末名词解释</h3></a></div><div class="item right"><a href="/2023/05/25/%E6%AF%94%E8%B5%9B/%E6%9F%90%E5%A4%A7%E5%AD%A6-vivo%E7%BC%96%E7%A8%8B%E9%A9%AC%E6%8B%89%E6%9D%BE%E5%A4%A7%E8%B5%9B%E5%86%B3%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;quasdo.oss-cn-hangzhou.aliyuncs.com&#x2F;img&#x2F;krenz-cushart-3-step9.jpg" title="某大学-vivo编程马拉松大赛决赛记录"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 比赛</span><h3>某大学-vivo编程马拉松大赛决赛记录</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lecture8-%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">Lecture8 - 图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">图的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">2.2.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">其他图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%E6%95%B0%E5%85%A5%E5%BA%A6%E5%92%8C%E5%87%BA%E5%BA%A6"><span class="toc-number">2.4.</span> <span class="toc-text">概念 —— 顶点的度数（入度和出度）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.5.</span> <span class="toc-text">图的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%9B%BE"><span class="toc-number">2.6.</span> <span class="toc-text">子图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84path"><span class="toc-number">2.7.</span> <span class="toc-text">路径 (path)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84%E5%92%8C%E7%8E%AFsimple-path-and-cycle"><span class="toc-number">2.8.</span> <span class="toc-text">简单路径和环 (Simple path and cycle)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E5%92%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8Fconnected-graph-connected-component"><span class="toc-number">2.9.</span> <span class="toc-text">连通图和连通分量 (Connected graph &amp; Connected component)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E8%81%94%E9%80%9A%E5%9B%BE%E5%92%8C%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8Fstrong-connected-graph-and-strongly-connected-component"><span class="toc-number">2.10.</span> <span class="toc-text">强联通图和强联通分量 (Strong connected graph and strongly connected component)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BEnetwork"><span class="toc-number">2.11.</span> <span class="toc-text">加权图 (Network)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91spanning-tree"><span class="toc-number">2.12.</span> <span class="toc-text">生成树 (Spanning tree)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#adt-graph-and-digraph"><span class="toc-number">3.</span> <span class="toc-text">ADT Graph and Digraph</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#representation-of-graphs-and-diagraphs"><span class="toc-number">4.</span> <span class="toc-text">Representation of graphs and diagraphs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#adjacency-matrix-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">4.1.</span> <span class="toc-text">Adjacency Matrix 邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE-2"><span class="toc-number">4.1.1.</span> <span class="toc-text">无向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE-2"><span class="toc-number">4.1.2.</span> <span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BE"><span class="toc-number">4.1.3.</span> <span class="toc-text">加权图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">代码实现 —— 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">代码实现 —— 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%9C%A8%E9%A1%B6%E7%82%B9%E8%A1%A8%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.3.3.</span> <span class="toc-text">找到在顶点表的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%87%BA%E9%A1%B6%E7%82%B9v%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%82%BB%E6%8E%A5%E9%A1%B6%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.3.4.</span> <span class="toc-text">给出顶点 V 的第一个邻接顶点的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E9%82%BB%E5%B1%85"><span class="toc-number">4.3.5.</span> <span class="toc-text">找到下一个邻居</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%80%83%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8adjacency-multilist"><span class="toc-number">4.4.</span> <span class="toc-text">【不考】邻接多重表（adjacency multilist）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">图的遍历与连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2depth-first-search"><span class="toc-number">5.1.</span> <span class="toc-text">深度优先搜索 (Depth-first-search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">5.1.1.</span> <span class="toc-text">算法思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2breadth-search"><span class="toc-number">5.2.</span> <span class="toc-text">广度优先搜索 (Breadth search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">5.2.1.</span> <span class="toc-text">思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">连通分量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91minimum-cost-spinning-tree-mst"><span class="toc-number">6.</span> <span class="toc-text">最小生成树 minimum-cost spinning tree MST</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.1.</span> <span class="toc-text">生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.1.</span> <span class="toc-text">生成树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.1.2.</span> <span class="toc-text">最小代价生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83grandy%E6%B1%82%E8%A7%A3%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.2.</span> <span class="toc-text">贪心 (Grandy) 求解最小代价生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9"><span class="toc-number">6.2.1.</span> <span class="toc-text">贪心策略的具体内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E7%B1%BB%E5%A3%B0%E6%98%8E"><span class="toc-number">6.2.2.</span> <span class="toc-text">最小生成树的类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95%E5%AF%B9%E8%BE%B9%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%84%B6%E5%90%8E%E7%94%9F%E6%88%90"><span class="toc-number">6.2.3.</span> <span class="toc-text">Kruskal 算法 (对边进行排序，然后生成)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95%E4%BB%BB%E4%BD%95%E8%B5%B7%E7%82%B9%E9%80%89%E5%8F%AF%E9%80%9A%E8%BE%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9D%83%E9%87%8D%E7%9A%84%E8%BE%B9"><span class="toc-number">6.2.4.</span> <span class="toc-text">Prim 算法（任何起点，选可通达的最小权重的边）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">6.2.5.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8D%E5%94%AF%E4%B8%80"><span class="toc-number">6.2.6.</span> <span class="toc-text">最小生成树不唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.2.7.</span> <span class="toc-text">prim 算法实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.8.</span> <span class="toc-text">Prim 算法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">7.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E9%9D%9E%E8%B4%9F%E6%9D%83%E5%80%BC%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84dijkstra"><span class="toc-number">7.1.</span> <span class="toc-text">含非负权值的单源最短路径 (Dijkstra)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">7.1.1.</span> <span class="toc-text">贪心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">7.1.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E4%B8%8A%E6%9D%83%E5%80%BC%E4%B8%BA%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9bellemanford"><span class="toc-number">7.2.</span> <span class="toc-text">边上权值为任意值的单源最短路径（贝尔曼 - 福特）BellemanFord</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E9%A1%B6%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84floyed"><span class="toc-number">7.3.</span> <span class="toc-text">所有顶点之间的最短路径（Floyed）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#floyed%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">floyed 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-floyed%E7%AE%97%E6%B3%95%E5%8F%82%E8%80%83"><span class="toc-number">7.4.</span> <span class="toc-text">6.4. Floyed 算法参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%BD%91%E7%BB%9C-activity-network%E5%B8%B8%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">活动网络 Activity Network（常考）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-aov%E7%BD%91%E7%BB%9Cactivity-on-vertex-network"><span class="toc-number">8.1.</span> <span class="toc-text">7.1. AOV 网络 Activity On Vertex network</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aov%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.1.</span> <span class="toc-text">AOV 网络结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aov%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">AOV 图的拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">8.1.3.</span> <span class="toc-text">拓扑算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.4.</span> <span class="toc-text">拓扑算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">8.1.5.</span> <span class="toc-text">算法复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-aoe%E7%BD%91%E7%BB%9C-activity-on-edge-network"><span class="toc-number">8.2.</span> <span class="toc-text">7.2. AOE 网络 Activity On Edge Network</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">8.2.1.</span> <span class="toc-text">关键路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89"><span class="toc-number">8.2.2.</span> <span class="toc-text">一些定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">寻找关键路径的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.4.</span> <span class="toc-text">算法实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text"></span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/12/01/NJUSE/dataStructure/Lecture01-%E5%AF%BC%E8%A8%80/" rel="bookmark" title="Lecture01-导言">Lecture01-导言</a></li><li><a href="/2022/12/01/NJUSE/dataStructure/Lecture2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" rel="bookmark" title="Lecture2-时间复杂度">Lecture2-时间复杂度</a></li><li><a href="/2022/12/01/NJUSE/dataStructure/Lecture03-%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="bookmark" title="Lecture03-线性表">Lecture03-线性表</a></li><li><a href="/2022/12/01/NJUSE/dataStructure/Lecture04-%E6%A0%91/" rel="bookmark" title="Lecture04-树">Lecture04-树</a></li><li><a href="/2022/12/01/NJUSE/dataStructure/Lecture04-1-%E7%89%B9%E6%AE%8A%E6%A0%91/" rel="bookmark" title="Lecture04.1-特殊树">Lecture04.1-特殊树</a></li><li><a href="/2022/12/05/NJUSE/dataStructure/Lecture05-Hash/" rel="bookmark" title="Lecture05-Hash">Lecture05-Hash</a></li><li><a href="/2022/12/05/NJUSE/dataStructure/Lecture06-PriorityQueue/" rel="bookmark" title="Lecture06-PriorityQueue">Lecture06-PriorityQueue</a></li><li><a href="/2023/02/26/NJUSE/dataStructure/Lecture07-1-DisjointSet/" rel="bookmark" title="Lecture07.1-DisjointSet">Lecture07.1-DisjointSet</a></li><li><a href="/2023/02/26/NJUSE/dataStructure/Lecture07-Sorting/" rel="bookmark" title="Lecture07-Sorting">Lecture07-Sorting</a></li><li class="active"><a href="/2023/02/26/NJUSE/dataStructure/Lecture8-Graph/" rel="bookmark" title="Lecture8-Graph">Lecture8-Graph</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="quas-modo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">quas-modo</p><div class="description" itemprop="description">notes/thoughts/nonsense</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">80</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">20</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXMtbW9kbw==" title="https:&#x2F;&#x2F;github.com&#x2F;quas-modo"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/02/26/NJUSE/internet-computer/%E6%9C%9F%E6%9C%AB%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/25/%E6%AF%94%E8%B5%9B/%E6%9F%90%E5%A4%A7%E5%AD%A6-vivo%E7%BC%96%E7%A8%8B%E9%A9%AC%E6%8B%89%E6%9D%BE%E5%A4%A7%E8%B5%9B%E5%86%B3%E8%B5%9B%E8%AE%B0%E5%BD%95/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/2022/12/02/NJUSE/COA/Lecture14-%E6%8C%87%E4%BB%A4/" title="Lecture14-指令系统">Lecture14-指令系统</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/01/15/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/" title="服务端2023期末回忆">服务端2023期末回忆</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/2022/09/15/NJUSE/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Lecture02-计算机体系结构的问题及解决方案">Lecture02-计算机体系结构的问题及解决方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/12/01/NJUSE/dataStructure/Lecture03-%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="Lecture03-线性表">Lecture03-线性表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="分类于 数据管理基础">数据管理基础</a></div><span><a href="/2023/06/14/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="数据管理基础期末复习">数据管理基础期末复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/12/01/NJUSE/dataStructure/Lecture01-%E5%AF%BC%E8%A8%80/" title="Lecture01-导言">Lecture01-导言</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/2023/02/10/NJUSE/COA/Lecture17-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" title="Lecture17-输入输出">Lecture17-输入输出</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/12/01/NJUSE/dataStructure/Lecture04-1-%E7%89%B9%E6%AE%8A%E6%A0%91/" title="Lecture04.1-特殊树">Lecture04.1-特殊树</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/11/21/NJUSE/cpp/Homework4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="Homework4-内存管理">Homework4-内存管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/2022/12/02/NJUSE/COA/Lecture13-%E6%80%BB%E7%BA%BF/" title="Lecture13-总线">Lecture13-总线</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-quas-modo"></i> </span><span class="author" itemprop="copyrightHolder">quas-modo @ quas-modo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">337k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:07</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/02/26/NJUSE/dataStructure/Lecture8-Graph/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->