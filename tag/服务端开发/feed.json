{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io",
    "items": [
        {
            "id": "https://quas-modo.github.io/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/",
            "url": "https://quas-modo.github.io/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/",
            "title": "服务端2023期末回忆",
            "date_published": "2024-01-15T04:11:17.000Z",
            "content_html": "<p>南京大学软件学院服务端开发回忆。</p>\n<p><span id=\"more\"></span></p>\n<p>by cxy nyb dsy</p>\n<h2 id=\"选择题\"><a class=\"anchor\" href=\"#选择题\">#</a> 选择题</h2>\n<ol>\n<li>横切关注点类型\n<ol>\n<li>日志</li>\n<li>安全</li>\n<li>事务</li>\n<li>缓存</li>\n</ol>\n</li>\n<li>aop 概念\n<ol>\n<li>通知 (Advice)：切面做什么？什么时候做？代表了切面的逻辑。</li>\n<li>切点 (Pointcut)：指定通知存放的位置，定义要改的方法和参数。</li>\n<li>切面 (Aspect)：通知 + 切点</li>\n<li>连接点：通知 + 切点的实例化：也就是和业务代码连接的地方</li>\n</ol>\n</li>\n<li>Bean 的作用域\n<ol>\n<li>Singleton，单例，在整个应用中，只创建 bean 的一个实例</li>\n<li>Prototype，原型，每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新 bean 实例</li>\n<li>Session，会话，在 Web 应用中，为每个会话创建一个 bean 实例</li>\n<li>Request，请求，在 Web 应用中，为每个请求创建一个 bean 实例</li>\n</ol>\n</li>\n<li>Redis 的数据类型\n<ol>\n<li>String</li>\n<li>List</li>\n<li>Hash</li>\n<li>Set</li>\n</ol>\n</li>\n<li>属性来源\n<ol>\n<li><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQyOTNlY2E1MzE0MjVhMzFhZjBiOTY3NzIyYzJjNmRfU2Y5OXdYd0dkZ1lFUENjVmdBZVpTcnB2UXQ0RWhKem1fVG9rZW46R3N0NGJKcHdMb29MN1J4RkN1SmNDaFoxbkFjXzE3MDUyOTI0OTU6MTcwNTI5NjA5NV9WNA\" alt=\"img\" /></li>\n</ol>\n</li>\n<li>配置日志\n<ol>\n<li>默认使用 logback，日志配置文件 logback.xml</li>\n<li>默认日志级别</li>\n</ol>\n</li>\n<li>属于消息中间件的\n<ol>\n<li>Rabbit MQ</li>\n<li>Active MQ</li>\n<li>Active Artemis</li>\n<li>Kafka</li>\n</ol>\n</li>\n<li>Kubernetes 调度的最小单元：pod</li>\n<li>创建新资源的状态码：201</li>\n<li>Docker compose 命令\n<ol>\n<li>Docker-compose logs -f [services]</li>\n<li>Docker-compose up</li>\n<li>Docker-compose stop</li>\n<li>Docker-compose build?</li>\n</ol>\n</li>\n<li>acuator 相关\n<ol>\n<li>哪个包？</li>\n<li>供许多<strong>端点 (endpoints)</strong>, 监测程序运行情况\n<ul>\n<li>/actuator，查询所有暴露端点</li>\n<li><strong>/actuator/configprops</strong>，查询配置属性</li>\n<li>/actuator/health，健康检查</li>\n<li>/actuator/beans，包含 bean 依赖关系</li>\n</ul>\n</li>\n<li>想要获得更多端点如何配置： <code>include: &quot;*&quot;</code>  暴露所有端口，否则只暴露 <code>/actuator/health</code></li>\n</ol>\n</li>\n<li>docker 命令？</li>\n<li>Spring 集成流的组件\n<ol>\n<li>Channels</li>\n<li>Routers</li>\n<li>Gateways</li>\n<li>Filters</li>\n</ol>\n</li>\n<li>哪些是请求映射的注解\n<ol>\n<li>RequestMapping</li>\n<li>GetMapping</li>\n<li>PostMapping</li>\n<li>PutMapping</li>\n</ol>\n</li>\n<li>JPA 的 DSL\n<ol>\n<li>Read</li>\n<li>Count</li>\n<li>Find</li>\n<li>Get</li>\n</ol>\n</li>\n<li>DOCKERFILE 最佳实践\n<ol>\n<li>容器只运行<strong>单个应用</strong></li>\n<li>每个 RUN 指令后删除多余文件</li>\n<li>基础镜像的标签不要用 latest</li>\n<li>每个 RUN 指令后删除多余文件</li>\n</ol>\n</li>\n<li>镜像分层\n<ol>\n<li>最上面一层可读写，下面只读</li>\n</ol>\n</li>\n<li>Git 本地工作区 - 暂存区的命令</li>\n</ol>\n<h2 id=\"简答题\"><a class=\"anchor\" href=\"#简答题\">#</a> 简答题</h2>\n<ol>\n<li>分层架构</li>\n<li>security 自己要实现的四个方面</li>\n<li>反应式编程的四个接口，以及它们之间的关系？</li>\n<li>docker 组成部分</li>\n<li>数据库初始化的时机</li>\n</ol>\n",
            "tags": [
                "NJUSE",
                "服务端开发",
                "服务端开发"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2024/01/15/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
            "url": "https://quas-modo.github.io/2024/01/15/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
            "title": "服务端期末复习",
            "date_published": "2024-01-15T04:10:11.000Z",
            "content_html": "<p>南京大学软件学院服务端开发期末整理。</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"多选题\"><a class=\"anchor\" href=\"#多选题\">#</a> 多选题</h1>\n<h2 id=\"核心技术\"><a class=\"anchor\" href=\"#核心技术\">#</a> 核心技术</h2>\n<ol>\n<li>DI（Dependency Injection）\n<ol>\n<li>保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，<strong>由抽象接口来注入依赖的实际对象</strong></li>\n</ol>\n</li>\n<li>AOP（Aspect Oriented Programming）\n<ol>\n<li>通过<strong>预编译方式</strong>和<strong>运行期间动态代理</strong>实现程序功能的统一维护的一种技术</li>\n<li>利用 AOP 可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"依赖注入\"><a class=\"anchor\" href=\"#依赖注入\">#</a> 依赖注入</h2>\n<h2 id=\"aop\"><a class=\"anchor\" href=\"#aop\">#</a> AOP</h2>\n<h3 id=\"横切关注点类型\"><a class=\"anchor\" href=\"#横切关注点类型\">#</a> 横切关注点类型</h3>\n<p>日志、安全、事务、缓存（可选：继承、委托）</p>\n<h3 id=\"advice注解类型\"><a class=\"anchor\" href=\"#advice注解类型\">#</a> Advice 注解类型</h3>\n<ul>\n<li>@Before</li>\n<li>@After：不区分是否正常结束</li>\n<li>@AfterReturning</li>\n<li>@AfterThrowing</li>\n<li>@Around：结合前面所有类型，around 可以是综合，之前、之后、结束、抛异常之后。</li>\n</ul>\n<p><strong>被切方法成功运行之后会执行</strong>：After、AfterReturning、Around</p>\n<h3 id=\"aspectj可以实现\"><a class=\"anchor\" href=\"#aspectj可以实现\">#</a> AspectJ 可以实现</h3>\n<ol>\n<li>指定在哪些方法上切入</li>\n<li>获取参数</li>\n<li>限定包路径</li>\n<li>限定 bean 名称，白名单或黑名单</li>\n<li>限定在特定注解上切入</li>\n</ol>\n<h2 id=\"spring-mvc\"><a class=\"anchor\" href=\"#spring-mvc\">#</a> Spring MVC</h2>\n<h3 id=\"谁有component的效果\"><a class=\"anchor\" href=\"#谁有component的效果\">#</a> 谁有 @Component 的效果？</h3>\n<p><code>@Controller</code> 、 <code>@Service</code>  和  <code>@Repository</code>  三个注解本身有  <code>@Component</code>  的实例化效果。</p>\n<h3 id=\"重定向\"><a class=\"anchor\" href=\"#重定向\">#</a> 重定向</h3>\n<p>控制器处理完成后可以返回逻辑视图名，也可以重定向到其他 url</p>\n<ul>\n<li>http 状态码：302 FOUND\n<ul>\n<li>HTTP 状态码 302 表示 “Found”（或者有时被称为 “Temporary Redirect” 临时重定向）。当一个 Web 服务器返回这个状态码时，它通常是在告诉客户端，请求的资源暂时被移动到了一个不同的 URI（统一资源标识符）。</li>\n</ul>\n</li>\n<li>控制器 <code>return redirect:&lt;url&gt;</code></li>\n</ul>\n<h3 id=\"spring-mvc获取参数的几种方式\"><a class=\"anchor\" href=\"#spring-mvc获取参数的几种方式\">#</a> Spring MVC 获取参数的几种方式</h3>\n<ol>\n<li>表单 (form) 参数，转成 model\n<ol>\n<li>成员类型可能要自己实现 Converter 进行转换</li>\n<li>可以用 <code>@Valid</code>  校验</li>\n<li>form 是 html 里定义的</li>\n</ol>\n</li>\n<li>路径参数\n<ol>\n<li><code>@PathVariable</code></li>\n<li>例： <code>/book/&#123;id&#125;</code></li>\n</ol>\n</li>\n<li>请求参数 / 查询参数\n<ol>\n<li><code>@RequestParam</code></li>\n<li>例： <code>/challenge?model=2</code></li>\n</ol>\n</li>\n<li>json 请求体\n<ol>\n<li><code>@RequestBody</code> ，会用到 HttpMessageConverter 消息转换器</li>\n<li>Rest API</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"spring-data-jdbcjpa\"><a class=\"anchor\" href=\"#spring-data-jdbcjpa\">#</a> Spring Data JDBC/JPA</h2>\n<h3 id=\"数据表创建和初始化\"><a class=\"anchor\" href=\"#数据表创建和初始化\">#</a> 数据表创建和初始化</h3>\n<p>三种方式，java 代码初始化有两种。</p>\n<ol>\n<li>表</li>\n<li>commandlinerunner</li>\n<li>applicationrunner</li>\n</ol>\n<p>三种方式关于 id 字段的处理：第一种方法需要主动地获取数据库新的 id 是什么，但二 / 三种没有需要</p>\n<h4 id=\"脚本\"><a class=\"anchor\" href=\"#脚本\">#</a> 脚本</h4>\n<p>schema.sql 表创建</p>\n<p>data.sql 数据初始化</p>\n<p><strong>java 代码初始化</strong></p>\n<p>CommandLineRunner 接口</p>\n<p>ApplicationRunner 接口</p>\n<h3 id=\"异常体系\"><a class=\"anchor\" href=\"#异常体系\">#</a> 异常体系</h3>\n<ul>\n<li>SQLException\n<ul>\n<li>发现异常很难恢复</li>\n<li>难以确定异常类型</li>\n</ul>\n</li>\n<li>Hibernate 异常\n<ul>\n<li>定义了许多具体异常，方便定位</li>\n<li>对业务对象侵入</li>\n</ul>\n</li>\n<li>Spring 提供与平台无关的异常\n<ul>\n<li><code>DataAccessException</code></li>\n<li>具体异常，方便定位</li>\n<li>隔离具体数据库</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"springdata-mongodbredis\"><a class=\"anchor\" href=\"#springdata-mongodbredis\">#</a> SpringData MongoDB\\Redis</h2>\n<h3 id=\"nosql特点\"><a class=\"anchor\" href=\"#nosql特点\">#</a> Nosql 特点</h3>\n<p>键值对存储、列存储、文档存储、图形数据库</p>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY0MDg0M2M5N2NlNTBjNzc5M2Y1M2U5NzM4YTE0YjhfVlJmbDlwOG1wcjFmZWpCTjF6Q1dVazI0bHRqSkQ1dXFfVG9rZW46TnhRZ2JjOWpzb0Q0cDB4Mk9RbWNPUWVwbkJqXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h3 id=\"mongodb特点\"><a class=\"anchor\" href=\"#mongodb特点\">#</a> MongoDB 特点</h3>\n<p>基于分布式文件存储的开源数据库系统，类似 json 格式存储</p>\n<p>MongoDB Shell 是 MongoDB 自带的交互式 Javascript shell, 用来对 MongoDB 进行操作和管理的交互式环境</p>\n<h3 id=\"mongodb概念\"><a class=\"anchor\" href=\"#mongodb概念\">#</a> MongoDB 概念</h3>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTliZWYwYmUzMWEwMGUxYmY5YzY4ZjJkMjJkYjI0M2VfTFExcm9ia0VrakMwRDRweG9LaEE1c3N2R0VoOEFYd1FfVG9rZW46QjluVGJkRXg0bzU2Zm14NVhrZWNYVnhSbnVjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h3 id=\"redis特点\"><a class=\"anchor\" href=\"#redis特点\">#</a> Redis 特点</h3>\n<ul>\n<li>分布式存储</li>\n<li><strong>内存数据库</strong>，存在内存里，常用于作缓存</li>\n<li>可以<strong>持久化</strong>，但不太重要，不是主要用途</li>\n<li>可以<strong>集群式部署</strong>\n<ul>\n<li>主从复制，主机写，从机并发读</li>\n</ul>\n</li>\n<li>key-value 的<strong> Hash 表</strong>结构，区分大小写</li>\n</ul>\n<h3 id=\"redis数据类型\"><a class=\"anchor\" href=\"#redis数据类型\">#</a> Redis 数据类型</h3>\n<ol>\n<li>String</li>\n<li>List</li>\n<li>Hash</li>\n<li>Set</li>\n</ol>\n<h3 id=\"redis指定序列化器\"><a class=\"anchor\" href=\"#redis指定序列化器\">#</a> Redis 指定序列化器</h3>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJjNzUwZjQzZjM2ZjlkN2FjYWM4ZjQyZTJkMzdkYTFfOUJUU1BHN3NiWDNZb3lXSEVKU051Z1hnZFBPV1hOQ0RfVG9rZW46QjZMYWJNd081b2dLNUJ4T1pCT2NPTjVmblFiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<p>mongodb 没有这个要求，因为它会把所有值都转成 json 串。</p>\n<p>redis 默认使用 JDK 序列化，但 JSON 序列化更常用。</p>\n<h2 id=\"spring-security\"><a class=\"anchor\" href=\"#spring-security\">#</a> Spring Security</h2>\n<p>划分为两类：</p>\n<ol>\n<li><strong>针对客户 web 请求权限控制</strong></li>\n<li><strong>针对方法级的权限控制</strong></li>\n</ol>\n<h3 id=\"实现方法级别的安全\"><a class=\"anchor\" href=\"#实现方法级别的安全\">#</a> 实现方法级别的安全</h3>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQyNTMyZTBiZWNmN2VlMDk0ZWFhOGMyZDZjMTA2MmVfejVyRnl1blI0MkRYYnIzWWhjOVkzNDZhdUVIemdiUkNfVG9rZW46RmsxeGJzc0ZJbzBwMGp4VktSamNkZWs0bmlYXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h3 id=\"获取当前登录的用户\"><a class=\"anchor\" href=\"#获取当前登录的用户\">#</a> 获取当前登录的用户</h3>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE2MDNjMTllZWU0MjQ3MTFiOGU3YWIwOThkNGQyZDRfMkt0Z1BBWmQxclh4MHVyMHBjcFlZNFJpM1Z1MkhibmdfVG9rZW46VDFCQ2J2Qnhjb2Q4MFp4OENZZmM0ak1vbkxiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"配置属性\"><a class=\"anchor\" href=\"#配置属性\">#</a> 配置属性</h2>\n<h3 id=\"actuator\"><a class=\"anchor\" href=\"#actuator\">#</a> Actuator</h3>\n<ul>\n<li>提供许多<strong>端点 (endpoints)</strong>, 监测程序运行情况\n<ul>\n<li>/actuator，查询所有暴露端点</li>\n<li><strong>/actuator/configprops</strong>，查询配置属性</li>\n<li>/actuator/health，健康检查</li>\n<li>/actuator/beans，包含 bean 依赖关系</li>\n</ul>\n</li>\n<li>想要获得更多端点如何配置： <code>include: &quot;*&quot;</code>  暴露所有端口，否则只暴露 <code>/actuator/health</code></li>\n</ul>\n<h2 id=\"rest-api\"><a class=\"anchor\" href=\"#rest-api\">#</a> Rest API</h2>\n<ul>\n<li>HTTP 协议的四个操作方式的动词：GET、POST、PUT、DELETE\n<ul>\n<li><strong>CRUD：Create、Read、Update、Delete</strong></li>\n<li>GET: Read</li>\n<li>POST: Create</li>\n<li>PUT: Update</li>\n<li>DELETE: Delete</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"requestmapping\"><a class=\"anchor\" href=\"#requestmapping\">#</a> RequestMapping/</h3>\n<p>实现控制器的时候 RequestMapping 可以加在？类、方法上面</p>\n<h3 id=\"restcontroller\"><a class=\"anchor\" href=\"#restcontroller\">#</a> RestController</h3>\n<p>在 Controller 类中：</p>\n<pre><code class=\"language-Plain\">@RestController  \n</code></pre>\n<p>等价于：</p>\n<pre><code class=\"language-Plain\">@Controller  \n@ResponseBody  \n</code></pre>\n<p>想要某个方法返回的<strong> Java 对象转成 json 格式串</strong>： <code>@ResponseBody</code>  注解加在特定函数上</p>\n<h3 id=\"响应头与响应体\"><a class=\"anchor\" href=\"#响应头与响应体\">#</a> 响应头与响应体</h3>\n<ul>\n<li>状态行：由 <strong>HTTP 协议版本、状态码、状态码描述</strong>三部分构成，它们之间由空格隔开。</li>\n</ul>\n<h2 id=\"oauth2\"><a class=\"anchor\" href=\"#oauth2\">#</a> OAuth2</h2>\n<p>解决分布式系统中，权限控制的问题</p>\n<h2 id=\"消息中间件\"><a class=\"anchor\" href=\"#消息中间件\">#</a> 消息中间件</h2>\n<h3 id=\"定义\"><a class=\"anchor\" href=\"#定义\">#</a> 定义</h3>\n<ul>\n<li>提供消息服务的应用程序</li>\n<li>主要用于组件之间的解耦，消息的发送者服务知道消息使用者的存在，反之依然</li>\n</ul>\n<p>消息代理 broker：</p>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg4NTg1ZjI3MTI3YjM0YjUxNWU5MDYzNzZjY2RjMjdfRjhidzJ1TU04b3RTUmFZbjg1UWJmS0dQNXc2NFUxQkdfVG9rZW46TzRPMWJ0R1NSb0hDSlB4eGo5Z2M2dUpIbnpoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h3 id=\"jms\"><a class=\"anchor\" href=\"#jms\">#</a> JMS</h3>\n<ul>\n<li>Java Message Service\n<ul>\n<li>Jms 规定了<strong> ConnectionFactory、Connection、Session</strong> 等接口 / 类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"activemq\"><a class=\"anchor\" href=\"#activemq\">#</a> ActiveMQ</h3>\n<p>支持协议</p>\n<ul>\n<li>JMS</li>\n<li>AMQP: Advanced Message Queueing Protocol</li>\n<li>MQTT: Message Queuing Telemetry Transport</li>\n</ul>\n<p>支持 Native 内存模式和 JVM 内存模式</p>\n<ul>\n<li>Native 可以绕过 JVM，加快访问</li>\n</ul>\n<p>消息持久化</p>\n<p>分布式架构</p>\n<h4 id=\"关键概念\"><a class=\"anchor\" href=\"#关键概念\">#</a> 关键概念</h4>\n<ul>\n<li>Message：类似广播，生产端</li>\n<li>Destination：队列或主题。消费端\n<ul>\n<li>三种指定方式：\n<ul>\n<li>application.yml（default-destination）</li>\n<li>@Bean（Destination 对象）</li>\n<li>直接 String 指定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"接收模式\"><a class=\"anchor\" href=\"#接收模式\">#</a> 接收模式</h3>\n<p><strong>拉取和推送都需要消息转换器做反序列化。</strong></p>\n<h4 id=\"351-拉取模式-pull-model\"><a class=\"anchor\" href=\"#351-拉取模式-pull-model\">#</a> 3.5.1. 拉取模式 pull model</h4>\n<p>JmsTemplate 支持</p>\n<p>访问 URL</p>\n<h4 id=\"352-推送模式-push-model\"><a class=\"anchor\" href=\"#352-推送模式-push-model\">#</a> 3.5.2. 推送模式 push model</h4>\n<p>需要<strong>定义消息监听器</strong></p>\n<p>@JmsListener</p>\n<h3 id=\"rabbitmq\"><a class=\"anchor\" href=\"#rabbitmq\">#</a> RabbitMQ</h3>\n<p><strong>实现 AMQP 协议</strong>。</p>\n<h4 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h4>\n<ul>\n<li>ConnectionFactory、Connection、Channel</li>\n<li>Exchange：\n<ul>\n<li>Default、Direct、Topic、Fanout、Headers、Dead letter</li>\n</ul>\n</li>\n<li>Queue</li>\n<li><strong>Routing key</strong>：exchange 根据 routing key 确定消息发往哪个队列\n<ul>\n<li><strong>JMS 里没有这个概念</strong></li>\n</ul>\n</li>\n<li><strong>Binding key</strong></li>\n</ul>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVkZDE0OWRkMDVjMWFmYjZjMDFlZGIzZmRkOTQ2N2JfRWhtV3JOZG9tMlAxanFhOUF5U0hnSzlJMXdoUUFVUGdfVG9rZW46QU9QcmI3WW5tb0lqM0R4TFcxZWNmMzVlbjVnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<p>一些 gpt 解释：</p>\n<ol>\n<li>connectionFactory: 这是一个创建连接到 RabbitMQ 服务器的工厂类。它封装了与 RabbitMQ 服务器连接所需的配置信息，如主机名、端口、用户名和密码。</li>\n<li>Connection: 这是客户端和 RabbitMQ 服务器之间的网络连接。ConnectionFactory 用于创建这个连接。</li>\n<li>Channel: 一旦建立了连接，Channel 就是在这个连接上进行通信的途径。可以将其视为连接内的一个轻量级会话。在 RabbitMQ 中，几乎所有的操作都是通过 Channel 来完成的，如声明队列、交换机或发布消息等。</li>\n<li>Exchange: 交换机是 RabbitMQ 的一个消息路由机制。它指定消息应该如何路由到不同的队列。RabbitMQ 提供了几种类型的交换机：\n<ol>\n<li>Default Exchange: 默认交换机是一个直接交换机，用于路由特定 Routing Key 的消息。</li>\n<li>Direct Exchange: 直接交换机将消息路由到具有特定 Routing Key 的队列。</li>\n<li>Topic Exchange: 主题交换机基于模式匹配 Routing Key 来路由消息。</li>\n<li>Fanout Exchange: 扇出交换机将收到的消息广播到它所知道的所有队列。</li>\n<li>Headers Exchange: 头交换机基于消息头信息而不是 Routing Key 来路由消息。</li>\n<li>Dead Letter Exchange: 死信交换机用于处理无法正常处理的消息，如被拒绝或超时的消息。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"如何查看镜像中的网卡信息和ip地址\"><a class=\"anchor\" href=\"#如何查看镜像中的网卡信息和ip地址\">#</a> 如何查看镜像中的网卡信息和 ip 地址</h2>\n<p>docker run --rm -it busybox</p>\n<p>cat /etc/hosts</p>\n<p>ip a</p>\n<h2 id=\"integration\"><a class=\"anchor\" href=\"#integration\">#</a> Integration</h2>\n<h3 id=\"service-activators\"><a class=\"anchor\" href=\"#service-activators\">#</a> Service activators</h3>\n<ul>\n<li>MessageHandler\n<ul>\n<li>处理完流就截止</li>\n</ul>\n</li>\n<li>GenericHandler\n<ul>\n<li>有返回值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gateways\"><a class=\"anchor\" href=\"#gateways\">#</a> Gateways</h3>\n<p>只需要写一个接口。 Gateways 是<strong>应用程序代码和消息系统之间的桥梁</strong>。它们抽象了消息发送和接收的细节，使得应用程序代码可以通过方法调用的方式与消息系统交互，而无需直接使用消息 API。这样可以使应用程序代码保持简洁，同时也便于测试。</p>\n<ul>\n<li>单向网关</li>\n<li>双向网关\n<ul>\n<li>requets channel 输入</li>\n<li>repley channel 获得返回值（Spring 会在这个管道上一直等，同步）\\</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"channel-adapters\"><a class=\"anchor\" href=\"#channel-adapters\">#</a> Channel adapters</h3>\n<p>Adapters 则是用于将<strong>消息从一种格式转换为另一种格式</strong>，或者从一种传输协议转换为另一种传输协议。Inbound 把外部系统的消息格式转为 spring integration 消息，outbound 把 spring integration 消息转为外部系统消息。 例如，JMS 适配器可以将 JMS 消息转换为 Spring Integration 通用消息，HTTP 适配器可以将 HTTP 请求和响应转换为 Spring Integration 消息。</p>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcyMGY0ZjBkMDhlNjEwOWFjMmZhNmQxOTRkZTFkNzhfaE9xMVRhNmk3TGtLZGV1N3FYSndZalRNdlhramRkZmdfVG9rZW46RnNnZWJrRENlb1ZtQnB4S1FwNGNFYnYxbjhiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"反应式编程\"><a class=\"anchor\" href=\"#反应式编程\">#</a> 反应式编程</h2>\n<h3 id=\"操作类型\"><a class=\"anchor\" href=\"#操作类型\">#</a> 操作类型</h3>\n<p>创建、组合、过滤、转换、逻辑</p>\n<h2 id=\"webflux\"><a class=\"anchor\" href=\"#webflux\">#</a> WebFlux</h2>\n<h3 id=\"使用函数式编程范式来定义控制器\"><a class=\"anchor\" href=\"#使用函数式编程范式来定义控制器\">#</a> 使用函数式编程范式来定义控制器</h3>\n<p>HandlerFunction 表示处理接收到的请求并生成响应的函数</p>\n<p>RouterFunction 替代了 @RequestMapping 注解。它用于将接收到的请求路由到处理函数</p>\n<h3 id=\"函数式编程模型涉及的4个类型\"><a class=\"anchor\" href=\"#函数式编程模型涉及的4个类型\">#</a> 函数式编程模型涉及的 4 个类型</h3>\n<p>RequestPredicate</p>\n<p>RouterFunction</p>\n<p>ServerRequest</p>\n<p>ServerResponse</p>\n<h1 id=\"简答题\"><a class=\"anchor\" href=\"#简答题\">#</a> 简答题</h1>\n<h2 id=\"bean的三种注入方式\"><a class=\"anchor\" href=\"#bean的三种注入方式\">#</a> Bean 的三种注入方式</h2>\n<h3 id=\"构造方法\"><a class=\"anchor\" href=\"#构造方法\">#</a> 构造方法</h3>\n<ul>\n<li>在构造函数上使用 @Autowired 注解，用于自动注入构造函数参数所需要的 Bean。<strong>如果构造函数只有一个参数，则可以省略 @Autowired 注解。</strong></li>\n</ul>\n<p this.myDao=\"\">@Autowired public MyService(MyDao myDao)</p>\n<h3 id=\"setter方法\"><a class=\"anchor\" href=\"#setter方法\">#</a> setter 方法</h3>\n<p this.orderRepo=\"\">public void setOrderRepo(OrderRepository orderRepo)</p>\n<p>也可以加 <code>Autowired</code>  自动注入.</p>\n<p this.orderRepo=\"\">@Autowired public void setOrderRepo(OrderRepository orderRepo)</p>\n<h3 id=\"属性字段下加autowired\"><a class=\"anchor\" href=\"#属性字段下加autowired\">#</a> 属性字段下加 <code>@Autowired</code></h3>\n<p>@Autowired</p>\n<p>private MyBean myBean;</p>\n<h2 id=\"spring配置方案\"><a class=\"anchor\" href=\"#spring配置方案\">#</a> <strong>Spring 配置方案</strong></h2>\n<ol>\n<li>自动化配置</li>\n<li>javaconfig - 第三方库</li>\n<li>XML 配置</li>\n<li>混合配置</li>\n</ol>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY4ZDBkMGMwOTEyNGZhZjBmYzJkYWJjNGI2ZWZhN2JfdlkwNmp4c3NYN1o0UFJGcndjQjFNZnk1WGFlVDhXZGtfVG9rZW46QjJ1RmJVWUx3bzBic0p4VUNlU2N4cWxrbmJoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<ol>\n<li>自动配置\n<ol>\n<li>组件扫描 component scanning\n<ul>\n<li><code>@Configuration</code>  配置类</li>\n<li><code>@ComponentScan</code>  从当前包递归找加了注解 <code>@Component</code>  的类，并把它们都实例化出来。表示要在那些包路径下搜索。</li>\n</ul>\n</li>\n<li>自动装配 autowiring  <code>@Autowired</code>\n<ul>\n<li>用在构造器</li>\n<li>用在属性 setter 方法</li>\n<li>用在（私有）属性</li>\n<li><code>required=false</code>\n<ul>\n<li>在 Spring 框架中使用  <code>@Autowired</code>  注解时， <code>required=false</code>  这一属性表示如果 Spring 容器中没有找到匹配的 bean 来注入，那么它将允许这个属性保持未设置状态，即不会抛出异常。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>需要实例化的 Bean： <code>@Component</code>\n<ul>\n<li>默认是<strong>单实例模式</strong>，在 Spring 上下文永远只有一个实例</li>\n<li>可以<strong>参数指定多实例</strong>，比如 <code>@Component(&quot;soundsystem&quot;)</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>Javaconfig\n<ol>\n<li>应用场景：自动化配置行不通，如第三方库</li>\n<li>注解\n<ul>\n<li><code>@Configuration</code></li>\n<li><code>@Bean(name=“..”)</code></li>\n</ul>\n</li>\n<li>注入\n<ul>\n<li>调用方法</li>\n<li>通过方法参数自动装配（其他配置类，其他方法创建的 Bean）</li>\n</ul>\n</li>\n<li>注意与业务逻辑和领域代码分开：只用于创建，不会把业务逻辑放进来</li>\n</ol>\n</li>\n<li>Xml\n<ol>\n<li>格式： <code>&lt;beans&gt;&lt;bean&gt;</code></li>\n<li><strong>无类型检查</strong></li>\n<li>构造器注入\n<ul>\n<li>constructor-arg</li>\n<li>c - 命名空间</li>\n<li>注入字面量值</li>\n<li>注入集合</li>\n</ul>\n</li>\n<li>属性注入\n<ul>\n<li>p - 命名空间</li>\n<li>util - 命名空间</li>\n</ul>\n</li>\n<li>建议：强依赖使用构造器注入</li>\n</ol>\n</li>\n<li>混合配置\n<ol>\n<li>在根配置类中导入其他配置类。</li>\n<li>JavaConfig 导入\n<ul>\n<li><code>@import(配置类,class,...)</code></li>\n<li><code>@importResource(xml文件)</code></li>\n</ul>\n</li>\n<li>XML 导入\n<ul>\n<li>&lt;import resource=“xml 文件”/&gt;</li>\n<li>&lt;bean class=“配置类”/&gt;</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"aop解决什么问题开发要点是什么\"><a class=\"anchor\" href=\"#aop解决什么问题开发要点是什么\">#</a> AOP 解决什么问题？开发要点是什么？</h2>\n<ul>\n<li>通过<strong>预编译方式</strong>和<strong>运行期间动态代理</strong>实现程序功能的统一维护的一种技术</li>\n<li>利用 AOP 可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li>\n</ul>\n<p>AOP 面向接口的编程，增强模块化，将影响多个模块但又与业务逻辑不直接相关的问题提取出（安全、日志、事务、缓存等），实现横切关注点，提高代码的可维护性和可读性，降低耦合</p>\n<p>开发要点：定义通知 Advice、切点 Pointcut、Aspect 等，确定在何时、何处切入，完成什么操作</p>\n<ol>\n<li><strong>通知 Advice</strong>：切面要做什么以及何时做\n<ol>\n<li>时间：方法前 / 后…</li>\n</ol>\n</li>\n<li><strong>切点 Pointcut</strong>：指定在何处切\n<ol>\n<li>Spring 只支持在方法的前后切</li>\n<li>写<strong>切点表达式</strong>指定逻辑</li>\n</ol>\n</li>\n<li><strong>切面 Aspect</strong>：Advice 和 Pointcut 的结合\n<ol>\n<li>包含切的所有逻辑</li>\n</ol>\n</li>\n<li><strong>连接点 Join point</strong>：方法、字段修改、构造方法</li>\n<li><strong>引入 introduction</strong>：引入新的行为和状态\n<ol>\n<li>给对象加入新的方法 / 状态，但不需要实现新的子类。在原来的对象上动态加入新的方法 / 状态。</li>\n<li>引入方式\n<ul>\n<li>创建需要增加的接口和实现类</li>\n<li>新建一个切面类，加 <code>@Aspect</code></li>\n<li>在里面定义一个新增实现类的 <code>static</code>  接口，加上 <code>@DeclareParents</code>  注解</li>\n<li>实例化切面类 Bean</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>织入 Weaving</strong>：切面应用到目标对象的过程</li>\n</ol>\n<h2 id=\"spring-web-开发框架的分层\"><a class=\"anchor\" href=\"#spring-web-开发框架的分层\">#</a> Spring Web 开发框架的分层</h2>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA5YjMyODU3NGM5ODU4MzZkNTQ1ZTM2M2UyZjBlNGJfeFRPMjVlUmlMMFRmZm5aUllldHBqMGx3Q1ljU2JtTTBfVG9rZW46Q0lONWJGWWprb3hPZ2J4ZzNleWNNOHNxblFiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"web框架请求的处理过程\"><a class=\"anchor\" href=\"#web框架请求的处理过程\">#</a> Web 框架请求的处理过程</h2>\n<h3 id=\"客户端请求参数分类\"><a class=\"anchor\" href=\"#客户端请求参数分类\">#</a> 客户端请求参数分类</h3>\n<ol>\n<li>路径参数， <code>@PathVariable</code></li>\n<li>请求参数（查询参数）， <code>@RequestParam</code></li>\n<li>表单参数，应用于前后端不分离的传统场景，默认，对应 model 对象，可以使用  <code>@Valid</code>  校验</li>\n<li><code>json</code>  请求体，应用于前后端分离的场景，使用  <code>@RequestBody</code>  把  <code>json</code>  格式转成 java 对象； <code>@ResponseBody</code> ，把 java 对象转成  <code>json</code>  格式</li>\n</ol>\n<h3 id=\"处理流程\"><a class=\"anchor\" href=\"#处理流程\">#</a> 处理流程</h3>\n<ol>\n<li>控制器根据 url 捕获请求，控制器解析并获取参数，同时将转向业务层进行处理</li>\n<li>涉及到数据的持久化则访问数据访问层，访问完毕后返回业务层，业务层处理完毕将结果数据返回到控制器</li>\n<li>控制器的响应处理：\n<ol>\n<li>前后端分离：返回 Java 对象，同时加上  <code>@ResponseBody</code>  注解，表示返回的对象将被自动转换为 JSON 或其他格式。前端处理数据并渲染到页面上。</li>\n<li>前后端不分离：控制器将数据赋值给 model 的属性，并返回视图名；根据视图名做视图解析，找到模板路径；通过第三方页面渲染，将 model 数据渲染到最终页面中，返回 html 格式文件。</li>\n</ol>\n</li>\n</ol>\n<p>在类的上方加注解  <code>@RestController</code> 。</p>\n<h2 id=\"mvc架构\"><a class=\"anchor\" href=\"#mvc架构\">#</a> MVC 架构</h2>\n<p><strong>M</strong>odel-<strong>V</strong>iew-<strong>C</strong>ontroller</p>\n<p>MVC 模式用于前后端不分离的开发场景</p>\n<ul>\n<li>模型 model：处理业务逻辑；存储、读取、处理数据</li>\n<li>控制器 controller：处理用户输入，处理客户端的请求；返回数据（model）</li>\n<li>视图 view：显示内容，model 和 view 结合</li>\n</ul>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJhMTQ3NjE1YTRmZTk0NWMwMTJkN2RmMTI3YzA4ZmZfU2pRTE1aMTZDbHI3Y1lZcFBEUjVCQ25BN2VKT1R4SnVfVG9rZW46TWw4V2JCODJJb3pDM214UDRlQWN5Wm5YbmtjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"spring-mvc的请求过程\"><a class=\"anchor\" href=\"#spring-mvc的请求过程\">#</a> Spring MVC 的请求过程</h2>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc1ZDQ1MTAxMDU5YjVmNDQ0YjQ1NGQ4ZTMyMWEyYTRfdG9XbnpDZWxFbDVCM2dzUk96NHNJYUlybWFPSzVkY3VfVG9rZW46THNsRWI1Wml1b01yaXd4WmpDa2NFTG1FbkRUXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<p>客户端请求在<strong>后端的处理过程</strong>，非常重要。 <strong>核心 DispatcherServlet</strong>，是 Spring 自己实现的 Servlet 容器。</p>\n<ol>\n<li>Web 容器开发的基本单元是 Servlet，请求 request 先到 servlet。</li>\n<li>spring 框架做参数解析，使用 handler mapping 根据 url 把请求转到对应的 controller。</li>\n<li>controller 处理请求和请求参数，把结果传给业务层</li>\n<li>业务层处理业务逻辑，业务层访问数据层；业务层把处理结果返回控制器</li>\n<li>控制器把结果返回给 servlet</li>\n<li>servlet 拿到了数据和逻辑视图名，找到视图解析器的第三方库</li>\n<li>视图解析器渲染视图</li>\n</ol>\n<h2 id=\"关系型数据访问层开发的三种方法区别-相同点\"><a class=\"anchor\" href=\"#关系型数据访问层开发的三种方法区别-相同点\">#</a> 关系型数据访问层开发的三种方法区别、相同点</h2>\n<ol>\n<li>使用 jdbcTemplate 简化 JDBC 访问（spring-boot-starter-jdbc）</li>\n<li>Spring Data JDBC（spring-boot-starter-data-jdbc）</li>\n<li>Spring Data JPA（spring-boot-starter-data-jpa）</li>\n</ol>\n<p>区别：</p>\n<ol>\n<li>数据表生成：1、2 需要 scheme.sql 脚本，3 不需要（根据领域类自动生成）</li>\n<li>数据 model 的定义：\n<ol>\n<li>领域类注解：1 不需要为领域类加注解，2、3 要为领域类加注解（提供领域类和表结构的映射关系）\n<ol>\n<li>2：@Table， @Column，@Id</li>\n<li>3:  @Entity， @Id</li>\n</ol>\n</li>\n<li>ID 字段的处理：1 需要手动获取数据库生成的 Id，2、3 不需要</li>\n</ol>\n</li>\n<li>数据库访问层接口 / 自定义查询：\n<ol>\n<li>1 需要自己实现接口；</li>\n<li>2、3 不需要，2、3 都继承自 CrudRepository 接口，且可以自定义查询：\n<ol>\n<li>2、3 都可以使用 @Querry 定义查询逻辑</li>\n<li>但 3 还可以使用基于方法名的<strong> DSL 自定义</strong>查询，JPA 在自定义逻辑上更加灵活</li>\n<li><code>List&lt;TacoOrder&gt; findByDeliveryZip(String deliveryZip);</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>包路径：2、3 为领域类添加持久化的注解包路径不一样\n<ol>\n<li>JPA 中的规范注解都来自 <code>javax.persisitence.*</code>  ，因为不是 Spring 自己实现</li>\n<li>@Table，对象会基于领域类的名称映射到数据库的表上</li>\n<li>@Id\n<ul>\n<li>有两个来自不同包的 @Id，注意区别</li>\n</ul>\n</li>\n<li>@Column</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>特点</strong></th>\n<th></th>\n<th><strong>jdbcTemplate</strong></th>\n<th><strong>Spring Data JDBC</strong></th>\n<th><strong>Spring Data JPA</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据表生成</td>\n<td></td>\n<td>需要 scheme.sql 脚本</td>\n<td>需要 scheme.sql 脚本</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>数据 model 的定义</td>\n<td>领域类注解（提供领域类和表结构的映射关系）</td>\n<td>不需要</td>\n<td>需要</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>ID 字段的处理</td>\n<td>手动生成</td>\n<td>不需要</td>\n<td>不需要</td>\n<td></td>\n</tr>\n<tr>\n<td>数据库访问层接口 / 自定义查询</td>\n<td>接口</td>\n<td>自己实现</td>\n<td>继承自 CrudRepository 接口</td>\n<td>继承自 CrudRepository 接口</td>\n</tr>\n<tr>\n<td>@Querry 定义</td>\n<td></td>\n<td></td>\n<td>基于方法名的 DSL 自定义查询</td>\n<td></td>\n</tr>\n<tr>\n<td>包路径</td>\n<td></td>\n<td></td>\n<td></td>\n<td>JPA 中的规范注解都来自 <code>javax.persisitence.*</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"给了spring框架开发人员还要做什么\"><a class=\"anchor\" href=\"#给了spring框架开发人员还要做什么\">#</a> 给了 Spring 框架，开发人员还要做什么？</h2>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJkMjBiMjYyMDVlNjU1OGQ4NzkxNzhjODI2ZmYxMDBfRWZOU2FaWHRZUWU1OVN1a2xGenc0UTRFTWthWmF6TE1fVG9rZW46RjRiS2JYVkxXb0VPeWF4TThlZGM5RTBabmZjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<ol>\n<li>实现接口\n<ol>\n<li><code>UserDetailsService</code>  接口：给 Spring 框架提供用户详细信息。用户信息注册、存储和查询。\n<ul>\n<li>这里用到之前讲到数据访问层实现技术。</li>\n<li>和 spring security 解耦，只需要提供用户信息但不关心怎么实现。被 Spring Security 调用</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>实现密码加密 / 解密\n<ol>\n<li>PasswordEncoder 加密和解密的过程，springboot 提供了若干个</li>\n<li>Bean 对象</li>\n</ol>\n</li>\n<li>(optional) 实现登录页面\n<ol>\n<li>有默认页面，也可以自己实现</li>\n<li><code>/login</code> , Spring 已经自动实现了对应的 <code>Controller</code></li>\n</ol>\n</li>\n<li>调用<strong> HTTPSecurity 进行权限设置</strong>，分为两种：\n<ol>\n<li><code>SecurityFilterChain</code>  实现，基于注入的 <code>httpSecurity</code>  对象</li>\n<li>继承父类 <code>WebSecurityConfigurerAdapter</code> ，实现 <code>configure</code>  方法</li>\n</ol>\n</li>\n</ol>\n<p>PasswordEncoder：密码不能明文存储，需要加密后再存到数据库里</p>\n<ul>\n<li>需要定义 <code>Bean</code></li>\n</ul>\n<p>框架帮我们做了哪些事情：</p>\n<ol>\n<li>实现用户登录控制器（get、post）</li>\n<li>请求重定向到用户登录页面\n<ol>\n<li>eg. 用户未登录时，访问 URL，服务端重定向到登录页面</li>\n</ol>\n</li>\n<li>通过 Filter 对设定的权限进行控制（自己只需要做权限的设定即可）</li>\n</ol>\n<h2 id=\"用户信息存储\"><a class=\"anchor\" href=\"#用户信息存储\">#</a> 用户信息存储</h2>\n<ul>\n<li>内存用户存储\n<ul>\n<li>小型应用</li>\n</ul>\n</li>\n<li>JDBC 用户存储\n<ul>\n<li>持久化数据</li>\n</ul>\n</li>\n<li>LDAP（Lightweight Directory Access Protocol） 用户存储\n<ul>\n<li>轻量级目录访问协议，适用于大型企业，支持复杂查询和目录结构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"属性来源\"><a class=\"anchor\" href=\"#属性来源\">#</a> 属性来源</h2>\n<p>不仅仅是 Spring Boot 需要的属性，也包含我们自己定义的属性。</p>\n<p>常见的是第一个和第四个，第二个和第三个偶尔用</p>\n<ol>\n<li><strong>配置文件</strong> <code>application.yml</code> 、 <code>application.properties</code> ，两个文件可以混用\n<ol>\n<li><code>server.port = 8090</code></li>\n</ol>\n</li>\n<li><strong>命令行参数</strong> <code>commandLineArgs</code> ，在程序中直接获取\n<ol>\n<li><code>java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar -- server.port=8081</code></li>\n</ol>\n</li>\n<li><strong>JVM 系统参数</strong> <code>-D</code>\n<ol>\n<li><code>java -Dserver.port=8091 -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</code></li>\n</ol>\n</li>\n<li><strong>操作系统环境变量</strong>\n<ol>\n<li><code>set SERVER_PORT=8082、java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"接口设计的关键要求\"><a class=\"anchor\" href=\"#接口设计的关键要求\">#</a> 接口设计的关键要求</h2>\n<p>接口设计的关键要求：</p>\n<ol>\n<li>使用标准动词：GET\\POST\\PUT\\DELETE，映射到 CRUD</li>\n<li>使用 URI 来传达意图，URI 用名词不用动词，表明单复数 tacos</li>\n<li>请求和响应使用 json，基本上大家都是用 json 标准，方便与第三方交流和解决问题</li>\n<li>HTTP 状态码表示结果：200、201（created）等</li>\n</ol>\n<h2 id=\"oauth2流程图\"><a class=\"anchor\" href=\"#oauth2流程图\">#</a> OAuth2 流程图</h2>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE5MDBhYTQwMjVmOWFiZWQ0ZGI1NTNlMGE4YjhlOGNfUEJmczBTT0RwZzFqSVo5NXpkRkh0TWM4bExMNWttM3NfVG9rZW46TG9ROWJuQnNYbzhRRjF4d0c0YmNEU2NYbndkXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<p>主体对象：</p>\n<ol>\n<li>Authserver 授权服务器：授权、认证</li>\n<li>Authorization server 资源服务器</li>\n<li>Client application 客户端应用程序</li>\n<li>User 用户</li>\n</ol>\n<p>过程：</p>\n<p>其中使用<strong>授权码授权模式</strong></p>\n<ol>\n<li>用户使用第三方的应用程序，也就是客户端应用程序</li>\n<li>客户端发现用户未登录，把用户请求<strong>重定向</strong>到授权服务器\n<ol>\n<li>授权服务器会维护合法的重定向地址，用于校验</li>\n</ol>\n</li>\n<li>授权服务器向用户索取用户名密码</li>\n<li>用户名密码匹配，则授权服务器请求用户授权</li>\n<li><strong>授权服务器给客户端程序返回 code</strong>，重定向回到应用程序\n<ol>\n<li>code 需要经过浏览器</li>\n</ol>\n</li>\n<li><strong>客户端应用程序用 code 向授权服务器索取 token</strong>\n<ol>\n<li>用 code 交换 token</li>\n<li>token 不过浏览器，在应用程序服务端和授权服务器之间处理</li>\n</ol>\n</li>\n<li>客户端在请求头带上 token 调用资源服务器的 API</li>\n<li>资源服务器验证 token，返回结果\n<ol>\n<li>授权服务器会用<strong>私钥</strong>给 token 签名，资源服务器用<strong>公钥</strong>验证 token 是否合法</li>\n<li>第一次，资源服务器向授权服务器索取公钥，验证 Token 合法性</li>\n<li>Token 未过期时，不用再次索取公钥</li>\n<li>Token 过期时，才会重新索取公钥</li>\n</ol>\n</li>\n<li>客户端程序把结果返回给用户</li>\n</ol>\n<p>补充：</p>\n<p>密码没有在浏览器来回传送，但是如果没有密码即使拿到 code 也没用</p>\n<p>用 code 向授权服务器换取 token 才需要密码</p>\n<h2 id=\"rabbitmq组成\"><a class=\"anchor\" href=\"#rabbitmq组成\">#</a> RabbitMQ 组成</h2>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NDg5MTZlMGVlYWI0OWI1ODJkMWEyOTI0MjJjOTA0YmZfaTE2Qk82UzduSloyTXc4N01iTUcwWmhPbEgxM0M4Ym1fVG9rZW46V2Q3b2JzV2hCb0FNdDF4V0E1VGNQZlNNblBoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<ul>\n<li>ConnectionFactory、Connection、Channel</li>\n<li>Exchange：\n<ul>\n<li>Default、Direct、Topic、Fanout、Headers、Dead letter</li>\n</ul>\n</li>\n<li>Queue</li>\n<li><strong>Routing key</strong>：exchange 根据 routing key 确定消息发往哪个队列\n<ul>\n<li><strong>JMS 里没有这个概念</strong></li>\n</ul>\n</li>\n<li><strong>Binding key</strong></li>\n</ul>\n<h2 id=\"reactive-programming反应式编程解决什么问题\"><a class=\"anchor\" href=\"#reactive-programming反应式编程解决什么问题\">#</a> Reactive Programming 反应式编程解决什么问题？</h2>\n<ul>\n<li>IO 密集型场景</li>\n<li>同步阻塞模型，阻塞线程多，CPU 利⽤率不⾼，性能下降 —— 轮询解决</li>\n<li>管理多线程，意味着更⾼的复杂性</li>\n</ul>\n<h2 id=\"java的stream和反应式流的区别\"><a class=\"anchor\" href=\"#java的stream和反应式流的区别\">#</a> Java 的 Stream 和反应式流的区别</h2>\n<p>Java 的 stream 通常都是同步的，并且只能处理有限的数据集，本质上来说，它们只是使⽤函数来对集合进⾏迭代的⼀种⽅式</p>\n<p>JDK9 中的 Flow API 对应反应式流</p>\n<h2 id=\"反应式流规范定义的4个接口\"><a class=\"anchor\" href=\"#反应式流规范定义的4个接口\">#</a> 反应式流规范定义的 4 个接口</h2>\n<ul>\n<li>org.reactivestrea</li>\n<li>ms.*</li>\n</ul>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA0YzcwNjU1Mzc3ZDA2YmU4YjU4MDkyMWQyMjg3M2JfWlFtaGo2NTY4amRRbE41OXBaSU1CRjFTd29OTVBUbHpfVG9rZW46TkdwR2J0Q2dhbzhSZGR4WUREcGN6bHE1bkJnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<ul>\n<li>Publisher：数据发布者\n<ul>\n<li>subscribe</li>\n</ul>\n</li>\n<li>Subscriber：数据订阅者\n<ul>\n<li>onSubscribe 第一次建立连接时调用</li>\n<li>onNext</li>\n<li>onError</li>\n<li>onComplete</li>\n<li>消费者：如果⽣产者产⽣数据的速度⾮常快，消费者会来不及处理，⽤回压来调节，根据消费者的速度来发送数据。</li>\n</ul>\n</li>\n<li>Processor：处理器，既是数据的消费者，也是数据的发布者</li>\n<li>Subscription：协调者，在 Publisher 和 Subscriber 之间传递消息\n<ul>\n<li>request</li>\n<li>cancel</li>\n</ul>\n</li>\n</ul>\n<p>每个环节可能会在不同的线程⾥处理，处理过程是异步的。</p>\n<p>消费者驱动，消费者去请求发布者才会发布数据</p>\n<h2 id=\"spring-integration集成流解决什么问题\"><a class=\"anchor\" href=\"#spring-integration集成流解决什么问题\">#</a> Spring Integration 集成流解决什么问题</h2>\n<p>提供了一系列的组件和配置选项，用于在应用程序中实现消息传递和集成模式。</p>\n<p>解耦合、异步处理、轻量级集成</p>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJmNWE4MzA2MTdhNDc2YjQ1YTE5MTNhNTEyZTQ3NjZfYkRwQ1RJd0N0NUdobE8xYnd5NmRka1dxZ1N3blFMWTBfVG9rZW46RGFBbmJBcFYxb1pDVnd4a2R2WmNjaDBubldkXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFmZTYxMjhkZDdhMzczOTU3ZTU3MzU0ZjIzMmEwOTBfbDd3VWZPMml0UDNobHpzUFV5THBHN3VobkxJRHRERXVfVG9rZW46Tnh0VmJQc09Qb1AzSGV4aGQyNWN1UGtMbmpoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"mapflatmap\"><a class=\"anchor\" href=\"#mapflatmap\">#</a> map/flatMap</h2>\n<ul>\n<li>map：\n<ul>\n<li>同步</li>\n<li>返回具体值</li>\n</ul>\n</li>\n<li><strong>flatMap</strong>：\n<ul>\n<li>异步</li>\n<li>转换出来的<strong>返回结果还是一个流（Mono/Flux）</strong></li>\n<li>可以<strong>并发处理</strong>，指定用哪个并发模型处理\n<ul>\n<li>多个流并发处理结果合并成一个流，但结果顺序不可控</li>\n</ul>\n</li>\n<li><strong>扁平化</strong></li>\n</ul>\n</li>\n<li><strong>并发模型（Schedulers 方法）</strong>\n<ul>\n<li>.immediate()</li>\n<li>.single()</li>\n<li>.newSingle()</li>\n<li>.elastic()</li>\n<li>.parallel()</li>\n<li><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYyMDkyZjNkNTVkNjk3ZGQ4NTg2NDU4ZTI1ODdjNDlfR0dRNmlQOEdTaWZQT2ZWdjNLb0VsYnEyQlJuRzdNOFJfVG9rZW46QkoxNWJ5S0NWb2MyZUt4eU1KQWMwVzhubmUwXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></li>\n<li></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"docker的三部分\"><a class=\"anchor\" href=\"#docker的三部分\">#</a> docker 的三部分</h2>\n<p>容器：一个轻量化的虚拟机</p>\n<ul>\n<li>哪三部分？\n<ul>\n<li>docker engine：服务端，管理一系列资源的生命周期，包括容器 containers、images 和 volumns</li>\n<li>Client：一个命令行程序，和 docker daemon 交互</li>\n<li>Registry：镜像仓库，上传和下载镜像 images</li>\n</ul>\n</li>\n<li>每一部分由哪些部分构成？</li>\n</ul>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ1ODkxOWQ2YjFkZWRiMGQzMGM2YmI4MjQzNTRhZDJfY1FEamZkNzBMbXVZeld5Zk9oejBLSFFBMlF2VjJzNm9fVG9rZW46UUJRU2JJd2pVb1FqVDV4WTNRMmNsYjQ5bktmXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"容器与虚拟机的区别\"><a class=\"anchor\" href=\"#容器与虚拟机的区别\">#</a> 容器与虚拟机的区别</h2>\n<p>容器是在 Linux 内核实现的轻量级资源隔离机制</p>\n<p>虚拟机是操作系统级别的资源隔离，容器本质上是进程级的资源隔离</p>\n<h2 id=\"pod-container与node之间的关系\"><a class=\"anchor\" href=\"#pod-container与node之间的关系\">#</a> Pod container 与 node 之间的关系</h2>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg2MTgzNTg3YzQxZTBmNzU1MmNmZWI4ZDJiYzU3ZWRfN3M2TEJaeFpQVjN5MHNHV3lNTExZNnVPVllxWkZjMHpfVG9rZW46Vzh6UWJuS0lIb0hoYm14Z0k3d2NRMmhPbmZmXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n<h2 id=\"spring-mvc与spring-webflux的共性与不同\"><a class=\"anchor\" href=\"#spring-mvc与spring-webflux的共性与不同\">#</a> Spring MVC 与 Spring WebFlux 的共性与不同</h2>\n<ul>\n<li>不同\n<ul>\n<li>MVC：依赖多线程处理</li>\n<li>WebFlux：在事件轮询中处理请求\n<ul>\n<li>可以使用纯粹的函数式编程实现 Controller</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>共性\n<ul>\n<li>WebFlux 也可以使用 Controller、RequestMapping 等注解\n<ul>\n<li>WebFlux 的参数和返回值可能是流</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=N2VkNWZjNmQ2YWUyODUyNjM5ZTkyMWNhYTAxMWYwOGJfUkpWV29ud0F5NjV6SHBCYmFQNEJFTFh4TjJBQXVOSmdfVG9rZW46SWxkc2JLY2Jnb3J5RUt4MTZJOWNyNnc1bmtnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA\" alt=\"img\" /></p>\n",
            "tags": [
                "NJUSE",
                "服务端开发",
                "服务端开发"
            ]
        }
    ]
}