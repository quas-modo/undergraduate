<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Carpe diem</title>
        <subtitle>pluck the day</subtitle>
        <icon>https://quas-modo.github.io/undergraduate/images/favicon.ico</icon>
        <link>https://quas-modo.github.io/undergraduate</link>
        <author>
          <name>quas-modo</name>
        </author>
        <description>notes/thoughts/nonsense</description>
        <language>zh-CN</language>
        <pubDate>Mon, 15 Jan 2024 12:11:17 +0800</pubDate>
        <lastBuildDate>Mon, 15 Jan 2024 12:11:17 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/</guid>
            <title>服务端2023期末回忆</title>
            <link>https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/</link>
            <category term="NJUSE" scheme="https://quas-modo.github.io/undergraduate/categories/NJUSE/" />
            <category term="服务端开发" scheme="https://quas-modo.github.io/undergraduate/categories/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" />
            <category term="服务端开发" scheme="https://quas-modo.github.io/undergraduate/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" />
            <pubDate>Mon, 15 Jan 2024 12:11:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;南京大学软件学院服务端开发回忆。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;by cxy nyb dsy&lt;/p&gt;
&lt;h2 id=&#34;选择题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#选择题&#34;&gt;#&lt;/a&gt; 选择题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;横切关注点类型
&lt;ol&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;事务&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;aop 概念
&lt;ol&gt;
&lt;li&gt;通知 (Advice)：切面做什么？什么时候做？代表了切面的逻辑。&lt;/li&gt;
&lt;li&gt;切点 (Pointcut)：指定通知存放的位置，定义要改的方法和参数。&lt;/li&gt;
&lt;li&gt;切面 (Aspect)：通知 + 切点&lt;/li&gt;
&lt;li&gt;连接点：通知 + 切点的实例化：也就是和业务代码连接的地方&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Bean 的作用域
&lt;ol&gt;
&lt;li&gt;Singleton，单例，在整个应用中，只创建 bean 的一个实例&lt;/li&gt;
&lt;li&gt;Prototype，原型，每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新 bean 实例&lt;/li&gt;
&lt;li&gt;Session，会话，在 Web 应用中，为每个会话创建一个 bean 实例&lt;/li&gt;
&lt;li&gt;Request，请求，在 Web 应用中，为每个请求创建一个 bean 实例&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Redis 的数据类型
&lt;ol&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;属性来源
&lt;ol&gt;
&lt;li&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQyOTNlY2E1MzE0MjVhMzFhZjBiOTY3NzIyYzJjNmRfU2Y5OXdYd0dkZ1lFUENjVmdBZVpTcnB2UXQ0RWhKem1fVG9rZW46R3N0NGJKcHdMb29MN1J4RkN1SmNDaFoxbkFjXzE3MDUyOTI0OTU6MTcwNTI5NjA5NV9WNA&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;配置日志
&lt;ol&gt;
&lt;li&gt;默认使用 logback，日志配置文件 logback.xml&lt;/li&gt;
&lt;li&gt;默认日志级别&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;属于消息中间件的
&lt;ol&gt;
&lt;li&gt;Rabbit MQ&lt;/li&gt;
&lt;li&gt;Active MQ&lt;/li&gt;
&lt;li&gt;Active Artemis&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Kubernetes 调度的最小单元：pod&lt;/li&gt;
&lt;li&gt;创建新资源的状态码：201&lt;/li&gt;
&lt;li&gt;Docker compose 命令
&lt;ol&gt;
&lt;li&gt;Docker-compose logs -f [services]&lt;/li&gt;
&lt;li&gt;Docker-compose up&lt;/li&gt;
&lt;li&gt;Docker-compose stop&lt;/li&gt;
&lt;li&gt;Docker-compose build?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;acuator 相关
&lt;ol&gt;
&lt;li&gt;哪个包？&lt;/li&gt;
&lt;li&gt;供许多&lt;strong&gt;端点 (endpoints)&lt;/strong&gt;, 监测程序运行情况
&lt;ul&gt;
&lt;li&gt;/actuator，查询所有暴露端点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/actuator/configprops&lt;/strong&gt;，查询配置属性&lt;/li&gt;
&lt;li&gt;/actuator/health，健康检查&lt;/li&gt;
&lt;li&gt;/actuator/beans，包含 bean 依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;想要获得更多端点如何配置： &lt;code&gt;include: &amp;quot;*&amp;quot;&lt;/code&gt;  暴露所有端口，否则只暴露 &lt;code&gt;/actuator/health&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;docker 命令？&lt;/li&gt;
&lt;li&gt;Spring 集成流的组件
&lt;ol&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Routers&lt;/li&gt;
&lt;li&gt;Gateways&lt;/li&gt;
&lt;li&gt;Filters&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;哪些是请求映射的注解
&lt;ol&gt;
&lt;li&gt;RequestMapping&lt;/li&gt;
&lt;li&gt;GetMapping&lt;/li&gt;
&lt;li&gt;PostMapping&lt;/li&gt;
&lt;li&gt;PutMapping&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;JPA 的 DSL
&lt;ol&gt;
&lt;li&gt;Read&lt;/li&gt;
&lt;li&gt;Count&lt;/li&gt;
&lt;li&gt;Find&lt;/li&gt;
&lt;li&gt;Get&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DOCKERFILE 最佳实践
&lt;ol&gt;
&lt;li&gt;容器只运行&lt;strong&gt;单个应用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个 RUN 指令后删除多余文件&lt;/li&gt;
&lt;li&gt;基础镜像的标签不要用 latest&lt;/li&gt;
&lt;li&gt;每个 RUN 指令后删除多余文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;镜像分层
&lt;ol&gt;
&lt;li&gt;最上面一层可读写，下面只读&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Git 本地工作区 - 暂存区的命令&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;简答题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简答题&#34;&gt;#&lt;/a&gt; 简答题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;分层架构&lt;/li&gt;
&lt;li&gt;security 自己要实现的四个方面&lt;/li&gt;
&lt;li&gt;反应式编程的四个接口，以及它们之间的关系？&lt;/li&gt;
&lt;li&gt;docker 组成部分&lt;/li&gt;
&lt;li&gt;数据库初始化的时机&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid>
            <title>服务端期末复习</title>
            <link>https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link>
            <category term="NJUSE" scheme="https://quas-modo.github.io/undergraduate/categories/NJUSE/" />
            <category term="服务端开发" scheme="https://quas-modo.github.io/undergraduate/categories/NJUSE/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" />
            <category term="服务端开发" scheme="https://quas-modo.github.io/undergraduate/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" />
            <pubDate>Mon, 15 Jan 2024 12:10:11 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;南京大学软件学院服务端开发期末整理。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;多选题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多选题&#34;&gt;#&lt;/a&gt; 多选题&lt;/h1&gt;
&lt;h2 id=&#34;核心技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#核心技术&#34;&gt;#&lt;/a&gt; 核心技术&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DI（Dependency Injection）
&lt;ol&gt;
&lt;li&gt;保留抽象接口，让组件（Component）依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，&lt;strong&gt;由抽象接口来注入依赖的实际对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;AOP（Aspect Oriented Programming）
&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;预编译方式&lt;/strong&gt;和&lt;strong&gt;运行期间动态代理&lt;/strong&gt;实现程序功能的统一维护的一种技术&lt;/li&gt;
&lt;li&gt;利用 AOP 可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;依赖注入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#依赖注入&#34;&gt;#&lt;/a&gt; 依赖注入&lt;/h2&gt;
&lt;h2 id=&#34;aop&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt; AOP&lt;/h2&gt;
&lt;h3 id=&#34;横切关注点类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#横切关注点类型&#34;&gt;#&lt;/a&gt; 横切关注点类型&lt;/h3&gt;
&lt;p&gt;日志、安全、事务、缓存（可选：继承、委托）&lt;/p&gt;
&lt;h3 id=&#34;advice注解类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#advice注解类型&#34;&gt;#&lt;/a&gt; Advice 注解类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@Before&lt;/li&gt;
&lt;li&gt;@After：不区分是否正常结束&lt;/li&gt;
&lt;li&gt;@AfterReturning&lt;/li&gt;
&lt;li&gt;@AfterThrowing&lt;/li&gt;
&lt;li&gt;@Around：结合前面所有类型，around 可以是综合，之前、之后、结束、抛异常之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;被切方法成功运行之后会执行&lt;/strong&gt;：After、AfterReturning、Around&lt;/p&gt;
&lt;h3 id=&#34;aspectj可以实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#aspectj可以实现&#34;&gt;#&lt;/a&gt; AspectJ 可以实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;指定在哪些方法上切入&lt;/li&gt;
&lt;li&gt;获取参数&lt;/li&gt;
&lt;li&gt;限定包路径&lt;/li&gt;
&lt;li&gt;限定 bean 名称，白名单或黑名单&lt;/li&gt;
&lt;li&gt;限定在特定注解上切入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-mvc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt; Spring MVC&lt;/h2&gt;
&lt;h3 id=&#34;谁有component的效果&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#谁有component的效果&#34;&gt;#&lt;/a&gt; 谁有 @Component 的效果？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@Controller&lt;/code&gt; 、 &lt;code&gt;@Service&lt;/code&gt;  和  &lt;code&gt;@Repository&lt;/code&gt;  三个注解本身有  &lt;code&gt;@Component&lt;/code&gt;  的实例化效果。&lt;/p&gt;
&lt;h3 id=&#34;重定向&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#重定向&#34;&gt;#&lt;/a&gt; 重定向&lt;/h3&gt;
&lt;p&gt;控制器处理完成后可以返回逻辑视图名，也可以重定向到其他 url&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http 状态码：302 FOUND
&lt;ul&gt;
&lt;li&gt;HTTP 状态码 302 表示 “Found”（或者有时被称为 “Temporary Redirect” 临时重定向）。当一个 Web 服务器返回这个状态码时，它通常是在告诉客户端，请求的资源暂时被移动到了一个不同的 URI（统一资源标识符）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制器 &lt;code&gt;return redirect:&amp;lt;url&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spring-mvc获取参数的几种方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc获取参数的几种方式&#34;&gt;#&lt;/a&gt; Spring MVC 获取参数的几种方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;表单 (form) 参数，转成 model
&lt;ol&gt;
&lt;li&gt;成员类型可能要自己实现 Converter 进行转换&lt;/li&gt;
&lt;li&gt;可以用 &lt;code&gt;@Valid&lt;/code&gt;  校验&lt;/li&gt;
&lt;li&gt;form 是 html 里定义的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路径参数
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@PathVariable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例： &lt;code&gt;/book/&amp;#123;id&amp;#125;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;请求参数 / 查询参数
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@RequestParam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例： &lt;code&gt;/challenge?model=2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;json 请求体
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@RequestBody&lt;/code&gt; ，会用到 HttpMessageConverter 消息转换器&lt;/li&gt;
&lt;li&gt;Rest API&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-data-jdbcjpa&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-data-jdbcjpa&#34;&gt;#&lt;/a&gt; Spring Data JDBC/JPA&lt;/h2&gt;
&lt;h3 id=&#34;数据表创建和初始化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据表创建和初始化&#34;&gt;#&lt;/a&gt; 数据表创建和初始化&lt;/h3&gt;
&lt;p&gt;三种方式，java 代码初始化有两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表&lt;/li&gt;
&lt;li&gt;commandlinerunner&lt;/li&gt;
&lt;li&gt;applicationrunner&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三种方式关于 id 字段的处理：第一种方法需要主动地获取数据库新的 id 是什么，但二 / 三种没有需要&lt;/p&gt;
&lt;h4 id=&#34;脚本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#脚本&#34;&gt;#&lt;/a&gt; 脚本&lt;/h4&gt;
&lt;p&gt;schema.sql 表创建&lt;/p&gt;
&lt;p&gt;data.sql 数据初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java 代码初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CommandLineRunner 接口&lt;/p&gt;
&lt;p&gt;ApplicationRunner 接口&lt;/p&gt;
&lt;h3 id=&#34;异常体系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异常体系&#34;&gt;#&lt;/a&gt; 异常体系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SQLException
&lt;ul&gt;
&lt;li&gt;发现异常很难恢复&lt;/li&gt;
&lt;li&gt;难以确定异常类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hibernate 异常
&lt;ul&gt;
&lt;li&gt;定义了许多具体异常，方便定位&lt;/li&gt;
&lt;li&gt;对业务对象侵入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spring 提供与平台无关的异常
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DataAccessException&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;具体异常，方便定位&lt;/li&gt;
&lt;li&gt;隔离具体数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;springdata-mongodbredis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#springdata-mongodbredis&#34;&gt;#&lt;/a&gt; SpringData MongoDB\Redis&lt;/h2&gt;
&lt;h3 id=&#34;nosql特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nosql特点&#34;&gt;#&lt;/a&gt; Nosql 特点&lt;/h3&gt;
&lt;p&gt;键值对存储、列存储、文档存储、图形数据库&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY0MDg0M2M5N2NlNTBjNzc5M2Y1M2U5NzM4YTE0YjhfVlJmbDlwOG1wcjFmZWpCTjF6Q1dVazI0bHRqSkQ1dXFfVG9rZW46TnhRZ2JjOWpzb0Q0cDB4Mk9RbWNPUWVwbkJqXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;mongodb特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mongodb特点&#34;&gt;#&lt;/a&gt; MongoDB 特点&lt;/h3&gt;
&lt;p&gt;基于分布式文件存储的开源数据库系统，类似 json 格式存储&lt;/p&gt;
&lt;p&gt;MongoDB Shell 是 MongoDB 自带的交互式 Javascript shell, 用来对 MongoDB 进行操作和管理的交互式环境&lt;/p&gt;
&lt;h3 id=&#34;mongodb概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mongodb概念&#34;&gt;#&lt;/a&gt; MongoDB 概念&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTliZWYwYmUzMWEwMGUxYmY5YzY4ZjJkMjJkYjI0M2VfTFExcm9ia0VrakMwRDRweG9LaEE1c3N2R0VoOEFYd1FfVG9rZW46QjluVGJkRXg0bzU2Zm14NVhrZWNYVnhSbnVjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;redis特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#redis特点&#34;&gt;#&lt;/a&gt; Redis 特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分布式存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存数据库&lt;/strong&gt;，存在内存里，常用于作缓存&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;持久化&lt;/strong&gt;，但不太重要，不是主要用途&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;集群式部署&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;主从复制，主机写，从机并发读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;key-value 的&lt;strong&gt; Hash 表&lt;/strong&gt;结构，区分大小写&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis数据类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#redis数据类型&#34;&gt;#&lt;/a&gt; Redis 数据类型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;redis指定序列化器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#redis指定序列化器&#34;&gt;#&lt;/a&gt; Redis 指定序列化器&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJjNzUwZjQzZjM2ZjlkN2FjYWM4ZjQyZTJkMzdkYTFfOUJUU1BHN3NiWDNZb3lXSEVKU051Z1hnZFBPV1hOQ0RfVG9rZW46QjZMYWJNd081b2dLNUJ4T1pCT2NPTjVmblFiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;mongodb 没有这个要求，因为它会把所有值都转成 json 串。&lt;/p&gt;
&lt;p&gt;redis 默认使用 JDK 序列化，但 JSON 序列化更常用。&lt;/p&gt;
&lt;h2 id=&#34;spring-security&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-security&#34;&gt;#&lt;/a&gt; Spring Security&lt;/h2&gt;
&lt;p&gt;划分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;针对客户 web 请求权限控制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;针对方法级的权限控制&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实现方法级别的安全&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实现方法级别的安全&#34;&gt;#&lt;/a&gt; 实现方法级别的安全&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQyNTMyZTBiZWNmN2VlMDk0ZWFhOGMyZDZjMTA2MmVfejVyRnl1blI0MkRYYnIzWWhjOVkzNDZhdUVIemdiUkNfVG9rZW46RmsxeGJzc0ZJbzBwMGp4VktSamNkZWs0bmlYXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;获取当前登录的用户&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#获取当前登录的用户&#34;&gt;#&lt;/a&gt; 获取当前登录的用户&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE2MDNjMTllZWU0MjQ3MTFiOGU3YWIwOThkNGQyZDRfMkt0Z1BBWmQxclh4MHVyMHBjcFlZNFJpM1Z1MkhibmdfVG9rZW46VDFCQ2J2Qnhjb2Q4MFp4OENZZmM0ak1vbkxiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置属性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置属性&#34;&gt;#&lt;/a&gt; 配置属性&lt;/h2&gt;
&lt;h3 id=&#34;actuator&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#actuator&#34;&gt;#&lt;/a&gt; Actuator&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供许多&lt;strong&gt;端点 (endpoints)&lt;/strong&gt;, 监测程序运行情况
&lt;ul&gt;
&lt;li&gt;/actuator，查询所有暴露端点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/actuator/configprops&lt;/strong&gt;，查询配置属性&lt;/li&gt;
&lt;li&gt;/actuator/health，健康检查&lt;/li&gt;
&lt;li&gt;/actuator/beans，包含 bean 依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;想要获得更多端点如何配置： &lt;code&gt;include: &amp;quot;*&amp;quot;&lt;/code&gt;  暴露所有端口，否则只暴露 &lt;code&gt;/actuator/health&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rest-api&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rest-api&#34;&gt;#&lt;/a&gt; Rest API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 协议的四个操作方式的动词：GET、POST、PUT、DELETE
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CRUD：Create、Read、Update、Delete&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;GET: Read&lt;/li&gt;
&lt;li&gt;POST: Create&lt;/li&gt;
&lt;li&gt;PUT: Update&lt;/li&gt;
&lt;li&gt;DELETE: Delete&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;requestmapping&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#requestmapping&#34;&gt;#&lt;/a&gt; RequestMapping/&lt;/h3&gt;
&lt;p&gt;实现控制器的时候 RequestMapping 可以加在？类、方法上面&lt;/p&gt;
&lt;h3 id=&#34;restcontroller&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#restcontroller&#34;&gt;#&lt;/a&gt; RestController&lt;/h3&gt;
&lt;p&gt;在 Controller 类中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Plain&#34;&gt;@RestController  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Plain&#34;&gt;@Controller  
@ResponseBody  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要某个方法返回的&lt;strong&gt; Java 对象转成 json 格式串&lt;/strong&gt;： &lt;code&gt;@ResponseBody&lt;/code&gt;  注解加在特定函数上&lt;/p&gt;
&lt;h3 id=&#34;响应头与响应体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#响应头与响应体&#34;&gt;#&lt;/a&gt; 响应头与响应体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;状态行：由 &lt;strong&gt;HTTP 协议版本、状态码、状态码描述&lt;/strong&gt;三部分构成，它们之间由空格隔开。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;oauth2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#oauth2&#34;&gt;#&lt;/a&gt; OAuth2&lt;/h2&gt;
&lt;p&gt;解决分布式系统中，权限控制的问题&lt;/p&gt;
&lt;h2 id=&#34;消息中间件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#消息中间件&#34;&gt;#&lt;/a&gt; 消息中间件&lt;/h2&gt;
&lt;h3 id=&#34;定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定义&#34;&gt;#&lt;/a&gt; 定义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供消息服务的应用程序&lt;/li&gt;
&lt;li&gt;主要用于组件之间的解耦，消息的发送者服务知道消息使用者的存在，反之依然&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息代理 broker：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg4NTg1ZjI3MTI3YjM0YjUxNWU5MDYzNzZjY2RjMjdfRjhidzJ1TU04b3RTUmFZbjg1UWJmS0dQNXc2NFUxQkdfVG9rZW46TzRPMWJ0R1NSb0hDSlB4eGo5Z2M2dUpIbnpoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;jms&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#jms&#34;&gt;#&lt;/a&gt; JMS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Java Message Service
&lt;ul&gt;
&lt;li&gt;Jms 规定了&lt;strong&gt; ConnectionFactory、Connection、Session&lt;/strong&gt; 等接口 / 类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;activemq&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#activemq&#34;&gt;#&lt;/a&gt; ActiveMQ&lt;/h3&gt;
&lt;p&gt;支持协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JMS&lt;/li&gt;
&lt;li&gt;AMQP: Advanced Message Queueing Protocol&lt;/li&gt;
&lt;li&gt;MQTT: Message Queuing Telemetry Transport&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持 Native 内存模式和 JVM 内存模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Native 可以绕过 JVM，加快访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息持久化&lt;/p&gt;
&lt;p&gt;分布式架构&lt;/p&gt;
&lt;h4 id=&#34;关键概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关键概念&#34;&gt;#&lt;/a&gt; 关键概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Message：类似广播，生产端&lt;/li&gt;
&lt;li&gt;Destination：队列或主题。消费端
&lt;ul&gt;
&lt;li&gt;三种指定方式：
&lt;ul&gt;
&lt;li&gt;application.yml（default-destination）&lt;/li&gt;
&lt;li&gt;@Bean（Destination 对象）&lt;/li&gt;
&lt;li&gt;直接 String 指定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接收模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#接收模式&#34;&gt;#&lt;/a&gt; 接收模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;拉取和推送都需要消息转换器做反序列化。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;351-拉取模式-pull-model&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#351-拉取模式-pull-model&#34;&gt;#&lt;/a&gt; 3.5.1. 拉取模式 pull model&lt;/h4&gt;
&lt;p&gt;JmsTemplate 支持&lt;/p&gt;
&lt;p&gt;访问 URL&lt;/p&gt;
&lt;h4 id=&#34;352-推送模式-push-model&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#352-推送模式-push-model&#34;&gt;#&lt;/a&gt; 3.5.2. 推送模式 push model&lt;/h4&gt;
&lt;p&gt;需要&lt;strong&gt;定义消息监听器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@JmsListener&lt;/p&gt;
&lt;h3 id=&#34;rabbitmq&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rabbitmq&#34;&gt;#&lt;/a&gt; RabbitMQ&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现 AMQP 协议&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概念&#34;&gt;#&lt;/a&gt; 概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ConnectionFactory、Connection、Channel&lt;/li&gt;
&lt;li&gt;Exchange：
&lt;ul&gt;
&lt;li&gt;Default、Direct、Topic、Fanout、Headers、Dead letter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt;：exchange 根据 routing key 确定消息发往哪个队列
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JMS 里没有这个概念&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binding key&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVkZDE0OWRkMDVjMWFmYjZjMDFlZGIzZmRkOTQ2N2JfRWhtV3JOZG9tMlAxanFhOUF5U0hnSzlJMXdoUUFVUGdfVG9rZW46QU9QcmI3WW5tb0lqM0R4TFcxZWNmMzVlbjVnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;一些 gpt 解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;connectionFactory: 这是一个创建连接到 RabbitMQ 服务器的工厂类。它封装了与 RabbitMQ 服务器连接所需的配置信息，如主机名、端口、用户名和密码。&lt;/li&gt;
&lt;li&gt;Connection: 这是客户端和 RabbitMQ 服务器之间的网络连接。ConnectionFactory 用于创建这个连接。&lt;/li&gt;
&lt;li&gt;Channel: 一旦建立了连接，Channel 就是在这个连接上进行通信的途径。可以将其视为连接内的一个轻量级会话。在 RabbitMQ 中，几乎所有的操作都是通过 Channel 来完成的，如声明队列、交换机或发布消息等。&lt;/li&gt;
&lt;li&gt;Exchange: 交换机是 RabbitMQ 的一个消息路由机制。它指定消息应该如何路由到不同的队列。RabbitMQ 提供了几种类型的交换机：
&lt;ol&gt;
&lt;li&gt;Default Exchange: 默认交换机是一个直接交换机，用于路由特定 Routing Key 的消息。&lt;/li&gt;
&lt;li&gt;Direct Exchange: 直接交换机将消息路由到具有特定 Routing Key 的队列。&lt;/li&gt;
&lt;li&gt;Topic Exchange: 主题交换机基于模式匹配 Routing Key 来路由消息。&lt;/li&gt;
&lt;li&gt;Fanout Exchange: 扇出交换机将收到的消息广播到它所知道的所有队列。&lt;/li&gt;
&lt;li&gt;Headers Exchange: 头交换机基于消息头信息而不是 Routing Key 来路由消息。&lt;/li&gt;
&lt;li&gt;Dead Letter Exchange: 死信交换机用于处理无法正常处理的消息，如被拒绝或超时的消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何查看镜像中的网卡信息和ip地址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如何查看镜像中的网卡信息和ip地址&#34;&gt;#&lt;/a&gt; 如何查看镜像中的网卡信息和 ip 地址&lt;/h2&gt;
&lt;p&gt;docker run --rm -it busybox&lt;/p&gt;
&lt;p&gt;cat /etc/hosts&lt;/p&gt;
&lt;p&gt;ip a&lt;/p&gt;
&lt;h2 id=&#34;integration&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#integration&#34;&gt;#&lt;/a&gt; Integration&lt;/h2&gt;
&lt;h3 id=&#34;service-activators&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#service-activators&#34;&gt;#&lt;/a&gt; Service activators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MessageHandler
&lt;ul&gt;
&lt;li&gt;处理完流就截止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GenericHandler
&lt;ul&gt;
&lt;li&gt;有返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gateways&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gateways&#34;&gt;#&lt;/a&gt; Gateways&lt;/h3&gt;
&lt;p&gt;只需要写一个接口。 Gateways 是&lt;strong&gt;应用程序代码和消息系统之间的桥梁&lt;/strong&gt;。它们抽象了消息发送和接收的细节，使得应用程序代码可以通过方法调用的方式与消息系统交互，而无需直接使用消息 API。这样可以使应用程序代码保持简洁，同时也便于测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单向网关&lt;/li&gt;
&lt;li&gt;双向网关
&lt;ul&gt;
&lt;li&gt;requets channel 输入&lt;/li&gt;
&lt;li&gt;repley channel 获得返回值（Spring 会在这个管道上一直等，同步）\&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;channel-adapters&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#channel-adapters&#34;&gt;#&lt;/a&gt; Channel adapters&lt;/h3&gt;
&lt;p&gt;Adapters 则是用于将&lt;strong&gt;消息从一种格式转换为另一种格式&lt;/strong&gt;，或者从一种传输协议转换为另一种传输协议。Inbound 把外部系统的消息格式转为 spring integration 消息，outbound 把 spring integration 消息转为外部系统消息。 例如，JMS 适配器可以将 JMS 消息转换为 Spring Integration 通用消息，HTTP 适配器可以将 HTTP 请求和响应转换为 Spring Integration 消息。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTcyMGY0ZjBkMDhlNjEwOWFjMmZhNmQxOTRkZTFkNzhfaE9xMVRhNmk3TGtLZGV1N3FYSndZalRNdlhramRkZmdfVG9rZW46RnNnZWJrRENlb1ZtQnB4S1FwNGNFYnYxbjhiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;反应式编程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反应式编程&#34;&gt;#&lt;/a&gt; 反应式编程&lt;/h2&gt;
&lt;h3 id=&#34;操作类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作类型&#34;&gt;#&lt;/a&gt; 操作类型&lt;/h3&gt;
&lt;p&gt;创建、组合、过滤、转换、逻辑&lt;/p&gt;
&lt;h2 id=&#34;webflux&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#webflux&#34;&gt;#&lt;/a&gt; WebFlux&lt;/h2&gt;
&lt;h3 id=&#34;使用函数式编程范式来定义控制器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用函数式编程范式来定义控制器&#34;&gt;#&lt;/a&gt; 使用函数式编程范式来定义控制器&lt;/h3&gt;
&lt;p&gt;HandlerFunction 表示处理接收到的请求并生成响应的函数&lt;/p&gt;
&lt;p&gt;RouterFunction 替代了 @RequestMapping 注解。它用于将接收到的请求路由到处理函数&lt;/p&gt;
&lt;h3 id=&#34;函数式编程模型涉及的4个类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数式编程模型涉及的4个类型&#34;&gt;#&lt;/a&gt; 函数式编程模型涉及的 4 个类型&lt;/h3&gt;
&lt;p&gt;RequestPredicate&lt;/p&gt;
&lt;p&gt;RouterFunction&lt;/p&gt;
&lt;p&gt;ServerRequest&lt;/p&gt;
&lt;p&gt;ServerResponse&lt;/p&gt;
&lt;h1 id=&#34;简答题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#简答题&#34;&gt;#&lt;/a&gt; 简答题&lt;/h1&gt;
&lt;h2 id=&#34;bean的三种注入方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bean的三种注入方式&#34;&gt;#&lt;/a&gt; Bean 的三种注入方式&lt;/h2&gt;
&lt;h3 id=&#34;构造方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#构造方法&#34;&gt;#&lt;/a&gt; 构造方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在构造函数上使用 @Autowired 注解，用于自动注入构造函数参数所需要的 Bean。&lt;strong&gt;如果构造函数只有一个参数，则可以省略 @Autowired 注解。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p this.myDao=&#34;&#34;&gt;@Autowired public MyService(MyDao myDao)&lt;/p&gt;
&lt;h3 id=&#34;setter方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#setter方法&#34;&gt;#&lt;/a&gt; setter 方法&lt;/h3&gt;
&lt;p this.orderRepo=&#34;&#34;&gt;public void setOrderRepo(OrderRepository orderRepo)&lt;/p&gt;
&lt;p&gt;也可以加 &lt;code&gt;Autowired&lt;/code&gt;  自动注入.&lt;/p&gt;
&lt;p this.orderRepo=&#34;&#34;&gt;@Autowired public void setOrderRepo(OrderRepository orderRepo)&lt;/p&gt;
&lt;h3 id=&#34;属性字段下加autowired&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#属性字段下加autowired&#34;&gt;#&lt;/a&gt; 属性字段下加 &lt;code&gt;@Autowired&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;@Autowired&lt;/p&gt;
&lt;p&gt;private MyBean myBean;&lt;/p&gt;
&lt;h2 id=&#34;spring配置方案&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring配置方案&#34;&gt;#&lt;/a&gt; &lt;strong&gt;Spring 配置方案&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;自动化配置&lt;/li&gt;
&lt;li&gt;javaconfig - 第三方库&lt;/li&gt;
&lt;li&gt;XML 配置&lt;/li&gt;
&lt;li&gt;混合配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY4ZDBkMGMwOTEyNGZhZjBmYzJkYWJjNGI2ZWZhN2JfdlkwNmp4c3NYN1o0UFJGcndjQjFNZnk1WGFlVDhXZGtfVG9rZW46QjJ1RmJVWUx3bzBic0p4VUNlU2N4cWxrbmJoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动配置
&lt;ol&gt;
&lt;li&gt;组件扫描 component scanning
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;  配置类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;  从当前包递归找加了注解 &lt;code&gt;@Component&lt;/code&gt;  的类，并把它们都实例化出来。表示要在那些包路径下搜索。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动装配 autowiring  &lt;code&gt;@Autowired&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;用在构造器&lt;/li&gt;
&lt;li&gt;用在属性 setter 方法&lt;/li&gt;
&lt;li&gt;用在（私有）属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;required=false&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;在 Spring 框架中使用  &lt;code&gt;@Autowired&lt;/code&gt;  注解时， &lt;code&gt;required=false&lt;/code&gt;  这一属性表示如果 Spring 容器中没有找到匹配的 bean 来注入，那么它将允许这个属性保持未设置状态，即不会抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要实例化的 Bean： &lt;code&gt;@Component&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;默认是&lt;strong&gt;单实例模式&lt;/strong&gt;，在 Spring 上下文永远只有一个实例&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;参数指定多实例&lt;/strong&gt;，比如 &lt;code&gt;@Component(&amp;quot;soundsystem&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Javaconfig
&lt;ol&gt;
&lt;li&gt;应用场景：自动化配置行不通，如第三方库&lt;/li&gt;
&lt;li&gt;注解
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Bean(name=“..”)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注入
&lt;ul&gt;
&lt;li&gt;调用方法&lt;/li&gt;
&lt;li&gt;通过方法参数自动装配（其他配置类，其他方法创建的 Bean）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意与业务逻辑和领域代码分开：只用于创建，不会把业务逻辑放进来&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Xml
&lt;ol&gt;
&lt;li&gt;格式： &lt;code&gt;&amp;lt;beans&amp;gt;&amp;lt;bean&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无类型检查&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;构造器注入
&lt;ul&gt;
&lt;li&gt;constructor-arg&lt;/li&gt;
&lt;li&gt;c - 命名空间&lt;/li&gt;
&lt;li&gt;注入字面量值&lt;/li&gt;
&lt;li&gt;注入集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;属性注入
&lt;ul&gt;
&lt;li&gt;p - 命名空间&lt;/li&gt;
&lt;li&gt;util - 命名空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建议：强依赖使用构造器注入&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;混合配置
&lt;ol&gt;
&lt;li&gt;在根配置类中导入其他配置类。&lt;/li&gt;
&lt;li&gt;JavaConfig 导入
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@import(配置类,class,...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@importResource(xml文件)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;XML 导入
&lt;ul&gt;
&lt;li&gt;&amp;lt;import resource=“xml 文件”/&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;bean class=“配置类”/&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;aop解决什么问题开发要点是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#aop解决什么问题开发要点是什么&#34;&gt;#&lt;/a&gt; AOP 解决什么问题？开发要点是什么？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;strong&gt;预编译方式&lt;/strong&gt;和&lt;strong&gt;运行期间动态代理&lt;/strong&gt;实现程序功能的统一维护的一种技术&lt;/li&gt;
&lt;li&gt;利用 AOP 可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOP 面向接口的编程，增强模块化，将影响多个模块但又与业务逻辑不直接相关的问题提取出（安全、日志、事务、缓存等），实现横切关注点，提高代码的可维护性和可读性，降低耦合&lt;/p&gt;
&lt;p&gt;开发要点：定义通知 Advice、切点 Pointcut、Aspect 等，确定在何时、何处切入，完成什么操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;通知 Advice&lt;/strong&gt;：切面要做什么以及何时做
&lt;ol&gt;
&lt;li&gt;时间：方法前 / 后…&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切点 Pointcut&lt;/strong&gt;：指定在何处切
&lt;ol&gt;
&lt;li&gt;Spring 只支持在方法的前后切&lt;/li&gt;
&lt;li&gt;写&lt;strong&gt;切点表达式&lt;/strong&gt;指定逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切面 Aspect&lt;/strong&gt;：Advice 和 Pointcut 的结合
&lt;ol&gt;
&lt;li&gt;包含切的所有逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接点 Join point&lt;/strong&gt;：方法、字段修改、构造方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入 introduction&lt;/strong&gt;：引入新的行为和状态
&lt;ol&gt;
&lt;li&gt;给对象加入新的方法 / 状态，但不需要实现新的子类。在原来的对象上动态加入新的方法 / 状态。&lt;/li&gt;
&lt;li&gt;引入方式
&lt;ul&gt;
&lt;li&gt;创建需要增加的接口和实现类&lt;/li&gt;
&lt;li&gt;新建一个切面类，加 &lt;code&gt;@Aspect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在里面定义一个新增实现类的 &lt;code&gt;static&lt;/code&gt;  接口，加上 &lt;code&gt;@DeclareParents&lt;/code&gt;  注解&lt;/li&gt;
&lt;li&gt;实例化切面类 Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;织入 Weaving&lt;/strong&gt;：切面应用到目标对象的过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-web-开发框架的分层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-web-开发框架的分层&#34;&gt;#&lt;/a&gt; Spring Web 开发框架的分层&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA5YjMyODU3NGM5ODU4MzZkNTQ1ZTM2M2UyZjBlNGJfeFRPMjVlUmlMMFRmZm5aUllldHBqMGx3Q1ljU2JtTTBfVG9rZW46Q0lONWJGWWprb3hPZ2J4ZzNleWNNOHNxblFiXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;web框架请求的处理过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web框架请求的处理过程&#34;&gt;#&lt;/a&gt; Web 框架请求的处理过程&lt;/h2&gt;
&lt;h3 id=&#34;客户端请求参数分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#客户端请求参数分类&#34;&gt;#&lt;/a&gt; 客户端请求参数分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;路径参数， &lt;code&gt;@PathVariable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求参数（查询参数）， &lt;code&gt;@RequestParam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表单参数，应用于前后端不分离的传统场景，默认，对应 model 对象，可以使用  &lt;code&gt;@Valid&lt;/code&gt;  校验&lt;/li&gt;
&lt;li&gt;&lt;code&gt;json&lt;/code&gt;  请求体，应用于前后端分离的场景，使用  &lt;code&gt;@RequestBody&lt;/code&gt;  把  &lt;code&gt;json&lt;/code&gt;  格式转成 java 对象； &lt;code&gt;@ResponseBody&lt;/code&gt; ，把 java 对象转成  &lt;code&gt;json&lt;/code&gt;  格式&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;处理流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理流程&#34;&gt;#&lt;/a&gt; 处理流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;控制器根据 url 捕获请求，控制器解析并获取参数，同时将转向业务层进行处理&lt;/li&gt;
&lt;li&gt;涉及到数据的持久化则访问数据访问层，访问完毕后返回业务层，业务层处理完毕将结果数据返回到控制器&lt;/li&gt;
&lt;li&gt;控制器的响应处理：
&lt;ol&gt;
&lt;li&gt;前后端分离：返回 Java 对象，同时加上  &lt;code&gt;@ResponseBody&lt;/code&gt;  注解，表示返回的对象将被自动转换为 JSON 或其他格式。前端处理数据并渲染到页面上。&lt;/li&gt;
&lt;li&gt;前后端不分离：控制器将数据赋值给 model 的属性，并返回视图名；根据视图名做视图解析，找到模板路径；通过第三方页面渲染，将 model 数据渲染到最终页面中，返回 html 格式文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在类的上方加注解  &lt;code&gt;@RestController&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;mvc架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mvc架构&#34;&gt;#&lt;/a&gt; MVC 架构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;M&lt;/strong&gt;odel-&lt;strong&gt;V&lt;/strong&gt;iew-&lt;strong&gt;C&lt;/strong&gt;ontroller&lt;/p&gt;
&lt;p&gt;MVC 模式用于前后端不分离的开发场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型 model：处理业务逻辑；存储、读取、处理数据&lt;/li&gt;
&lt;li&gt;控制器 controller：处理用户输入，处理客户端的请求；返回数据（model）&lt;/li&gt;
&lt;li&gt;视图 view：显示内容，model 和 view 结合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJhMTQ3NjE1YTRmZTk0NWMwMTJkN2RmMTI3YzA4ZmZfU2pRTE1aMTZDbHI3Y1lZcFBEUjVCQ25BN2VKT1R4SnVfVG9rZW46TWw4V2JCODJJb3pDM214UDRlQWN5Wm5YbmtjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;spring-mvc的请求过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc的请求过程&#34;&gt;#&lt;/a&gt; Spring MVC 的请求过程&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc1ZDQ1MTAxMDU5YjVmNDQ0YjQ1NGQ4ZTMyMWEyYTRfdG9XbnpDZWxFbDVCM2dzUk96NHNJYUlybWFPSzVkY3VfVG9rZW46THNsRWI1Wml1b01yaXd4WmpDa2NFTG1FbkRUXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;客户端请求在&lt;strong&gt;后端的处理过程&lt;/strong&gt;，非常重要。 &lt;strong&gt;核心 DispatcherServlet&lt;/strong&gt;，是 Spring 自己实现的 Servlet 容器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Web 容器开发的基本单元是 Servlet，请求 request 先到 servlet。&lt;/li&gt;
&lt;li&gt;spring 框架做参数解析，使用 handler mapping 根据 url 把请求转到对应的 controller。&lt;/li&gt;
&lt;li&gt;controller 处理请求和请求参数，把结果传给业务层&lt;/li&gt;
&lt;li&gt;业务层处理业务逻辑，业务层访问数据层；业务层把处理结果返回控制器&lt;/li&gt;
&lt;li&gt;控制器把结果返回给 servlet&lt;/li&gt;
&lt;li&gt;servlet 拿到了数据和逻辑视图名，找到视图解析器的第三方库&lt;/li&gt;
&lt;li&gt;视图解析器渲染视图&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关系型数据访问层开发的三种方法区别-相同点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关系型数据访问层开发的三种方法区别-相同点&#34;&gt;#&lt;/a&gt; 关系型数据访问层开发的三种方法区别、相同点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用 jdbcTemplate 简化 JDBC 访问（spring-boot-starter-jdbc）&lt;/li&gt;
&lt;li&gt;Spring Data JDBC（spring-boot-starter-data-jdbc）&lt;/li&gt;
&lt;li&gt;Spring Data JPA（spring-boot-starter-data-jpa）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据表生成：1、2 需要 scheme.sql 脚本，3 不需要（根据领域类自动生成）&lt;/li&gt;
&lt;li&gt;数据 model 的定义：
&lt;ol&gt;
&lt;li&gt;领域类注解：1 不需要为领域类加注解，2、3 要为领域类加注解（提供领域类和表结构的映射关系）
&lt;ol&gt;
&lt;li&gt;2：@Table， @Column，@Id&lt;/li&gt;
&lt;li&gt;3:  @Entity， @Id&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ID 字段的处理：1 需要手动获取数据库生成的 Id，2、3 不需要&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;数据库访问层接口 / 自定义查询：
&lt;ol&gt;
&lt;li&gt;1 需要自己实现接口；&lt;/li&gt;
&lt;li&gt;2、3 不需要，2、3 都继承自 CrudRepository 接口，且可以自定义查询：
&lt;ol&gt;
&lt;li&gt;2、3 都可以使用 @Querry 定义查询逻辑&lt;/li&gt;
&lt;li&gt;但 3 还可以使用基于方法名的&lt;strong&gt; DSL 自定义&lt;/strong&gt;查询，JPA 在自定义逻辑上更加灵活&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;TacoOrder&amp;gt; findByDeliveryZip(String deliveryZip);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;包路径：2、3 为领域类添加持久化的注解包路径不一样
&lt;ol&gt;
&lt;li&gt;JPA 中的规范注解都来自 &lt;code&gt;javax.persisitence.*&lt;/code&gt;  ，因为不是 Spring 自己实现&lt;/li&gt;
&lt;li&gt;@Table，对象会基于领域类的名称映射到数据库的表上&lt;/li&gt;
&lt;li&gt;@Id
&lt;ul&gt;
&lt;li&gt;有两个来自不同包的 @Id，注意区别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Column&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;jdbcTemplate&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Spring Data JDBC&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Spring Data JPA&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据表生成&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;需要 scheme.sql 脚本&lt;/td&gt;
&lt;td&gt;需要 scheme.sql 脚本&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据 model 的定义&lt;/td&gt;
&lt;td&gt;领域类注解（提供领域类和表结构的映射关系）&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ID 字段的处理&lt;/td&gt;
&lt;td&gt;手动生成&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据库访问层接口 / 自定义查询&lt;/td&gt;
&lt;td&gt;接口&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;td&gt;继承自 CrudRepository 接口&lt;/td&gt;
&lt;td&gt;继承自 CrudRepository 接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Querry 定义&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;基于方法名的 DSL 自定义查询&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包路径&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;JPA 中的规范注解都来自 &lt;code&gt;javax.persisitence.*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;给了spring框架开发人员还要做什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#给了spring框架开发人员还要做什么&#34;&gt;#&lt;/a&gt; 给了 Spring 框架，开发人员还要做什么？&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJkMjBiMjYyMDVlNjU1OGQ4NzkxNzhjODI2ZmYxMDBfRWZOU2FaWHRZUWU1OVN1a2xGenc0UTRFTWthWmF6TE1fVG9rZW46RjRiS2JYVkxXb0VPeWF4TThlZGM5RTBabmZjXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现接口
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;UserDetailsService&lt;/code&gt;  接口：给 Spring 框架提供用户详细信息。用户信息注册、存储和查询。
&lt;ul&gt;
&lt;li&gt;这里用到之前讲到数据访问层实现技术。&lt;/li&gt;
&lt;li&gt;和 spring security 解耦，只需要提供用户信息但不关心怎么实现。被 Spring Security 调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;实现密码加密 / 解密
&lt;ol&gt;
&lt;li&gt;PasswordEncoder 加密和解密的过程，springboot 提供了若干个&lt;/li&gt;
&lt;li&gt;Bean 对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;(optional) 实现登录页面
&lt;ol&gt;
&lt;li&gt;有默认页面，也可以自己实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/login&lt;/code&gt; , Spring 已经自动实现了对应的 &lt;code&gt;Controller&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;strong&gt; HTTPSecurity 进行权限设置&lt;/strong&gt;，分为两种：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SecurityFilterChain&lt;/code&gt;  实现，基于注入的 &lt;code&gt;httpSecurity&lt;/code&gt;  对象&lt;/li&gt;
&lt;li&gt;继承父类 &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; ，实现 &lt;code&gt;configure&lt;/code&gt;  方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PasswordEncoder：密码不能明文存储，需要加密后再存到数据库里&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要定义 &lt;code&gt;Bean&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;框架帮我们做了哪些事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现用户登录控制器（get、post）&lt;/li&gt;
&lt;li&gt;请求重定向到用户登录页面
&lt;ol&gt;
&lt;li&gt;eg. 用户未登录时，访问 URL，服务端重定向到登录页面&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通过 Filter 对设定的权限进行控制（自己只需要做权限的设定即可）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;用户信息存储&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用户信息存储&#34;&gt;#&lt;/a&gt; 用户信息存储&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内存用户存储
&lt;ul&gt;
&lt;li&gt;小型应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JDBC 用户存储
&lt;ul&gt;
&lt;li&gt;持久化数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LDAP（Lightweight Directory Access Protocol） 用户存储
&lt;ul&gt;
&lt;li&gt;轻量级目录访问协议，适用于大型企业，支持复杂查询和目录结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;属性来源&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#属性来源&#34;&gt;#&lt;/a&gt; 属性来源&lt;/h2&gt;
&lt;p&gt;不仅仅是 Spring Boot 需要的属性，也包含我们自己定义的属性。&lt;/p&gt;
&lt;p&gt;常见的是第一个和第四个，第二个和第三个偶尔用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置文件&lt;/strong&gt; &lt;code&gt;application.yml&lt;/code&gt; 、 &lt;code&gt;application.properties&lt;/code&gt; ，两个文件可以混用
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;server.port = 8090&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命令行参数&lt;/strong&gt; &lt;code&gt;commandLineArgs&lt;/code&gt; ，在程序中直接获取
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar -- server.port=8081&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JVM 系统参数&lt;/strong&gt; &lt;code&gt;-D&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;java -Dserver.port=8091 -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作系统环境变量&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;set SERVER_PORT=8082、java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;接口设计的关键要求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#接口设计的关键要求&#34;&gt;#&lt;/a&gt; 接口设计的关键要求&lt;/h2&gt;
&lt;p&gt;接口设计的关键要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用标准动词：GET\POST\PUT\DELETE，映射到 CRUD&lt;/li&gt;
&lt;li&gt;使用 URI 来传达意图，URI 用名词不用动词，表明单复数 tacos&lt;/li&gt;
&lt;li&gt;请求和响应使用 json，基本上大家都是用 json 标准，方便与第三方交流和解决问题&lt;/li&gt;
&lt;li&gt;HTTP 状态码表示结果：200、201（created）等&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;oauth2流程图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#oauth2流程图&#34;&gt;#&lt;/a&gt; OAuth2 流程图&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE5MDBhYTQwMjVmOWFiZWQ0ZGI1NTNlMGE4YjhlOGNfUEJmczBTT0RwZzFqSVo5NXpkRkh0TWM4bExMNWttM3NfVG9rZW46TG9ROWJuQnNYbzhRRjF4d0c0YmNEU2NYbndkXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;主体对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Authserver 授权服务器：授权、认证&lt;/li&gt;
&lt;li&gt;Authorization server 资源服务器&lt;/li&gt;
&lt;li&gt;Client application 客户端应用程序&lt;/li&gt;
&lt;li&gt;User 用户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;p&gt;其中使用&lt;strong&gt;授权码授权模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户使用第三方的应用程序，也就是客户端应用程序&lt;/li&gt;
&lt;li&gt;客户端发现用户未登录，把用户请求&lt;strong&gt;重定向&lt;/strong&gt;到授权服务器
&lt;ol&gt;
&lt;li&gt;授权服务器会维护合法的重定向地址，用于校验&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;授权服务器向用户索取用户名密码&lt;/li&gt;
&lt;li&gt;用户名密码匹配，则授权服务器请求用户授权&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;授权服务器给客户端程序返回 code&lt;/strong&gt;，重定向回到应用程序
&lt;ol&gt;
&lt;li&gt;code 需要经过浏览器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端应用程序用 code 向授权服务器索取 token&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;用 code 交换 token&lt;/li&gt;
&lt;li&gt;token 不过浏览器，在应用程序服务端和授权服务器之间处理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;客户端在请求头带上 token 调用资源服务器的 API&lt;/li&gt;
&lt;li&gt;资源服务器验证 token，返回结果
&lt;ol&gt;
&lt;li&gt;授权服务器会用&lt;strong&gt;私钥&lt;/strong&gt;给 token 签名，资源服务器用&lt;strong&gt;公钥&lt;/strong&gt;验证 token 是否合法&lt;/li&gt;
&lt;li&gt;第一次，资源服务器向授权服务器索取公钥，验证 Token 合法性&lt;/li&gt;
&lt;li&gt;Token 未过期时，不用再次索取公钥&lt;/li&gt;
&lt;li&gt;Token 过期时，才会重新索取公钥&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;客户端程序把结果返回给用户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;密码没有在浏览器来回传送，但是如果没有密码即使拿到 code 也没用&lt;/p&gt;
&lt;p&gt;用 code 向授权服务器换取 token 才需要密码&lt;/p&gt;
&lt;h2 id=&#34;rabbitmq组成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rabbitmq组成&#34;&gt;#&lt;/a&gt; RabbitMQ 组成&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NDg5MTZlMGVlYWI0OWI1ODJkMWEyOTI0MjJjOTA0YmZfaTE2Qk82UzduSloyTXc4N01iTUcwWmhPbEgxM0M4Ym1fVG9rZW46V2Q3b2JzV2hCb0FNdDF4V0E1VGNQZlNNblBoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConnectionFactory、Connection、Channel&lt;/li&gt;
&lt;li&gt;Exchange：
&lt;ul&gt;
&lt;li&gt;Default、Direct、Topic、Fanout、Headers、Dead letter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt;：exchange 根据 routing key 确定消息发往哪个队列
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JMS 里没有这个概念&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binding key&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reactive-programming反应式编程解决什么问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#reactive-programming反应式编程解决什么问题&#34;&gt;#&lt;/a&gt; Reactive Programming 反应式编程解决什么问题？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IO 密集型场景&lt;/li&gt;
&lt;li&gt;同步阻塞模型，阻塞线程多，CPU 利⽤率不⾼，性能下降 —— 轮询解决&lt;/li&gt;
&lt;li&gt;管理多线程，意味着更⾼的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java的stream和反应式流的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#java的stream和反应式流的区别&#34;&gt;#&lt;/a&gt; Java 的 Stream 和反应式流的区别&lt;/h2&gt;
&lt;p&gt;Java 的 stream 通常都是同步的，并且只能处理有限的数据集，本质上来说，它们只是使⽤函数来对集合进⾏迭代的⼀种⽅式&lt;/p&gt;
&lt;p&gt;JDK9 中的 Flow API 对应反应式流&lt;/p&gt;
&lt;h2 id=&#34;反应式流规范定义的4个接口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反应式流规范定义的4个接口&#34;&gt;#&lt;/a&gt; 反应式流规范定义的 4 个接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;org.reactivestrea&lt;/li&gt;
&lt;li&gt;ms.*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA0YzcwNjU1Mzc3ZDA2YmU4YjU4MDkyMWQyMjg3M2JfWlFtaGo2NTY4amRRbE41OXBaSU1CRjFTd29OTVBUbHpfVG9rZW46TkdwR2J0Q2dhbzhSZGR4WUREcGN6bHE1bkJnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Publisher：数据发布者
&lt;ul&gt;
&lt;li&gt;subscribe&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Subscriber：数据订阅者
&lt;ul&gt;
&lt;li&gt;onSubscribe 第一次建立连接时调用&lt;/li&gt;
&lt;li&gt;onNext&lt;/li&gt;
&lt;li&gt;onError&lt;/li&gt;
&lt;li&gt;onComplete&lt;/li&gt;
&lt;li&gt;消费者：如果⽣产者产⽣数据的速度⾮常快，消费者会来不及处理，⽤回压来调节，根据消费者的速度来发送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Processor：处理器，既是数据的消费者，也是数据的发布者&lt;/li&gt;
&lt;li&gt;Subscription：协调者，在 Publisher 和 Subscriber 之间传递消息
&lt;ul&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;cancel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个环节可能会在不同的线程⾥处理，处理过程是异步的。&lt;/p&gt;
&lt;p&gt;消费者驱动，消费者去请求发布者才会发布数据&lt;/p&gt;
&lt;h2 id=&#34;spring-integration集成流解决什么问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-integration集成流解决什么问题&#34;&gt;#&lt;/a&gt; Spring Integration 集成流解决什么问题&lt;/h2&gt;
&lt;p&gt;提供了一系列的组件和配置选项，用于在应用程序中实现消息传递和集成模式。&lt;/p&gt;
&lt;p&gt;解耦合、异步处理、轻量级集成&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJmNWE4MzA2MTdhNDc2YjQ1YTE5MTNhNTEyZTQ3NjZfYkRwQ1RJd0N0NUdobE8xYnd5NmRka1dxZ1N3blFMWTBfVG9rZW46RGFBbmJBcFYxb1pDVnd4a2R2WmNjaDBubldkXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFmZTYxMjhkZDdhMzczOTU3ZTU3MzU0ZjIzMmEwOTBfbDd3VWZPMml0UDNobHpzUFV5THBHN3VobkxJRHRERXVfVG9rZW46Tnh0VmJQc09Qb1AzSGV4aGQyNWN1UGtMbmpoXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;mapflatmap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mapflatmap&#34;&gt;#&lt;/a&gt; map/flatMap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;map：
&lt;ul&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;li&gt;返回具体值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flatMap&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;转换出来的&lt;strong&gt;返回结果还是一个流（Mono/Flux）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以&lt;strong&gt;并发处理&lt;/strong&gt;，指定用哪个并发模型处理
&lt;ul&gt;
&lt;li&gt;多个流并发处理结果合并成一个流，但结果顺序不可控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扁平化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发模型（Schedulers 方法）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;.immediate()&lt;/li&gt;
&lt;li&gt;.single()&lt;/li&gt;
&lt;li&gt;.newSingle()&lt;/li&gt;
&lt;li&gt;.elastic()&lt;/li&gt;
&lt;li&gt;.parallel()&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYyMDkyZjNkNTVkNjk3ZGQ4NTg2NDU4ZTI1ODdjNDlfR0dRNmlQOEdTaWZQT2ZWdjNLb0VsYnEyQlJuRzdNOFJfVG9rZW46QkoxNWJ5S0NWb2MyZUt4eU1KQWMwVzhubmUwXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker的三部分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker的三部分&#34;&gt;#&lt;/a&gt; docker 的三部分&lt;/h2&gt;
&lt;p&gt;容器：一个轻量化的虚拟机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪三部分？
&lt;ul&gt;
&lt;li&gt;docker engine：服务端，管理一系列资源的生命周期，包括容器 containers、images 和 volumns&lt;/li&gt;
&lt;li&gt;Client：一个命令行程序，和 docker daemon 交互&lt;/li&gt;
&lt;li&gt;Registry：镜像仓库，上传和下载镜像 images&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每一部分由哪些部分构成？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ1ODkxOWQ2YjFkZWRiMGQzMGM2YmI4MjQzNTRhZDJfY1FEamZkNzBMbXVZeld5Zk9oejBLSFFBMlF2VjJzNm9fVG9rZW46UUJRU2JJd2pVb1FqVDV4WTNRMmNsYjQ5bktmXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;容器与虚拟机的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器与虚拟机的区别&#34;&gt;#&lt;/a&gt; 容器与虚拟机的区别&lt;/h2&gt;
&lt;p&gt;容器是在 Linux 内核实现的轻量级资源隔离机制&lt;/p&gt;
&lt;p&gt;虚拟机是操作系统级别的资源隔离，容器本质上是进程级的资源隔离&lt;/p&gt;
&lt;h2 id=&#34;pod-container与node之间的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pod-container与node之间的关系&#34;&gt;#&lt;/a&gt; Pod container 与 node 之间的关系&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg2MTgzNTg3YzQxZTBmNzU1MmNmZWI4ZDJiYzU3ZWRfN3M2TEJaeFpQVjN5MHNHV3lNTExZNnVPVllxWkZjMHpfVG9rZW46Vzh6UWJuS0lIb0hoYm14Z0k3d2NRMmhPbmZmXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;spring-mvc与spring-webflux的共性与不同&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc与spring-webflux的共性与不同&#34;&gt;#&lt;/a&gt; Spring MVC 与 Spring WebFlux 的共性与不同&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不同
&lt;ul&gt;
&lt;li&gt;MVC：依赖多线程处理&lt;/li&gt;
&lt;li&gt;WebFlux：在事件轮询中处理请求
&lt;ul&gt;
&lt;li&gt;可以使用纯粹的函数式编程实现 Controller&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共性
&lt;ul&gt;
&lt;li&gt;WebFlux 也可以使用 Controller、RequestMapping 等注解
&lt;ul&gt;
&lt;li&gt;WebFlux 的参数和返回值可能是流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=N2VkNWZjNmQ2YWUyODUyNjM5ZTkyMWNhYTAxMWYwOGJfUkpWV29ud0F5NjV6SHBCYmFQNEJFTFh4TjJBQXVOSmdfVG9rZW46SWxkc2JLY2Jnb3J5RUt4MTZJOWNyNnc1bmtnXzE3MDUyOTMzMTM6MTcwNTI5NjkxM19WNA&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
