{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io",
    "items": [
        {
            "id": "https://quas-modo.github.io/2022/10/04/COA/Lecture0506-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/04/COA/Lecture0506-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "title": "Lecture0506-整数运算",
            "date_published": "2022-10-04T13:32:43.000Z",
            "content_html": "<p>整数的加减乘除计算的实现。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"整数运算\"><a class=\"anchor\" href=\"#整数运算\">#</a> 整数运算</h1>\n<h2 id=\"算术逻辑单元alu\"><a class=\"anchor\" href=\"#算术逻辑单元alu\">#</a> 算术逻辑单元 ALU</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004201226053.png\" alt=\"image-20221004201226053\" /></p>\n<p>寄存器存储数据、结果、flags</p>\n<p>控制器控制 ALU 操作和数据传入的信号</p>\n<h2 id=\"全加器\"><a class=\"anchor\" href=\"#全加器\">#</a> 全加器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004201329220.png\" alt=\"image-20221004201329220\" /></p>\n<p><strong>关注与或异或的符号</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004201426820.png\" alt=\"image-20221004201426820\" /></p>\n<p><strong>计算结果和进位</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004201536313.png\" alt=\"image-20221004201536313\" /></p>\n<p>F 可以理解为，是奇数个 1 的时候，结果为 1；是偶数个 1 的时候，结果为 0。</p>\n<p>进位则是，有两个 1 的时候即可进位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004202318557.png\" alt=\"image-20221004202318557\" /></p>\n<p>异或门只能有<strong>两个</strong>输入端，异或门的时延<strong>不一定为 3ty</strong>。</p>\n<p>在网上找了一些实现异或的方法，可以看出，时延可以是 2ty 也可以是 3ty，应该是由异或门实现的方式决定的。</p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log29.gif\" alt=\"logic equivalent\" /></p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log30.gif\" alt=\"implimentation using NAND\" /></p>\n<p>非门算不算时延？ <strong>非门算时延</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004202431041.png\" alt=\"image-20221004202431041\" /></p>\n<p>减少了一个与门，但是时延仍然是 6ty</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004202622094.png\" alt=\"image-20221004202622094\" /></p>\n<p>这里可以解释为，因为 X 和 Y 的或和异或仅在 X、Y 均为 1 时不同，但 X、Y 均为 1 时，前面的与为 1，并不影响结果，所以两个式子相等。</p>\n<h2 id=\"串行进位行波进位加法器\"><a class=\"anchor\" href=\"#串行进位行波进位加法器\">#</a> 串行进位（行波进位）加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004203257934.png\" alt=\"image-20221004203257934\" /></p>\n<p>公式来源于前面的全加法器，理解一样。</p>\n<p>需要等待 “进位输出信号”，所以缺点是延迟慢。</p>\n<h2 id=\"全先行进位加法器\"><a class=\"anchor\" href=\"#全先行进位加法器\">#</a> 全先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004203840078.png\" alt=\"image-20221004203840078\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004203851451.png\" alt=\"image-20221004203851451\" /></p>\n<p>不需要等待 n-1 位算完，就可以开始计算第 n 位，把能计算的先提前计算好。</p>\n<p>1ty：Gi 和 Pi 的计算，Gi 和 Pi 的计算可以同时进行，只需要 1ty</p>\n<p>2ty：计算 C 的值，因为需要先进行与操作，再进行或操作，所以需要 2ty，因为 Ci 只和 P\\G\\C0 的值有关，所以不需要等前一位的进位算好。</p>\n<p>3ty：Xi 和 Yi 的异或可在前三个时延做好，只需要再和 Ci-1 做异或即可算出 F。</p>\n<h2 id=\"部分先行进位加法器\"><a class=\"anchor\" href=\"#部分先行进位加法器\">#</a> 部分先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004205020973.png\" alt=\"image-20221004205020973\" /></p>\n<p>加法器延迟过于严重，但是全先行进位又难以实现，所以采用了两者的混合杂交。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004205033867.png\" alt=\"image-20221004205033867\" /></p>\n<p>3ty：第一个全先行加法器需要算出 G、P，耗时 1ty；然后需要算出所有的进位，耗时 2ty；与此同时，其他三个 CLA 也算好了自己的 G 和 P。</p>\n<p>2ty：第二个 CLA 收到 Cin 之后，需要 2ty 计算 Cout。</p>\n<p>2ty：同上，为第三个 CLA 的计算。</p>\n<p>5ty：2ty+3ty，第四个 CLA 计算 C 需要 2ty，然后再和 X、Y 进行异或操作，需要 3ty。在此之前，其余的 CLA 已经完成了异或计算。</p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004205052489.png\" alt=\"image-20221004205052489\" /></p>\n<p>溢出的情况只能是两个正的变成负的，或者两个负的变成正的。</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>C</th>\n<th>Fn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<p>判断是否溢出的 flag 就是在 Cn-1 和 Cn 上加一个异或器</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>Cn-1</th>\n<th>Cn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212422633.png\" alt=\"image-20221004212422633\" /></p>\n<p>减法就是在加法器上加一个选择器，sub 给一个信号</p>\n<h2 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212600089.png\" alt=\"image-20221004212600089\" /></p>\n<p>实际上，加法和移位可以合并，因为始终上升沿到来之前，各寄存器中的数据会被取出，因此不需要 2-3 个时钟周期，1 个时钟周期即可完成。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212637939.png\" alt=\"image-20221004212637939\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212647037.png\" alt=\"image-20221004212647037\" /></p>\n<h2 id=\"补码一位乘法布斯算法\"><a class=\"anchor\" href=\"#补码一位乘法布斯算法\">#</a> 补码一位乘法：布斯算法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212751668.png\" alt=\"image-20221004212751668\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212807919.png\" alt=\"image-20221004212807919\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212829253.png\" alt=\"image-20221004212829253\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212838655.png\" alt=\"image-20221004212838655\" /> 错误原因：补位负数补 1</p>\n<h2 id=\"乘法溢出\"><a class=\"anchor\" href=\"#乘法溢出\">#</a> 乘法溢出</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221004212915106.png\" alt=\"image-20221004212915106\" /></p>\n<p>带符号整数：因为乘法的补位是根据当前最高位计算的，如果有变化，则说明有溢出</p>\n<p>无符号整数：无符号整数应该没有 1 的出现</p>\n<p><strong>这里有些许的疑惑</strong></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-04-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture03 04-数据的机器级表表示",
            "date_published": "2022-09-22T23:41:11.000Z",
            "content_html": "<p>仅记录有用部分，课件详细内容在 ppt 上已经很清楚了。</p>\n<p>需要加强的地方：二进制转十进制，十进制转二进制，补码的模不懂，静默式和通知式，非规格化数不懂、精度保护中的舍入看不懂，大端小端</p>\n<p>好难…… 呜呜看不懂</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"第一次作业讲解\"><a class=\"anchor\" href=\"#第一次作业讲解\">#</a> 第一次作业讲解</h2>\n<p>作业 1：. 为什么速率的总和没有意义？</p>\n<p>作业 2：指令集结构不同的计算机，只比较 MIPS 是没有意义的，例如此题当中，A 的 MIPS 大，但是运行时间较长。</p>\n<p>作业 3：采用不同指令集、<strong>流水线</strong>和并行</p>\n<p>作业 4：MIPS 求和有意义吗？</p>\n<p>组织不可见，结构可见</p>\n<h1 id=\"lecture0304-数据的机器级表示\"><a class=\"anchor\" href=\"#lecture0304-数据的机器级表示\">#</a> lecture03/04 - 数据的机器级表示</h1>\n<p>参考紫书第 2 章 / 黑书第 9 章 计算机算数</p>\n<h2 id=\"课堂ppt结合黑书版本\"><a class=\"anchor\" href=\"#课堂ppt结合黑书版本\">#</a> 课堂 /ppt—— 结合黑书版本</h2>\n<h3 id=\"信息的二进制编码\"><a class=\"anchor\" href=\"#信息的二进制编码\">#</a> 信息的二进制编码</h3>\n<h3 id=\"整数的二进制表示\"><a class=\"anchor\" href=\"#整数的二进制表示\">#</a> 整数的二进制表示</h3>\n<h4 id=\"无符号整数\"><a class=\"anchor\" href=\"#无符号整数\">#</a> 无符号整数</h4>\n<h4 id=\"有符号整数\"><a class=\"anchor\" href=\"#有符号整数\">#</a> 有符号整数</h4>\n<h5 id=\"原码-符号幅值表示法\"><a class=\"anchor\" href=\"#原码-符号幅值表示法\">#</a> 原码 符号幅值表示法</h5>\n<p>符号位不同，数值位相同</p>\n<p>不同位长间的转换：符号位左移，空余的填补 0</p>\n<p>浮点数的尾数用原码定点小数表示</p>\n<p>零的表示不唯一，不利于程序员编程</p>\n<h5 id=\"反码\"><a class=\"anchor\" href=\"#反码\">#</a> 反码</h5>\n<p>符号位和数值位均取反</p>\n<h5 id=\"移码\"><a class=\"anchor\" href=\"#移码\">#</a> 移码</h5>\n<p>是一种有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbmVkX251bWJlcl9yZXByZXNlbnRhdGlvbg==\">符号数表示</span>的方法，其中有符号数 n 是由对应于<strong>无符号数 n + K</strong> 的位模式表示，K 是<em>偏置值</em>或<em>偏移量</em>。</p>\n<p>bias 通常取 2 的 n-1 次方或者 2 的 n-1 次方减 1<br />\n 当 bias 为 2 的 n-1 次方时，移码和补码仅第一位不同，0 的表示唯一<br />\n<strong>浮点数的阶用移码表示</strong>：当两个数都是负数的时候，移码更容易比较</p>\n<h5 id=\"补码\"><a class=\"anchor\" href=\"#补码\">#</a> 补码</h5>\n<p>计算机处理中，<strong>通常使用补码</strong><br />\n负数的数值部分 <strong>各位取反，末尾加 1</strong></p>\n<p>不同位长间的转换：符号位移到最左位，其余空出位用符号位的值替代</p>\n<p>加和减的统一：<br />\n一个负数的补码等于模减该负数的绝对值<br />\n对于一个确定的模，某数减去小于模的另一数，总可以加上另一数负数的补码来代替。</p>\n<p><strong>求真值的补码</strong></p>\n<p>全 0：0</p>\n<p>全 1：-1</p>\n<p>10000...：- 2 <sup>n-1</sup></p>\n<p><strong>求补码的真值</strong></p>\n<p>**X = - x<sub>n-1</sub> * 2 <sup>n-1</sup> + ... + x <sub>2</sub> * 2 <sup>1</sup>+ x <sub>1</sub>*2<sup>0</sup> **</p>\n<p><strong>若对负数的补码再取负，得到原来那个数</strong>【其中的特例是，-2<sup>n-1</sup> 在取负之后仍然为本身，因为范围内并没有 2<sup>n-1</sup> 与之相对应】</p>\n<h3 id=\"浮点数\"><a class=\"anchor\" href=\"#浮点数\">#</a> 浮点数</h3>\n<p>单精度 32 位（1+8+23）<strong>仍然表示 2<sup>32</sup> 个数</strong></p>\n<p>双精度 64 位（1+11+52）</p>\n<p>基底为 2（也存在基底为 16 的情况）—— 基数越大，范围越大，精度越低</p>\n<h4 id=\"表示方法\"><a class=\"anchor\" href=\"#表示方法\">#</a> 表示方法</h4>\n<p>S E M</p>\n<ol>\n<li>\n<p>符号位</p>\n</li>\n<li>\n<p>8 位移码表示阶码（指数） —— 范围为 - 126~127，全 0 和全 1 为特殊值</p>\n</li>\n<li>\n<p>23 位原码表示 24 位尾数，最高位总为 1</p>\n</li>\n</ol>\n<h4 id=\"表示的数\"><a class=\"anchor\" href=\"#表示的数\">#</a> 表示的数</h4>\n<p><strong>规格化数</strong>，关注上溢出和下溢出，</p>\n<p>下溢出部分用<strong>非格式化数</strong>表示，它的间距是等距的</p>\n<p>越靠近原点，数越密集；越远离原点，数越稀疏</p>\n<p><strong>静默式和通知式非数</strong> —— 静默式表示未定义的算数结果，通知式非数表示未初始化的值。</p>\n<h2 id=\"计算机组成与体系结构性能设计\"><a class=\"anchor\" href=\"#计算机组成与体系结构性能设计\">#</a> 计算机组成与体系结构：性能设计</h2>\n<h3 id=\"整数的加法与减法补码\"><a class=\"anchor\" href=\"#整数的加法与减法补码\">#</a> 整数的加法与减法（补码）</h3>\n<p>上溢规则</p>\n<p>减法规则 —— 减法，即加上减数的 2 的补</p>\n<p>在实际的操作中，有 OF 溢出位记录是否溢出</p>\n<h3 id=\"整数的乘法\"><a class=\"anchor\" href=\"#整数的乘法\">#</a> 整数的乘法</h3>\n<h4 id=\"无符号整数的乘法\"><a class=\"anchor\" href=\"#无符号整数的乘法\">#</a> 无符号整数的乘法</h4>\n<p>两个 n 为二进制整数的乘法可产生最大长度为 2n 位的积</p>\n<p>乘</p>\n<p>移位</p>\n<p>计数 - 1</p>\n<h4 id=\"有符号整数的乘法\"><a class=\"anchor\" href=\"#有符号整数的乘法\">#</a> 有符号整数的乘法</h4>\n<p>只要有一个是负数，原来的方法就不奏效</p>\n<ol>\n<li>\n<p>把被乘数和乘数都转变成正数再相乘，当两者初始的符号不相同时，结果取 2 的补</p>\n</li>\n<li>\n<p>布斯（Booth）算法</p>\n<p>分为 10 01 【00 11】三种情况讨论</p>\n<p>运用公式，   <strong>2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup></strong></p>\n<p>很巧妙，优雅，实在是太优雅了！</p>\n</li>\n</ol>\n<h3 id=\"整数的除法\"><a class=\"anchor\" href=\"#整数的除法\">#</a> 整数的除法</h3>\n<p>搞来搞去，也很优雅</p>\n<h3 id=\"浮点数加法和减法\"><a class=\"anchor\" href=\"#浮点数加法和减法\">#</a> 浮点数加法和减法</h3>\n<ol>\n<li>检查 0</li>\n<li>对齐有效值</li>\n<li>加法</li>\n<li>规格化</li>\n</ol>\n<p>注意时时检查是否有效值为 0，以及是否溢出</p>\n<p>若两个数的阶值差别非常大，则较小的数丢失</p>\n<h3 id=\"浮点数乘法和除法\"><a class=\"anchor\" href=\"#浮点数乘法和除法\">#</a> 浮点数乘法和除法</h3>\n<p>由于阶值是移码的形式，相乘的时候，两个阶值的和要减去一个偏移量，相除的时候，两个阶值的差要加上一个偏移量</p>\n<h4 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h4>\n<ol>\n<li>\n<p>保护位</p>\n<p>对齐的时候会导致丢失，在末尾增加保护位，可以扩展有效值的右端</p>\n</li>\n<li>\n<p>舍入（不懂）</p>\n</li>\n</ol>\n<h2 id=\"计算机组成与系统结构习题解答和教学指导\"><a class=\"anchor\" href=\"#计算机组成与系统结构习题解答和教学指导\">#</a> 计算机组成与系统结构习题解答和教学指导</h2>\n<h3 id=\"数据的表示\"><a class=\"anchor\" href=\"#数据的表示\">#</a> 数据的表示</h3>\n<ul>\n<li>\n<p>数值数据 —— 二进制、十进制（BCD binary coded decimal）</p>\n</li>\n<li>\n<p>非数值数据</p>\n</li>\n</ul>\n<h3 id=\"数据的宽度\"><a class=\"anchor\" href=\"#数据的宽度\">#</a> 数据的宽度</h3>\n<p>数据容量和宽度</p>\n<p>比特</p>\n<p>字节</p>\n<p>字（2 个 / 4 个 / 8 个 / 16 个字节）</p>\n<h3 id=\"数据的排列\"><a class=\"anchor\" href=\"#数据的排列\">#</a> 数据的排列</h3>\n<ul>\n<li>大端排列 —— 最低有效字节 LSB 存放在大地址单元中，MSB 所在地址为数据的地址</li>\n<li>小端排列 —— 最低有效字节 LSB 存放在小地址单元中，LSB 所在地址为数据的地址</li>\n</ul>\n<h3 id=\"数据校验方式\"><a class=\"anchor\" href=\"#数据校验方式\">#</a> 数据校验方式</h3>\n<ul>\n<li>\n<p>奇偶校验</p>\n</li>\n<li>\n<p>海明校验</p>\n</li>\n<li>\n<p>循环冗余码校验</p>\n</li>\n</ul>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "Lecture02-计算机体系结构的问题及解决方案",
            "date_published": "2022-09-15T10:01:24.000Z",
            "content_html": "<p>讲述了六个计算机体系结构的问题以及解决方案<br />\n<span id=\"more\"></span></p>\n<h2 id=\"冯诺依曼最重要的思想存储程序\"><a class=\"anchor\" href=\"#冯诺依曼最重要的思想存储程序\">#</a> 冯诺依曼最重要的思想 —— 存储程序</h2>\n<p>任何要计算机完成的工作都要先被编写成程序，然后将<strong>程序和原始数据送入主存</strong>并启动执行。一旦程序被启动，计算机应能在不需要操作人员干预下，自动完成逐条取出指令和执行指令的任务。</p>\n<p>区分中央处理单元（CPU）和处理器。</p>\n<p>CPU 的制作工艺逐渐在提高，几乎不变的是 CPU 的大小，一直在增加的是晶体管的数量。</p>\n<p>目前，苹果 M2 以及可以集成 200 亿的晶体管。</p>\n<h2 id=\"问题与解决思路\"><a class=\"anchor\" href=\"#问题与解决思路\">#</a> 问题与解决思路</h2>\n<h3 id=\"可以通过无限增加cpu的大小来增加性能嘛\"><a class=\"anchor\" href=\"#可以通过无限增加cpu的大小来增加性能嘛\">#</a> 可以通过无限增加 CPU 的大小来增加性能嘛？</h3>\n<p>不可以，面积越大，意味着<strong>互联延迟</strong>越大。一个时钟周期需要大于最长互联延迟。存在物理极限。</p>\n<h3 id=\"问题1cpu的频率不能无限提高\"><a class=\"anchor\" href=\"#问题1cpu的频率不能无限提高\">#</a> 问题 1：CPU 的频率不能无限提高</h3>\n<p>MOS 管开关、脉冲通过门电路需要时间</p>\n<p>为了信号同步，每个脉冲信号需要持续一定的时间</p>\n<p>面积大，连线延迟大；</p>\n<p>频率越高，开关损耗高，CPU 耗电和散热提高；</p>\n<h3 id=\"解决1改变cpu芯片结构\"><a class=\"anchor\" href=\"#解决1改变cpu芯片结构\">#</a> 解决 1：改变 CPU 芯片结构</h3>\n<ol>\n<li>\n<p>采用各种技术，对芯片体系结构进行优化：指令流水线、每周期多条指令、cache、更长流水线和双速算术</p>\n</li>\n<li>\n<p>领域定制，如面向人工智能的芯片</p>\n</li>\n</ol>\n<h3 id=\"问题2内存墙的存在-memory-wall\"><a class=\"anchor\" href=\"#问题2内存墙的存在-memory-wall\">#</a> 问题 2：内存墙的存在 memory wall</h3>\n<p>主存和 CPU 之间传输数据的速度跟不上 CPU 的速度</p>\n<h3 id=\"解决2采用高速缓存cache\"><a class=\"anchor\" href=\"#解决2采用高速缓存cache\">#</a> 解决 2：采用高速缓存（cache）</h3>\n<ol>\n<li>添加一级或多级缓存以减少存储器访问频率并提高数据传输速率</li>\n<li>增大总线的数据宽度，来增加每次所能取出的位数</li>\n</ol>\n<h3 id=\"问题3cpu等待io传输数据\"><a class=\"anchor\" href=\"#问题3cpu等待io传输数据\">#</a> 问题 3：CPU 等待 I/O 传输数据</h3>\n<p>CPU 在等待 I/O 设备时保持空闲</p>\n<h3 id=\"解决3中断\"><a class=\"anchor\" href=\"#解决3中断\">#</a> 解决 3：中断</h3>\n<p>其他模块（例如 IO）可以中断正常处理顺序的机制</p>\n<p>中断周期加入指令周期中</p>\n<p>多重中断：顺序中断处理、嵌套中断处理</p>\n<h3 id=\"问题4兼顾存储容量-速度和成本\"><a class=\"anchor\" href=\"#问题4兼顾存储容量-速度和成本\">#</a> 问题 4：兼顾存储容量、速度和成本</h3>\n<p>约束</p>\n<ul>\n<li>容量：越大越好</li>\n<li>速度：跟上处理器</li>\n<li>成本：相较于其他组件合理</li>\n</ul>\n<p>约束之间的关系</p>\n<p>​\t更短的访问时间，更高的每比特成本</p>\n<h3 id=\"解决4层次式存储结构\"><a class=\"anchor\" href=\"#解决4层次式存储结构\">#</a> 解决 4：层次式存储结构</h3>\n<p>需求</p>\n<ul>\n<li>大容量数据存储</li>\n<li>高速性能</li>\n</ul>\n<p>解决方案</p>\n<ul>\n<li>使用存储器层次结构而不是依赖单个存储器组件</li>\n</ul>\n<p><strong>寄存器 ——cache—— 主存 —— 磁盘 —— 磁带</strong></p>\n<p>存储量越来越大，速度越来越慢，离 CPU 越来越远</p>\n<h3 id=\"问题5io设备传输速率差异大\"><a class=\"anchor\" href=\"#问题5io设备传输速率差异大\">#</a> 问题 5：I/O 设备传输速率差异大</h3>\n<p>I/O 性能跟不上 CPU 速度的提升</p>\n<h3 id=\"解决5采用缓冲区和改进io操作技术\"><a class=\"anchor\" href=\"#解决5采用缓冲区和改进io操作技术\">#</a> 解决 5：采用缓冲区和改进 I/O 操作技术</h3>\n<p>设立缓存区</p>\n<h3 id=\"问题6计算机部件互连复杂\"><a class=\"anchor\" href=\"#问题6计算机部件互连复杂\">#</a> 问题 6：计算机部件互连复杂</h3>\n<h3 id=\"解决6采用总线\"><a class=\"anchor\" href=\"#解决6采用总线\">#</a> 解决 6：采用总线</h3>\n<h4 id=\"总线\"><a class=\"anchor\" href=\"#总线\">#</a> 总线</h4>\n<p>目前，对通用计算机而言，各种点对点互连结构逐渐取代总线互连的方式。但是总线结构依然普遍用于嵌入式系统。</p>\n<h5 id=\"共享\"><a class=\"anchor\" href=\"#共享\">#</a> 共享</h5>\n<p>所有部件都通过总线传递数据</p>\n<h5 id=\"分时\"><a class=\"anchor\" href=\"#分时\">#</a> 分时</h5>\n<p>只有一个部件能够传输数据</p>\n<h5 id=\"功能组\"><a class=\"anchor\" href=\"#功能组\">#</a> 功能组</h5>\n<p><strong>控制线</strong> —— 控制对数据线路与地址线路的访问和使用，控制信号传递<strong>命令和定时信息</strong>。</p>\n<p><strong>地址线</strong> —— 指定数据总线上数据的源或目的，地址总线的宽度决定了系统可能的<strong>最大内存容量</strong></p>\n<p><strong>数据线</strong> —— 为系统模块之间的数据传输提供路径，一般而言，线路的条数决定了<strong>一次能传输的位数</strong>，数据总线的宽度是决定系统整体性能的一个关键因素</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "Lecture01-计算机系统概述",
            "date_published": "2022-09-08T12:30:32.000Z",
            "content_html": "<p>第一讲，以及对于书籍的第一章重点知识点整理</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"课程随笔\"><a class=\"anchor\" href=\"#课程随笔\">#</a> 课程随笔</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<p><strong>通用 电子 数字 计算机</strong></p>\n<p>通用</p>\n<p>电子</p>\n<p>数字</p>\n<h3 id=\"组织与结构\"><a class=\"anchor\" href=\"#组织与结构\">#</a> 组织与结构</h3>\n<ol>\n<li>结构 (对于程序员是可见的)\n<ul>\n<li>一个提供乘法算法的计算机和另一个不提供乘法算法的计算机之间的区别</li>\n<li>包括：指令集、各类数据类型的大小</li>\n</ul>\n</li>\n<li>组织 (对于程序员是不可见的)\n<ul>\n<li>一个用乘法器完成乘法的计算机和一个用加法器通过算法完成乘法的计算机之间的不同。</li>\n<li>包括：控制信号、存储技术</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"计算机发展历史\"><a class=\"anchor\" href=\"#计算机发展历史\">#</a> 计算机发展历史</h2>\n<p>真空管</p>\n<p>晶体管</p>\n<p>集成电路（scale 越来越大，SSI-&gt;MSI-&gt;LSI-&gt;VLSI-&gt;ULSI）</p>\n<p>摩尔定律（集成电路芯片上集成的晶体管数将番一番，速度将提高一倍，而价格将降低一半）</p>\n<h2 id=\"冯诺依曼结构的实现与演变\"><a class=\"anchor\" href=\"#冯诺依曼结构的实现与演变\">#</a> 冯诺依曼结构的实现与演变</h2>\n<h3 id=\"cpu-北桥-南桥\"><a class=\"anchor\" href=\"#cpu-北桥-南桥\">#</a> CPU + 北桥 + 南桥</h3>\n<p>芯片近北桥，远离南桥。</p>\n<h4 id=\"南桥\"><a class=\"anchor\" href=\"#南桥\">#</a> 南桥</h4>\n<p>南桥（英语：Southbridge）是基于个人计算机主板芯片组架构中的其中一枚芯片。南桥设计用来处理<strong>低速信号</strong>，通过北桥与中央处理器联系。<br />\n南桥芯片负责 I/O 总线之间的通信，如 PCI 总线、USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等。<br />\nPCI、SATA、IDE、USB。</p>\n<h4 id=\"北桥\"><a class=\"anchor\" href=\"#北桥\">#</a> 北桥</h4>\n<p>北桥设计用来处理<strong>高速信号</strong>，通常处理中央处理器、存储器、PCI Express 显卡（早年是 AGP 显卡）、高速 PCI Express X16/X8 的端口，还有与南桥之间的通信。<br />\n芯片组（chipset）的名称就是以北桥芯片的名称来命名的。<br />\n北桥被用来处理高速信号，通常处理 CPU（处理器），RAM（内存），AGP 端口或 PCI Express, 和南桥芯片之间的通信。<br />\nPCIE/AGP、Memory、CPU。</p>\n<h3 id=\"cpu-pch集成显卡-显示部件\"><a class=\"anchor\" href=\"#cpu-pch集成显卡-显示部件\">#</a> CPU + PCH（集成显卡 - 显示部件）</h3>\n<p>PCH 全称为 Platform Controller Hub，是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9pbnRlbCVFNSU4NSVBQyVFNSU4RiVCOA==\"> intel 公司</span>的集成南桥。</p>\n<p>北桥中的内存控制器和 PCIe 控制器都集成到了 CPU 内部，相当于整个北桥芯片都集成到了 CPU 内部，主板上只剩下南桥。所以 PCH 可以理解成南桥。目前 Intel 的有些 SOC 就是连 PCH 也集成到了 CPU 内部，比如：Intel Xeon D 系列.</p>\n<h2 id=\"计算机性能\"><a class=\"anchor\" href=\"#计算机性能\">#</a> 计算机性能</h2>\n<h3 id=\"cpu性能\"><a class=\"anchor\" href=\"#cpu性能\">#</a> CPU 性能</h3>\n<p>时钟频率 / 时钟周期</p>\n<p>CPI</p>\n<p>MIPS（每秒百万条指令）</p>\n<p>MRLOPS（每秒百万条浮点操作）</p>\n<p>基准程序</p>\n<h3 id=\"性能设计的基本原则\"><a class=\"anchor\" href=\"#性能设计的基本原则\">#</a> 性能设计的基本原则</h3>\n<ul>\n<li>\n<p>大概率事件优先原则</p>\n</li>\n<li>\n<p>阿姆代尔定律 Amdahl 定律</p>\n<p>技术或设计的某一部分的加速不会导致性能产生相应的改进。性能的提高是有限度的。</p>\n</li>\n<li>\n<p>Little 定律</p>\n</li>\n</ul>\n<h1 id=\"对应书籍整理-计算机系统概述\"><a class=\"anchor\" href=\"#对应书籍整理-计算机系统概述\">#</a> 对应书籍整理 - 计算机系统概述</h1>\n<h2 id=\"计算机结构\"><a class=\"anchor\" href=\"#计算机结构\">#</a> 计算机结构</h2>\n<h3 id=\"硬件\"><a class=\"anchor\" href=\"#硬件\">#</a> 硬件</h3>\n<ol>\n<li>\n<p>CPU</p>\n<ul>\n<li>运算器 —— 各种算数逻辑运算</li>\n<li>控制器 —— 对指令译码并送出操作控制信号</li>\n</ul>\n</li>\n<li>\n<p>存储器 —— 存放指令和数据</p>\n<p>包括 ROM 芯片和 RAM 芯片。</p>\n<ul>\n<li>\n<p>内存储器</p>\n<ul>\n<li>主存</li>\n<li>高速缓存（cache）</li>\n</ul>\n</li>\n<li>\n<p>外存储器</p>\n<p>磁盘、磁带存储器、光盘存储器等</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I/O 设备 —— 计算机和用户之间的信息交换</p>\n</li>\n</ol>\n<h3 id=\"软件\"><a class=\"anchor\" href=\"#软件\">#</a> 软件</h3>\n<ol>\n<li>系统软件 —— 介于计算机硬件和应用软件之间的各种软件\n<ul>\n<li>操作系统软件</li>\n<li>语言处理系统</li>\n<li>数据库管理系统</li>\n<li>各类实用程序</li>\n</ul>\n</li>\n<li>应用软件\n<ul>\n<li>办公自动化软件</li>\n<li>互联网应用软件</li>\n<li>多媒体处理软件</li>\n<li>股票分析软件</li>\n<li>游戏软件</li>\n<li>管理信息系统</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"程序开发和执行过程\"><a class=\"anchor\" href=\"#程序开发和执行过程\">#</a> 程序开发和执行过程</h3>\n<ol>\n<li>高级语言、低级语言（汇编语言）-&gt; 机器语言</li>\n</ol>\n<p>​\t\t其中，汇编语言和机器语言程序员必须对机器的结构和指令系统等细节非常清楚。</p>\n<ol start=\"2\">\n<li>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>对应计算机用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用程序</td>\n<td>最终用户</td>\n</tr>\n<tr>\n<td>高级语言虚拟机</td>\n<td>高级语言程序员或者应用程序员</td>\n</tr>\n<tr>\n<td>汇编语言虚拟机</td>\n<td>汇编语言程序员</td>\n</tr>\n<tr>\n<td>操作系统虚拟机</td>\n<td>系统管理员</td>\n</tr>\n<tr>\n<td>机器语言虚拟机</td>\n<td>机器语言程序员</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>源程序</strong>通过<strong>编译程序和汇编程序</strong>得到<strong>目标程序</strong></p>\n</li>\n<li>\n<p>编译程序 vs 解释程序（编译程序生成机器码，解释程序生成后立即执行）</p>\n</li>\n</ol>\n<h3 id=\"cpu性能-2\"><a class=\"anchor\" href=\"#cpu性能-2\">#</a> CPU 性能</h3>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        }
    ]
}