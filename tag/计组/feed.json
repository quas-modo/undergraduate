{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io",
    "items": [
        {
            "id": "https://quas-modo.github.io/2022/11/21/COA/Lecture11-RAID/",
            "url": "https://quas-modo.github.io/2022/11/21/COA/Lecture11-RAID/",
            "title": "Lecture11-RAID",
            "date_published": "2022-11-21T06:06:58.000Z",
            "content_html": "<p>RAID0-6<br />\n 条带、镜像、并行存取（海明码、位交错奇偶校验）、独立存取（块交错奇偶检验、块级分布式奇偶检验、双冗余度）</p>\n<p>并行存取的大数据传输率高，独立存取的 IO 请求快。</p>\n<h1 id=\"lecture11-raid\"><a class=\"anchor\" href=\"#lecture11-raid\">#</a> Lecture11-RAID</h1>\n<p>区分高数据传输率和高速 IO 请求</p>\n<h2 id=\"raid冗余磁盘阵列简介redundant-arrays-of-independent-disks\"><a class=\"anchor\" href=\"#raid冗余磁盘阵列简介redundant-arrays-of-independent-disks\">#</a> RAID 冗余磁盘阵列简介 ——Redundant Arrays of Independent Disks</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161456782.png\" alt=\"image-20221117161456782\" /></p>\n<p>Redundant 冗余 —— 进行错误恢复以提高系统可靠性</p>\n<h2 id=\"raid分类\"><a class=\"anchor\" href=\"#raid分类\">#</a> RAID 分类</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161543752.png\" alt=\"image-20221117161543752\" /></p>\n<p>0-6 都是条带式的</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163203515.png\" alt=\"image-20221117163203515\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163224833.png\" alt=\"image-20221117163224833\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163240540.png\" alt=\"image-20221117163240540\" /></p>\n<h3 id=\"raid0-不是raid成员\"><a class=\"anchor\" href=\"#raid0-不是raid成员\">#</a> RAID0 - 不是 RAID 成员</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161726563.png\" alt=\"image-20221117161726563\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221121125725716.png\" alt=\"image-20221121125725716\" /></p>\n<p>如果单个 IO 请求有多个逻辑相邻的条带组成，则多达对 n 个条带的请求可以并行处理，这样大大地减少了 IO 传输时间。</p>\n<h3 id=\"raid1-镜像\"><a class=\"anchor\" href=\"#raid1-镜像\">#</a> RAID1 - 镜像</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161806501.png\" alt=\"image-20221117161806501\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161823895.png\" alt=\"image-20221117161823895\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161835837.png\" alt=\"image-20221117161835837\" /></p>\n<p>大批读请求，速度较快；写请求，与 RAID0 类似。</p>\n<h3 id=\"raid01-vs-raid10\"><a class=\"anchor\" href=\"#raid01-vs-raid10\">#</a> RAID01 VS RAID10</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161936601.png\" alt=\"image-20221117161936601\" /></p>\n<h4 id=\"如果disk-0和disk-3坏了会怎么样\"><a class=\"anchor\" href=\"#如果disk-0和disk-3坏了会怎么样\">#</a> 如果 Disk 0 和 Disk 3 坏了会怎么样？</h4>\n<ul>\n<li>\n<p>对于 RAID01 来说</p>\n<p>Disk1 损坏，左边的 RAID 0 报废；Disk3 损坏，右边的 RAID 0 报废，整体的 RAID 1 报废</p>\n</li>\n<li>\n<p>对于 RAID10 来说</p>\n<p>Disk1 损坏，左边的 RAID 1 仍能够使用；Disk3 损坏，右边的 RAID 1 仍能够使用，整体的 RAID1 仍能够使用</p>\n</li>\n</ul>\n<p>​\t对于同样的出错，RAID10 仍能够正常运行，但是 RAID1 无法使用，所以 RAID10<strong> 容错率更高</strong></p>\n<h3 id=\"raid2-并行存取\"><a class=\"anchor\" href=\"#raid2-并行存取\">#</a> RAID2 - 并行存取</h3>\n<p>并行存取 —— 所有磁盘成员都参与每个 IO 请求的执行，各个驱动器的轴是<strong>同步旋转</strong>的。</p>\n<p>RAID2 和 RAID3 的<strong>条带非常小</strong>，经常小到一个字节或一个字。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117162002788.png\" alt=\"image-20221117162002788\" /></p>\n<p>读写时，都需要进行校验，读操作要访问所有磁盘，写操作要访问所有数据盘和校验盘。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117162035002.png\" alt=\"image-20221117162035002\" /></p>\n<p>需要时间开销处理海明码</p>\n<h3 id=\"raid3-并行存取\"><a class=\"anchor\" href=\"#raid3-并行存取\">#</a> RAID3 - 并行存取</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117162051620.png\" alt=\"image-20221117162051620\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163754445.png\" alt=\"image-20221117163754445\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163718019.png\" alt=\"image-20221117163718019\" /></p>\n<p>并行存取</p>\n<p>四个盘同时读写</p>\n<p>数据传输率 —— 任何 IO 请求将包含所有数据盘的并行数据传送，对于大量传送，性能改善特别明显。</p>\n<p>面对多个事务 —— 但是一次只能执行一个 IO 请求，在面向事务的环境中，性能将受损。</p>\n<h3 id=\"raid4-独立存取\"><a class=\"anchor\" href=\"#raid4-独立存取\">#</a> RAID4 - 独立存取</h3>\n<p>独立存取阵列更适合与需要高速 IO 请求的应用，而相对较少用于需要高数据传输率的场合。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163553896.png\" alt=\"image-20221117163553896\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163604760.png\" alt=\"image-20221117163604760\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117164749605.png\" alt=\"image-20221117164749605\" /></p>\n<p>独立存取，每个磁盘的操作都是独立的。</p>\n<p>写损失 —— 既要修改数据盘，也要修改校验盘。</p>\n<p>一次写入 包括<strong>两读两写</strong> —— 两次读操作（数据盘、校验盘）、两次写操作（数据盘、校验盘）</p>\n<h3 id=\"raid5-独立存取\"><a class=\"anchor\" href=\"#raid5-独立存取\">#</a> RAID5 - 独立存取</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163643553.png\" alt=\"image-20221117163643553\" /></p>\n<p>避免潜在的 IO 瓶颈问题 —— 校验条带分开了可以同时读取 (</p>\n<p>读没有影响，写受到限制（还是两读两写</p>\n<h3 id=\"raid50\"><a class=\"anchor\" href=\"#raid50\">#</a> RAID50</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165428182.png\" alt=\"image-20221117165428182\" /></p>\n<h3 id=\"raid6-独立存取-两种不同的奇偶校验码\"><a class=\"anchor\" href=\"#raid6-独立存取-两种不同的奇偶校验码\">#</a> RAID6 - 独立存取 - 两种不同的奇偶校验码</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165615475.png\" alt=\"image-20221117165615475\" /></p>\n<h2 id=\"raid比较\"><a class=\"anchor\" href=\"#raid比较\">#</a> RAID 比较</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165842161.png\" alt=\"image-20221117165842161\" /></p>\n<p>基本需求 —— 快、可用性</p>\n<p>0 和 1 没有达到兼顾</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165949394.png\" alt=\"image-20221117165949394\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117170009169.png\" alt=\"image-20221117170009169\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117170031768.png\" alt=\"image-20221117170031768\" /></p>\n<p>一些 callback</p>\n<p>3 和 4 的区别在于，是不是一起转的</p>\n<p>5 和 6 各有优劣</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/15/COA/Lecture10-%E6%A3%80%E9%94%99%E4%B8%8E%E7%BA%A0%E9%94%99/",
            "url": "https://quas-modo.github.io/2022/11/15/COA/Lecture10-%E6%A3%80%E9%94%99%E4%B8%8E%E7%BA%A0%E9%94%99/",
            "title": "Lecture10-检错与纠错",
            "date_published": "2022-11-15T14:18:59.000Z",
            "content_html": "<p>奇偶检验、海明码检验、循环冗余检验 CRC</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture10-校验码\"><a class=\"anchor\" href=\"#lecture10-校验码\">#</a> Lecture10 - 校验码</h1>\n<h2 id=\"差错\"><a class=\"anchor\" href=\"#差错\">#</a> 差错</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110172321805.png\" alt=\"image-20221110172321805\" /></p>\n<h2 id=\"纠错\"><a class=\"anchor\" href=\"#纠错\">#</a> 纠错</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110173954538.png\" alt=\"image-20221110173954538\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110174007085.png\" alt=\"image-20221110174007085\" /></p>\n<h3 id=\"奇偶校验码\"><a class=\"anchor\" href=\"#奇偶校验码\">#</a> 奇偶校验码</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110174244153.png\" alt=\"image-20221110174244153\" /></p>\n<p>奇校验和偶校验的代价和应用场景不同</p>\n<p>偶校验位的产生直接对待发送的数据依次做异或运算就可以得到，而产生奇校验位还要在偶校验电路的输出取非，相对而言，产生<strong>奇校验位的代价高</strong>，速度也相对慢（慢一个逻辑门的时延）</p>\n<p>如果被传输的数据为全 0，此时采用奇校验时，接收端至少会收到 1 个 1，很容易<strong>判断确实有传送发生</strong>；如果采用偶校验，此时收发双方都是 0，不容易判断是否有信号传来。而对于异步传输，因为有停止位的缘故，采用偶校验，接收方也至少能收到 1 个 1，当然，此时采用奇校验也是可以的；</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110175031448.png\" alt=\"image-20221110175031448\" /></p>\n<h3 id=\"汉明码海明码hamming-code\"><a class=\"anchor\" href=\"#汉明码海明码hamming-code\">#</a> 汉明码 / 海明码 Hamming code</h3>\n<h4 id=\"基本思想和处理过程\"><a class=\"anchor\" href=\"#基本思想和处理过程\">#</a> 基本思想和处理过程</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110175242990.png\" alt=\"image-20221110175242990\" /></p>\n<p>C D 通过传输得到 C‘ D’</p>\n<p>在接收端，用 D‘得到 C''，和 C’异或，生成故障字。</p>\n<h4 id=\"校验码长度\"><a class=\"anchor\" href=\"#校验码长度\">#</a> 校验码长度</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110175746481.png\" alt=\"image-20221110175746481\" /></p>\n<p>校验码要能够 cover 数据位一位出错、校验位一位出错和没有差错的情况</p>\n<h4 id=\"故障字的作用\"><a class=\"anchor\" href=\"#故障字的作用\">#</a> 故障字的作用</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163421156.png\" alt=\"image-20221115163421156\" /></p>\n<h4 id=\"数据位的划分\"><a class=\"anchor\" href=\"#数据位的划分\">#</a> 数据位的划分</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163637665.png\" alt=\"image-20221115163637665\" /></p>\n<p>规定 C1-C4 所对应的情况。再排好 D1-D8 的位置。</p>\n<p>例如，1100 对应 C4 和 C3，则就在 C3 和 C4 中取异或。</p>\n<h4 id=\"位安排\"><a class=\"anchor\" href=\"#位安排\">#</a> 位安排</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163906975.png\" alt=\"image-20221115163906975\" /></p>\n<h4 id=\"实例\"><a class=\"anchor\" href=\"#实例\">#</a> 实例</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164310763.png\" alt=\"image-20221115164310763\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164322978.png\" alt=\"image-20221115164322978\" /></p>\n<p>0110  <strong>0</strong>101  <strong>0</strong>0<strong>11</strong></p>\n<p>0111  <strong>0</strong>101  <strong>0</strong>0<strong>11</strong></p>\n<p>0110  <strong>1</strong>101  <strong>0</strong>0<strong>11</strong></p>\n<h3 id=\"码距和纠错理论\"><a class=\"anchor\" href=\"#码距和纠错理论\">#</a> 码距和纠错理论</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163224140.png\" alt=\"image-20221115163224140\" /></p>\n<p><strong>合法编码</strong>是正确的。</p>\n<p><strong>纠错理论</strong>： <code>L - 1 = D + C, D &gt;= C</code></p>\n<p>奇偶校验：</p>\n<ul>\n<li>如果 D 一位发生变化，C 就发生了变化。如果两位发生了变化，则码距已经超过了 2。奇偶校验不具备检测两位错误的能力。</li>\n<li>D 是 1 位，C 是 0 位。</li>\n</ul>\n<p>汉明码校验：</p>\n<ul>\n<li>D 是 1 位，C 也是 1 位</li>\n<li>可以 2 位检测、0 位纠错吗？不可以，用海明码检测基于 “只有一位出现错误” 的假设。比如，如果 1、2 位出现了差错，那么可以对应与 D3 的情况。</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115220739021.png\" alt=\"image-20221115220739021\" /></p>\n<h3 id=\"补充阅读sec-d-ec\"><a class=\"anchor\" href=\"#补充阅读sec-d-ec\">#</a> 补充阅读：SEC-D-EC</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164644225.png\" alt=\"image-20221115164644225\" /></p>\n<p>在海明码中，除了 D4 和 D7 之外，都会影响两位的校验码。</p>\n<p>L - 1 = D + C</p>\n<p>L - 1=  2 + 1</p>\n<p>为了实现两位的检错，需要将码距增加到 4【即添加一个额外的校验位，让数据对应的校验码位数增加到 3 位】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115165141136.png\" alt=\"image-20221115165141136\" /></p>\n<p>D1 和 D2 有问题，C3 和 D5 有问题是同一种显示。</p>\n<p>如何计算单纠错 / 单检错需要的校验位？ 2<sup>k</sup> &gt;= M + K + 1</p>\n<p>如何计算单纠错 / 双检错需要的校验位？2<sup>k-1</sup> &gt;= M + K + 1</p>\n<p>如何计算双纠错 / 双检错需要的校验位？2 <sup>k</sup> &gt;= C<sub>(M+K)</sub><sup>2</sup> + M + K + 1</p>\n<h3 id=\"循环冗余校验crc\"><a class=\"anchor\" href=\"#循环冗余校验crc\">#</a> 循环冗余校验 CRC</h3>\n<h4 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171249746.png\" alt=\"image-20221115171249746\" /></p>\n<p>无论是奇偶校验还是海明码，需要的代价都很高。海明码也是以奇偶检测为手段的。</p>\n<h4 id=\"基本思想和实现\"><a class=\"anchor\" href=\"#基本思想和实现\">#</a> 基本思想和实现</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171316315.png\" alt=\"image-20221115171316315\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115221430300.png\" alt=\"image-20221115221430300\" /></p>\n<h4 id=\"实例-2\"><a class=\"anchor\" href=\"#实例-2\">#</a> 实例</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171421174.png\" alt=\"image-20221115171421174\" /></p>\n<p>接收方也对 1001 做模 2 运算，余数为 0 则无误。【余数为 111，相等于原来的数加上 111 就能够整除 1001】</p>\n<p>1001（x<sup>3</sup> + 1)</p>\n<p>无借位减，等价于<strong>异或运算</strong>。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115172153954.png\" alt=\"image-20221115172153954\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115214420096.png\" alt=\"image-20221115214420096\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/15/COA/Lecture09-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/",
            "url": "https://quas-modo.github.io/2022/11/15/COA/Lecture09-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/",
            "title": "Lecture09-外部存储器",
            "date_published": "2022-11-15T12:56:09.000Z",
            "content_html": "<p>外部存储器，主要介绍磁盘存储器（结构、读写、数据组织），略带介绍光盘、磁带、快闪存储器。</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture09-外部存储器\"><a class=\"anchor\" href=\"#lecture09-外部存储器\">#</a> Lecture09 - 外部存储器</h1>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109140148221.png\" alt=\"image-20221109140148221\" /></p>\n<h2 id=\"外部存储器简介\"><a class=\"anchor\" href=\"#外部存储器简介\">#</a> 外部存储器简介</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109140744633.png\" alt=\"image-20221109140744633\" /></p>\n<h2 id=\"磁盘存储器\"><a class=\"anchor\" href=\"#磁盘存储器\">#</a> 磁盘存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109140910784.png\" alt=\"image-20221109140910784\" /></p>\n<p>磁盘是一种由<strong>非磁性材料</strong>制成称为衬底（基材）的圆盘，其上涂有一层<strong>磁性材料</strong>。</p>\n<p>磁可以保持稳定。</p>\n<p>玻璃基材有很多优点。</p>\n<p>飞行高度 —— 磁头并不直接接触磁道。飞行高度更低，面对的数据（面积）更小，电磁感应更强，更利于读写数据。磁盘读取很快，如果直接接触，会导致较大的摩擦力，会毁坏磁盘。</p>\n<p>坏道，在无尘环境中修复。（唱片）的针扫到 “灰尘”，会有吱呀吱呀的声音。</p>\n<h3 id=\"磁盘存储器类型\"><a class=\"anchor\" href=\"#磁盘存储器类型\">#</a> 磁盘存储器类型</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109142404842.png\" alt=\"image-20221109142404842\" /></p>\n<p>软盘（读写头在读或写操作时实际地物理接触磁表面，其容量小、使用灵活和价格便宜）</p>\n<h3 id=\"硬磁盘存储器\"><a class=\"anchor\" href=\"#硬磁盘存储器\">#</a> 硬磁盘存储器</h3>\n<h4 id=\"结构轴盘头臂\"><a class=\"anchor\" href=\"#结构轴盘头臂\">#</a> 结构 —— 轴盘头臂</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109142416824.png\" alt=\"image-20221109142416824\" /></p>\n<p>多个盘片，盘间相隔约 1 英寸。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109142429153.png\" alt=\"image-20221109142429153\" /></p>\n<p>大多数磁盘是两面都有可磁化的涂层，称为双面磁盘。</p>\n<p>在上图中，共有 10 个面，有 6 个磁头，中间 4 个是双面的。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143416494.png\" alt=\"image-20221109143416494\" /></p>\n<p>温彻斯特磁盘（温氏磁盘）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143604481.png\" alt=\"image-20221109143604481\" /></p>\n<h4 id=\"读写机制\"><a class=\"anchor\" href=\"#读写机制\">#</a> 读写机制</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143651520.png\" alt=\"image-20221109143651520\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143935791.png\" alt=\"image-20221109143935791\" /></p>\n<p>读写速度由电磁感应的物理速度限制。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143951017.png\" alt=\"image-20221109143951017\" /></p>\n<p>MR magnetoresistive 磁阻</p>\n<p>红框应该框中 MR 敏感器，MR 敏感器是为了满足更高的读速度的要求而出现。MR 敏感器对磁场较为敏感，需要做<strong>屏蔽机制</strong>，防止周围的磁场造成影响。</p>\n<h4 id=\"数据组织磁道-扇区\"><a class=\"anchor\" href=\"#数据组织磁道-扇区\">#</a> 数据组织 —— 磁道、扇区</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109144841491.png\" alt=\"image-20221109144841491\" /></p>\n<p>每个盘面上有上千个磁道。</p>\n<p>相邻磁道间隙 —— 防止或至少可以减少由于磁头为对准或磁域干扰所引起的错误。</p>\n<p>相邻扇区间隙 —— 避免对系统提出不合理的定位精度要求。</p>\n<p>扇区默认大小为<strong> 512B</strong>。（如果题目中没有说明，则采用默认值 512B）</p>\n<p>编号<strong>从外向里</strong>递增。</p>\n<h5 id=\"cav-constant-angular-velocity-恒定角速度\"><a class=\"anchor\" href=\"#cav-constant-angular-velocity-恒定角速度\">#</a> CAV constant angular velocity 恒定角速度</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109145031875.png\" alt=\"image-20221109145031875\" /></p>\n<p>优点：直接寻址</p>\n<p>缺点：容量限制</p>\n<h5 id=\"multiple-zone-recording-多重区域记录\"><a class=\"anchor\" href=\"#multiple-zone-recording-多重区域记录\">#</a> Multiple zone recording 多重区域记录</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109145505507.png\" alt=\"image-20221109145505507\" /></p>\n<p>同一个区域以相同的角速度转，不同的区域以不同的角速度转。区域可以包含多个磁道（相邻磁道之间的周长相差不大，所以需要隔一些磁道进行分组）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109150942979.png\" alt=\"image-20221109150942979\" /></p>\n<h4 id=\"格式化\"><a class=\"anchor\" href=\"#格式化\">#</a> 格式化</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109151053633.png\" alt=\"image-20221109151053633\" /></p>\n<p>图中，每个扇区有 600 字节，包含 512 字节的数据和磁盘控制器使用的控制信息。</p>\n<p>同步字节 ——ID 域开始特定的 01 序列</p>\n<p>扇区间隙 —— 没有被磁化，既不表示 0，也不表示 1。有延时。</p>\n<p>数据域 ——4096 是主流标准，512 是之前的标准，因为之前需要存储的程序和数据较小，存储大小大会造成碎片化问题。混用的时候，把 4096 分为 8 个区域，共享同一个 ID。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109151105554.png\" alt=\"image-20221109151105554\" /></p>\n<p>快速格式化并没有清除数据，而是标注可写。</p>\n<h4 id=\"io访问时间\"><a class=\"anchor\" href=\"#io访问时间\">#</a> IO 访问时间</h4>\n<h5 id=\"寻道时间-旋转延迟-传送时间\"><a class=\"anchor\" href=\"#寻道时间-旋转延迟-传送时间\">#</a> 寻道时间、旋转延迟、传送时间</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109152850127.png\" alt=\"image-20221109152850127\" /></p>\n<p>旋转延迟 —— 可能刚好到，也可能刚好错过，取平均为<strong>半周</strong></p>\n<p>访问时间 = 寻道时间（如果有） + 旋转延迟 【是到达读写位置所需的时间】</p>\n<p>rpm 转速常用单位 resolution per minute</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153121081.png\" alt=\"image-20221109153121081\" /></p>\n<p>寻道时间只考虑第一个磁道 —— 访问相邻的磁道，磁道很窄、移动时间可以忽略不计</p>\n<h5 id=\"案例\"><a class=\"anchor\" href=\"#案例\">#</a> 案例</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153318387.png\" alt=\"image-20221109153318387\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153631766.png\" alt=\"image-20221109153631766\" /></p>\n<p>1 / (2 * 15000 / 60) = 0.002 s = 2ms【注意单位的统一】</p>\n<p>500 / (500 * 15000 / 60) = 4ms</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153643053.png\" alt=\"image-20221109153643053\" /></p>\n<h4 id=\"磁头寻道-磁盘调度\"><a class=\"anchor\" href=\"#磁头寻道-磁盘调度\">#</a> 磁头寻道、磁盘调度</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153937260.png\" alt=\"image-20221109153937260\" /></p>\n<h5 id=\"先来先服务\"><a class=\"anchor\" href=\"#先来先服务\">#</a> 先来先服务</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154019777.png\" alt=\"image-20221109154019777\" /></p>\n<h5 id=\"最短寻道时间优先\"><a class=\"anchor\" href=\"#最短寻道时间优先\">#</a> 最短寻道时间优先</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154112018.png\" alt=\"image-20221109154112018\" /></p>\n<p>最短寻道时间优先 (SSTF) 算法会导致 “饥饿” 现象发生，因为<strong>只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近</strong>，这种新进程的 I/O 请求必然优先满足（也就是距离磁头当前所在磁道的距离较远的磁道总是得不到访问）。</p>\n<h5 id=\"扫描电梯scan\"><a class=\"anchor\" href=\"#扫描电梯scan\">#</a> 扫描 / 电梯 SCAN</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154319022.png\" alt=\"image-20221109154319022\" /></p>\n<h5 id=\"循环扫描c-scan\"><a class=\"anchor\" href=\"#循环扫描c-scan\">#</a> 循环扫描 C-SCAN</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154329283.png\" alt=\"image-20221109154329283\" /></p>\n<h5 id=\"lookscan算法的升级\"><a class=\"anchor\" href=\"#lookscan算法的升级\">#</a> LOOK (SCAN 算法的升级)</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154745626.png\" alt=\"image-20221109154745626\" /></p>\n<h5 id=\"c-lookc-scan算法的改进\"><a class=\"anchor\" href=\"#c-lookc-scan算法的改进\">#</a> C-LOOK（C-SCAN 算法的改进）</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154917267.png\" alt=\"image-20221109154917267\" /></p>\n<h2 id=\"光存储器\"><a class=\"anchor\" href=\"#光存储器\">#</a> 光存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110163221804.png\" alt=\"image-20221110163221804\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110162427440.png\" alt=\"image-20221110162427440\" /></p>\n<h3 id=\"cd和cd-rom\"><a class=\"anchor\" href=\"#cd和cd-rom\">#</a> CD 和 CD-ROM</h3>\n<h4 id=\"制造方法\"><a class=\"anchor\" href=\"#制造方法\">#</a> 制造方法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110162711863.png\" alt=\"image-20221110162711863\" /></p>\n<p>在<strong>凹坑</strong>表面镀上一层高反射材料（一般采用铝，HQCD 采用银合金）</p>\n<h4 id=\"读取\"><a class=\"anchor\" href=\"#读取\">#</a> 读取</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110163548903.png\" alt=\"image-20221110163548903\" /></p>\n<ol>\n<li>\n<p>光传感器检测凹坑与台之间的反射光强弱变化，并将其转换成数字信号。传感器以规整的间隔检测表面。 一个凹坑的开始或结束表示一个 1；间隔之间无标高变动出现时，记录为一个 0。</p>\n</li>\n<li>\n<p>单螺旋式轨道 —— 凹坑被激光以恒定线速度（<strong>CLV</strong>，constant linear velocity）读出</p>\n</li>\n<li>\n<p>CD-ROM 块格式</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164457816.png\" alt=\"image-20221110164457816\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164510136.png\" alt=\"image-20221110164510136\" /></p>\n</li>\n</ol>\n<h4 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164245961.png\" alt=\"image-20221110164245961\" /></p>\n<h3 id=\"cd-r和cd-rw\"><a class=\"anchor\" href=\"#cd-r和cd-rw\">#</a> CD-R 和 CD-RW</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164727597.png\" alt=\"image-20221110164727597\" /></p>\n<h4 id=\"cd-r\"><a class=\"anchor\" href=\"#cd-r\">#</a> CD-R</h4>\n<p>可刻录 CD—— 一写多读</p>\n<h4 id=\"cd-rw\"><a class=\"anchor\" href=\"#cd-rw\">#</a> CD-RW</h4>\n<p>可重写盘 —— 多写</p>\n<p>使用了<strong>光致相变材料</strong></p>\n<h3 id=\"dvd数字多功能光盘\"><a class=\"anchor\" href=\"#dvd数字多功能光盘\">#</a> DVD 数字多功能光盘</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110165211317.png\" alt=\"image-20221110165211317\" /></p>\n<h3 id=\"高清晰光盘\"><a class=\"anchor\" href=\"#高清晰光盘\">#</a> 高清晰光盘</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110165245610.png\" alt=\"image-20221110165245610\" /></p>\n<p>衍射极限公式：</p>\n<p>波长 lambda 和分辨两点的最小距离 D 正相关</p>\n<h2 id=\"磁带\"><a class=\"anchor\" href=\"#磁带\">#</a> 磁带</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110165638182.png\" alt=\"image-20221110165638182\" /></p>\n<p>磁性材料，有许多磁针，根据磁场方向发生变化。</p>\n<p>磁带顺序读取 —— 依次读取，想要读取前面的必须倒带</p>\n<p>直接存取 —— 不需要顺序读取磁盘上的所有扇区</p>\n<p>并行记录（parallel recording）读写蛇形</p>\n<p>串行记录（serial recording）（蛇形记录 serpentine recording 时串行记录的典型记录技术）</p>\n<p>6-14(a)</p>\n<p>6-14 (b) 为了提高速度，读 - 写头能同时对几个相邻磁道进行读写操作</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171608725.png\" alt=\"image-20221110171608725\" /></p>\n<h2 id=\"快闪存储器\"><a class=\"anchor\" href=\"#快闪存储器\">#</a> 快闪存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171635494.png\" alt=\"image-20221110171635494\" /></p>\n<h2 id=\"u盘和固态硬盘\"><a class=\"anchor\" href=\"#u盘和固态硬盘\">#</a> U 盘和固态硬盘</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171653977.png\" alt=\"image-20221110171653977\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171711344.png\" alt=\"image-20221110171711344\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/03/COA/Lecture08-cache/",
            "url": "https://quas-modo.github.io/2022/11/03/COA/Lecture08-cache/",
            "title": "Lecture08-cache",
            "date_published": "2022-11-03T13:03:21.000Z",
            "content_html": "<p>cache 缓存器，解决内存墙问题，是主存部分的副本，设计要素有地址、容量、映射功能、替换算法、写策略、行大小、cache 数目。</p>\n<h1 id=\"lecture08-cache\"><a class=\"anchor\" href=\"#lecture08-cache\">#</a> Lecture08-cache</h1>\n<h2 id=\"cache简介\"><a class=\"anchor\" href=\"#cache简介\">#</a> cache 简介</h2>\n<h3 id=\"存储器层次结构\"><a class=\"anchor\" href=\"#存储器层次结构\">#</a> 存储器层次结构</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164918401.png\" alt=\"image-20221101164918401\" /></p>\n<p>随着层次的下降，每位价格下降，容量增大，存取时间变长，处理器访问存储器的频率降低。</p>\n<p>cache（高速缓存）存储器的目的是使存储器的速度逼近可用的最快存储器的速度。</p>\n<p>多级 cache 一般标注为 L1、L2，通常由动态随机存取存储器（DRAM）构成。</p>\n<h3 id=\"cache存在的意义解决内存墙的问题\"><a class=\"anchor\" href=\"#cache存在的意义解决内存墙的问题\">#</a> cache 存在的意义：解决内存墙的问题</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165310897.png\" alt=\"image-20221101165310897\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165325716.png\" alt=\"image-20221101165325716\" /></p>\n<h3 id=\"cache的基本思路\"><a class=\"anchor\" href=\"#cache的基本思路\">#</a> cache 的基本思路</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164904882.png\" alt=\"image-20221101164904882\" /></p>\n<p>只是主存<strong>部分</strong>信息的<strong>副本</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101170441990.png\" alt=\"image-20221101170441990\" /></p>\n<h3 id=\"cache主存系统的结构\"><a class=\"anchor\" href=\"#cache主存系统的结构\">#</a> cache / 主存系统的结构</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101205028927.png\" alt=\"image-20221101205028927\" /></p>\n<p>主存系统中 ——M 个块，每块有 K 个字</p>\n<p>cache 中 ——m 个块，称作行【控制为 + 标记 + K 个字】</p>\n<p><strong>行的数量远远小于主存储器块的数目 m &lt;&lt; M</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101170954954.png\" alt=\"image-20221101170954954\" /></p>\n<p>传入地址 RA， 最后红线框处的两步为并行操作。</p>\n<h2 id=\"cache的工作流程\"><a class=\"anchor\" href=\"#cache的工作流程\">#</a> cache 的工作流程</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165017905.png\" alt=\"image-20221101165017905\" /></p>\n<ul>\n<li>Hit—— 传送的是<strong>字</strong></li>\n<li>Miss—— 读入 cache 的是<strong>块</strong>，传入 CPU 的是<strong>字</strong></li>\n</ul>\n<h2 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165200894.png\" alt=\"image-20221101165200894\" /></p>\n<h3 id=\"命中还是未命中\"><a class=\"anchor\" href=\"#命中还是未命中\">#</a> 命中还是未命中？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165513269.png\" alt=\"image-20221101165513269\" /></p>\n<p>CPU、cache、主存如何建立地址的一一对应关系？</p>\n<p><strong>标记</strong>是什么？</p>\n<h3 id=\"为什么从内存中读入一个块\"><a class=\"anchor\" href=\"#为什么从内存中读入一个块\">#</a> 为什么从内存中读入一个块？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165809967.png\" alt=\"image-20221101165809967\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171223532.png\" alt=\"image-20221101171223532\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171836956.png\" alt=\"image-20221101171836956\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101172138850.png\" alt=\"image-20221101172138850\" /></p>\n<p>利用空间局限性，所以把块传入 cache 当中。</p>\n<p>块在 cache 中，则字在 cache 中。</p>\n<p>标记和内存地址之间的关系？</p>\n<h3 id=\"使用cache需要更多的操作为什么还可以节省时间\"><a class=\"anchor\" href=\"#使用cache需要更多的操作为什么还可以节省时间\">#</a> 使用 cache 需要更多的操作，为什么还可以节省时间？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101173524901.png\" alt=\"image-20221101173524901\" /></p>\n<p>Tm 是未命中惩罚</p>\n<p>两个式子都需要理解，下面的式子更方便做题。</p>\n<p>降低 cache 的访问时间与提高命中率矛盾 —— 存的东西多，提高命中率，但是降低了 cache 的访问时间。</p>\n<h4 id=\"避免cache未命中提高命中率\"><a class=\"anchor\" href=\"#避免cache未命中提高命中率\">#</a> 避免 cache 未命中，提高命中率</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101173558232.png\" alt=\"image-20221101173558232\" /></p>\n<p>容量失效 —— 涉及映射规则和替代原则的问题</p>\n<p>冲突失效 —— 例如直接映射中的冲突</p>\n<h2 id=\"cache的设计要素\"><a class=\"anchor\" href=\"#cache的设计要素\">#</a> cache 的设计要素</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101173743177.png\" alt=\"image-20221101173743177\" /></p>\n<h3 id=\"cache地址\"><a class=\"anchor\" href=\"#cache地址\">#</a> cache 地址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174037678.png\" alt=\"image-20221101174037678\" /></p>\n<p>物理 cache 和逻辑 cache 的比较</p>\n<p>逻辑 cache 访问速度快，但是需要 cache 的每一行增加额外的几位来标记与该地址相关的虚拟地址。</p>\n<h3 id=\"cache容量\"><a class=\"anchor\" href=\"#cache容量\">#</a> cache 容量</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174233373.png\" alt=\"image-20221101174233373\" /></p>\n<p>1k 涨到 16k，命中率有明显的上升，可以解决一些容量失效的额问题，但是再往后，命中率的上升近乎达到峰值。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174537594.png\" alt=\"image-20221101174537594\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174552006.png\" alt=\"image-20221101174552006\" /></p>\n<h3 id=\"映射功能\"><a class=\"anchor\" href=\"#映射功能\">#</a> 映射功能</h3>\n<h4 id=\"直接映射\"><a class=\"anchor\" href=\"#直接映射\">#</a> 直接映射</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174930231.png\" alt=\"image-20221101174930231\" /></p>\n<p>左边的映射方式可能会造成容量失效的问题。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101175153621.png\" alt=\"image-20221101175153621\" /></p>\n<p>000H 和 080H 对应一个 cache 的行，每隔 8 个就会共用一个 cache 的行。</p>\n<p>稍微真实一点的示例，一个块里面有 16 个字，每个地址差 10H（即为 16）。</p>\n<p>H 是 16 进制的意思。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101175330724.png\" alt=\"image-20221101175330724\" /></p>\n<p>M = 主存的块数</p>\n<p>i = cache 行号（在 cache 中对应的行数）</p>\n<p>j = 主存储器的块号</p>\n<p>C = cache 的行数（cache 总共的行数）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101210831620.png\" alt=\"image-20221101210831620\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101175648891.png\" alt=\"image-20221101175648891\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101213351613.png\" alt=\"image-20221101213351613\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101213323009.png\" alt=\"image-20221101213323009\" /></p>\n<h4 id=\"全相联映射关联映射\"><a class=\"anchor\" href=\"#全相联映射关联映射\">#</a> 全相联映射（关联映射）</h4>\n<p>标记域 + 字域（s+w）位，cache 中的行号不由地址格式决定</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103162237911.png\" alt=\"image-20221103162237911\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101213419743.png\" alt=\"image-20221101213419743\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163021051.png\" alt=\"image-20221103163021051\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163033660.png\" alt=\"image-20221103163033660\" /></p>\n<h4 id=\"组关联映射\"><a class=\"anchor\" href=\"#组关联映射\">#</a> 组关联映射</h4>\n<p>折中方法，体现了直接映射和全相联映射的优点，又避免了两者的缺点。</p>\n<p>标记 + 组（v = 2 <sup>d</sup>）+ 字（块大小 ）。</p>\n<p>一组中有 K 行。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163817034.png\" alt=\"image-20221103163817034\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163951991.png\" alt=\"image-20221103163951991\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164015137.png\" alt=\"image-20221103164015137\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164147269.png\" alt=\"image-20221103164147269\" /></p>\n<p>小容量适合全关联映射</p>\n<p>大容量适合直接映射</p>\n<p>K 路组关联映射处于两者之间</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172751908.png\" alt=\"image-20221103172751908\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172808723.png\" alt=\"image-20221103172808723\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172844027.png\" alt=\"image-20221103172844027\" /></p>\n<p>两个映射到同一 cache 组的块不可能具有相同的标记数。</p>\n<p>每组两行 (v = m/2, k = 2) 是最常用的组相联结构，与直接映射相比，它明显地提高了命中率。</p>\n<h4 id=\"三种映射方式比较\"><a class=\"anchor\" href=\"#三种映射方式比较\">#</a> 三种映射方式比较</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164308172.png\" alt=\"image-20221103164308172\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164318953.png\" alt=\"image-20221103164318953\" /></p>\n<p>关联度越低，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小。【关联度小，其他三个都小】</p>\n<h3 id=\"替换算法\"><a class=\"anchor\" href=\"#替换算法\">#</a> 替换算法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164810384.png\" alt=\"image-20221103164810384\" /></p>\n<h4 id=\"常用的替换算法\"><a class=\"anchor\" href=\"#常用的替换算法\">#</a> 常用的替换算法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165206857.png\" alt=\"image-20221103165206857\" /></p>\n<h4 id=\"最近最少使用算法lru\"><a class=\"anchor\" href=\"#最近最少使用算法lru\">#</a> 最近最少使用算法 LRU</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165310688.png\" alt=\"image-20221103165310688\" /></p>\n<p>USE 位为 0，不代表没有数据</p>\n<p>由前文，可以看到，两路组关联映射是最常用的方法，这个实现是很有现实意义的举例。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165326712.png\" alt=\"image-20221103165326712\" /></p>\n<p>最后一个 1110 的替换，LRU 最大为 3 的位置被替换，其他得未被访问的行的 LRU 自增 1。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpYW9waWFvbGFuZ2h1YS9hcnRpY2xlL2RldGFpbHMvOTM4NDA0Mw==\">https://blog.csdn.net/piaopiaolanghua/article/details/9384043</span></p>\n<p>为什么是 log (K!)—— 排列组合的问题</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165404094.png\" alt=\"image-20221103165404094\" /></p>\n<p>LRU 的命中率可能没有想象中那么高</p>\n<h4 id=\"先进先出算法fifo\"><a class=\"anchor\" href=\"#先进先出算法fifo\">#</a> 先进先出算法 FIFO</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165417670.png\" alt=\"image-20221103165417670\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165432556.png\" alt=\"image-20221103165432556\" /></p>\n<h4 id=\"最不经常使用算法lfu\"><a class=\"anchor\" href=\"#最不经常使用算法lfu\">#</a> 最不经常使用算法 LFU</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165447852.png\" alt=\"image-20221103165447852\" /></p>\n<p>所需要的额外的硬件实现太多，不能够支持。</p>\n<h4 id=\"随机替换算法\"><a class=\"anchor\" href=\"#随机替换算法\">#</a> 随机替换算法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165504705.png\" alt=\"image-20221103165504705\" /></p>\n<p>随机替换算法是一种基线【或者说底线】，随机替换算法在性能上只稍逊于使用其他替换算法，也就说明其他随机替换算法没有那么好。</p>\n<h3 id=\"写策略\"><a class=\"anchor\" href=\"#写策略\">#</a> 写策略</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172948799.png\" alt=\"image-20221103172948799\" /></p>\n<h4 id=\"缓存命中时的写策略写直达write-through\"><a class=\"anchor\" href=\"#缓存命中时的写策略写直达write-through\">#</a> 缓存命中时的写策略：写直达 Write Through</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103173037433.png\" alt=\"image-20221103173037433\" /></p>\n<h4 id=\"缓存命中时的写策略写回法write-back\"><a class=\"anchor\" href=\"#缓存命中时的写策略写回法write-back\">#</a> 缓存命中时的写策略：写回法 Write Back</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103173052648.png\" alt=\"image-20221103173052648\" /></p>\n<p>缺点的解决方法：每次 I/O 模块存取的时候先和 cache 做一个同步</p>\n<h4 id=\"缓存未命中的写策略写不分配写分配\"><a class=\"anchor\" href=\"#缓存未命中的写策略写不分配写分配\">#</a> 缓存未命中的写策略：写不分配 / 写分配</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103173811474.png\" alt=\"image-20221103173811474\" /></p>\n<h3 id=\"行大小\"><a class=\"anchor\" href=\"#行大小\">#</a> 行大小</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103174054409.png\" alt=\"image-20221103174054409\" /></p>\n<p>不是违反时间和空间关系，而是影响局部性（？</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103180046644.png\" alt=\"image-20221103180046644\" /></p>\n<h3 id=\"cache数目\"><a class=\"anchor\" href=\"#cache数目\">#</a> cache 数目</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103174453746.png\" alt=\"image-20221103174453746\" /></p>\n<p>通常，会有片内和片外的 cache。片内 cache 为第一级（L1），外部 cache 为第二级（L2）。L2cache 大小至少为 L1cache 大小的两倍时，才对提高总命中率有明显的作用。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103174504972.png\" alt=\"image-20221103174504972\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/",
            "url": "https://quas-modo.github.io/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/",
            "title": "Lecture07-存储器",
            "date_published": "2022-10-24T05:30:15.000Z",
            "content_html": "<p>存储器相关，聚焦于半导体存储器，主要分为读写存储器、只读存储器以及读为主的存储器。接着叙述芯片逻辑，以及芯片优化。<br />\n<span id=\"more\"></span></p>\n<h2 id=\"回顾存储器\"><a class=\"anchor\" href=\"#回顾存储器\">#</a> 回顾：存储器</h2>\n<h2 id=\"回顾存储器-2\"><a class=\"anchor\" href=\"#回顾存储器-2\">#</a> 回顾：存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221020163158122.png\" alt=\"image-20221020163158122\" /></p>\n<p>1Byte（字节） = 8 bit（比特）</p>\n<p>1 字 可能是 4 字节，也可能是 8 字节。根据计算机是 32 位还是 64 位有所不同，不同计算机有不同的字长。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171557660.png\" alt=\"image-20221101171557660\" /></p>\n<h2 id=\"存储器层次结构\"><a class=\"anchor\" href=\"#存储器层次结构\">#</a> 存储器层次结构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221021202852887.png\" alt=\"image-20221021202852887\" /></p>\n<h2 id=\"半导体存储器\"><a class=\"anchor\" href=\"#半导体存储器\">#</a> 半导体存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124316886.png\" alt=\"image-20221024124316886\" /></p>\n<p><strong>半导体</strong></p>\n<p>位元 存储 1 位数据</p>\n<h3 id=\"半导体存储器类型\"><a class=\"anchor\" href=\"#半导体存储器类型\">#</a> 半导体存储器类型</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124432370.png\" alt=\"image-20221024124432370\" /></p>\n<p>表中列出的而<strong>所有类型的存储器都是随机存取</strong>的。</p>\n<p>快闪 flash——U 盘是其中的一种。</p>\n<h3 id=\"读-写存储器随机存取存储器ram\"><a class=\"anchor\" href=\"#读-写存储器随机存取存储器ram\">#</a> 读 - 写存储器 —— 随机存取存储器 RAM</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124536588.png\" alt=\"image-20221024124536588\" /></p>\n<p>RAM 的明显特征是，可以<strong>方便快捷</strong>地从存储器读取数据和向存储器写入新数据，且读写操作都是通过使用<strong>电信号</strong>来实现的。</p>\n<p><strong>易失</strong> —— 必须持续供电，一旦断电，数据就会丢失。</p>\n<h4 id=\"sram-静态ram\"><a class=\"anchor\" href=\"#sram-静态ram\">#</a> SRAM 静态 RAM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124554411.png\" alt=\"image-20221024124554411\" /></p>\n<p>CS 片送</p>\n<p>RW 控制读写</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124714978.png\" alt=\"image-20221024124714978\" /></p>\n<p>推导过程</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130157726.png\" alt=\"image-20221024130157726\" /></p>\n<h4 id=\"dram-动态ram\"><a class=\"anchor\" href=\"#dram-动态ram\">#</a> DRAM 动态 RAM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124958784.png\" alt=\"image-20221024124958784\" /></p>\n<p>通过电容充电来存储数据。</p>\n<p>电容器有漏电趋势，动态 RAM 需要周期地充电刷新来维持数据的存储。</p>\n<p>动态一词就是在描述存储电荷丢失的趋势，即使电源一直在供电。</p>\n<h4 id=\"sram与dram的对比\"><a class=\"anchor\" href=\"#sram与dram的对比\">#</a> SRAM 与 DRAM 的对比</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024125105338.png\" alt=\"image-20221024125105338\" /></p>\n<p>DRAM 密度高，价格便宜，趋向于满足大容量存储器的要求。但是 SRAM 更快。</p>\n<p>SRAM 一般用于 cache 存储器（片上或者片外的）【CPU 中】，而 DRAM 则用于主存储器中。</p>\n<h3 id=\"只读存储器\"><a class=\"anchor\" href=\"#只读存储器\">#</a> 只读存储器</h3>\n<h4 id=\"rom-只读存储器\"><a class=\"anchor\" href=\"#rom-只读存储器\">#</a> ROM 只读存储器</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130516422.png\" alt=\"image-20221024130516422\" /></p>\n<p>问题补充：固化数据需要较大的固定成本，无论是制造一片或者复制上千片特殊的 ROM。但是可以通过批量生产降低单片芯片的成本。</p>\n<h4 id=\"可编程romprom\"><a class=\"anchor\" href=\"#可编程romprom\">#</a> 可编程 ROM（PROM）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130821252.png\" alt=\"image-20221024130821252\" /></p>\n<p>需要少量的存储特定内容的 ROM 芯片，可以选择较为廉价的可编程 PROM</p>\n<p>可由供应商或者用户在芯片出厂后写入一次、</p>\n<h3 id=\"主要进行读操作的存储器\"><a class=\"anchor\" href=\"#主要进行读操作的存储器\">#</a> 主要进行读操作的存储器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131021140.png\" alt=\"image-20221024131021140\" /></p>\n<h4 id=\"eprom\"><a class=\"anchor\" href=\"#eprom\">#</a> EPROM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131047438.png\" alt=\"image-20221024131047438\" /></p>\n<p>使芯片暴露在紫外线辐射下使所有的存储位元都被擦除，没有办法做到很精确，因此是芯片级的可擦除性。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131226634.png\" alt=\"image-20221024131226634\" /></p>\n<h4 id=\"eeprom\"><a class=\"anchor\" href=\"#eeprom\">#</a> EEPROM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131245626.png\" alt=\"image-20221024131245626\" /></p>\n<p>任何时候都可以写入，无需擦除原先内容，只更新寻址到的一个或多个字节。</p>\n<p>将非易失性和数据修改灵活的优点结合起来。修改数据只需要使用常规的控制、地址和地址总线。</p>\n<p><strong>电写入，从 1 变成 0； 电擦除，从 0 变成 1。</strong></p>\n<h4 id=\"快闪存储器\"><a class=\"anchor\" href=\"#快闪存储器\">#</a> 快闪存储器</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131457113.png\" alt=\"image-20221024131457113\" /></p>\n<p>NAND Flash 共用一条线 —— 外部存储器</p>\n<h3 id=\"各类rom对比\"><a class=\"anchor\" href=\"#各类rom对比\">#</a> 各类 ROM 对比</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131557564.png\" alt=\"image-20221024131557564\" /></p>\n<h2 id=\"芯片逻辑\"><a class=\"anchor\" href=\"#芯片逻辑\">#</a> 芯片逻辑</h2>\n<h3 id=\"从位元到主存\"><a class=\"anchor\" href=\"#从位元到主存\">#</a> 从位元到主存</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131723140.png\" alt=\"image-20221024131723140\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131744592.png\" alt=\"image-20221024131744592\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131758270.png\" alt=\"image-20221024131758270\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131957375.png\" alt=\"image-20221024131957375\" /></p>\n<p>位扩展，从 1bit 增加到 8bit，需要增加 7 根线。</p>\n<p>字扩展，从 16K 变成 64K，16K 需要 7 根线，64K 需要 8 根线【因为行列复用】，只需要增加一根线，就可以实现 16K 到 64K。</p>\n<p>1K = 2 <sup>10</sup></p>\n<p>有多少位数据，就需要有多少根数据线。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101172926489.png\" alt=\"image-20221101172926489\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132007925.png\" alt=\"image-20221024132007925\" /></p>\n<h3 id=\"如何寻址地址译码器\"><a class=\"anchor\" href=\"#如何寻址地址译码器\">#</a> 如何寻址：地址译码器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131851948.png\" alt=\"image-20221024131851948\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131815432.png\" alt=\"image-20221024131815432\" /></p>\n<p>DRAM 不用刷新，采用行列复用 —— 用 11 位分别计算出行地址和列地址进行访问， 因为 DRAM 的存储空间较大，且行列复用耗时较高，所以只在 DRAM 中使用。</p>\n<p>SRAM 且没有 RAS（行地址选通）和 CAS（列地址选通），也没有数据输入输出缓冲器，SRAM 常作为缓存，需要更快的速度。</p>\n<p>WE 写允许</p>\n<p>OE 输出允许</p>\n<h3 id=\"如何刷新\"><a class=\"anchor\" href=\"#如何刷新\">#</a> 如何刷新</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131911336.png\" alt=\"image-20221024131911336\" /></p>\n<p>集中式刷新会造成死区，影响使用，因此开发分散式刷新和异步刷新进行优化。</p>\n<p>译码阶段不需要进行缓存，每行的刷新相对独立，不需要按照顺序。</p>\n<h2 id=\"高级的dram架构\"><a class=\"anchor\" href=\"#高级的dram架构\">#</a> 高级的 DRAM 架构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132123622.png\" alt=\"image-20221024132123622\" /></p>\n<h3 id=\"同步dramsynchorounous-dram-sdram\"><a class=\"anchor\" href=\"#同步dramsynchorounous-dram-sdram\">#</a> 同步 DRAM (Synchorounous DRAM, SDRAM)</h3>\n<h3 id=\"双频率sdramdouble-data-rate-sdram\"><a class=\"anchor\" href=\"#双频率sdramdouble-data-rate-sdram\">#</a> 双频率 SDRAM (Double-Data-Rate SDRAM)</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132312999.png\" alt=\"image-20221024132312999\" /></p>\n<p>SDRAM</p>\n<p>在每一次行选之前，都需要做预充电</p>\n<p>如果下一次仍然是同一行的数据，不需要行选。</p>\n<p>在时钟上升沿才能发数据</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132326001.png\" alt=\"image-20221024132326001\" /></p>\n<p>DDR SDRAM</p>\n<p>在时钟下升沿也可以发数据</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132335364.png\" alt=\"image-20221024132335364\" /></p>\n<p>核心频率无法改变 —— 电容很难提升</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101162647755.png\" alt=\"image-20221101162647755\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101162656519.png\" alt=\"image-20221101162656519\" /></p>\n<h2 id=\"寄存器基本原理\"><a class=\"anchor\" href=\"#寄存器基本原理\">#</a> 寄存器基本原理</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164208668.png\" alt=\"image-20221101164208668\" /></p>\n<p>边沿 D 触发器，RS 锁存器以及增加了 input 和 clock（？</p>\n<p>寄存器和 CPU 的时钟同步</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132047639.png\" alt=\"image-20221024132047639\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/18/COA/Lecture06-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%8D%81%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/10/18/COA/Lecture06-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%8D%81%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture06-加减法十进制表示",
            "date_published": "2022-10-18T11:50:47.000Z",
            "content_html": "<p>十进制表示的加减法<br />\n &lt;!--more&gt;</p>\n<h1 id=\"lecture06-加减法十进制数表示\"><a class=\"anchor\" href=\"#lecture06-加减法十进制数表示\">#</a> Lecture06 加减法十进制数表示</h1>\n<h2 id=\"回顾二进制编码的十进制表示\"><a class=\"anchor\" href=\"#回顾二进制编码的十进制表示\">#</a> 回顾：二进制编码的十进制表示</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161625312.png\" alt=\"image-20221018161625312\" /></p>\n<h2 id=\"回顾补码表示整数的加减法\"><a class=\"anchor\" href=\"#回顾补码表示整数的加减法\">#</a> 回顾：补码表示整数的加减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161749133.png\" alt=\"image-20221018161749133\" /></p>\n<h3 id=\"加法溢出判定\"><a class=\"anchor\" href=\"#加法溢出判定\">#</a> 加法溢出判定</h3>\n<p>正负 进位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162304448.png\" alt=\"image-20221018162304448\" /></p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162440184.png\" alt=\"image-20221018162440184\" /></p>\n<h3 id=\"25-31-56\"><a class=\"anchor\" href=\"#25-31-56\">#</a> 25 + 31 = 56</h3>\n<p>用 0010 表示 2，用 0101 表示 5</p>\n<p>用 0011 表示 3，用 0001 表示 1</p>\n<p>个位数和十位数的和均小于 9</p>\n<h3 id=\"28-39-67\"><a class=\"anchor\" href=\"#28-39-67\">#</a> 28 + 39 = 67</h3>\n<p>0001 要再加上一个 0110 等于 0111</p>\n<p><strong>为什么加上 6？</strong></p>\n<p>二进制 10000 的第 5 位表示 16，但在十进制中实际上表示的是 10，少进了 6，所以在个位还需要再加上 6。</p>\n<h3 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163500884.png\" alt=\"image-20221018163500884\" /></p>\n<p>左边表格分别表示 10-19 的数，右边为实际的硬件实现。</p>\n<p>C4 表达式的意思是，如果（S1 和 S3 为 1）或者（S2 和 S3 为 1）则肯定大于 10，若 C4 * 为 1，则肯定大于 16。【公式中的 S1、2、3 应该有星号）</p>\n<p>C4 作为输出的同时，也对 S2 和 S1 的真正输出产生了影响。</p>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164311877.png\" alt=\"image-20221018164311877\" /></p>\n<p>9-x 不会出现借位的情况。</p>\n<h3 id=\"反转数字\"><a class=\"anchor\" href=\"#反转数字\">#</a> “反转” 数字：</h3>\n<ul>\n<li>按位反转，并添加 <code>1010</code> （10）</li>\n<li>添加 <code>0110</code> （6），并按位反转</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190527126.png\" alt=\"image-20221018190527126\" /></p>\n<h3 id=\"结果调整\"><a class=\"anchor\" href=\"#结果调整\">#</a> 结果调整</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164745084.png\" alt=\"image-20221018164745084\" /></p>\n<h4 id=\"309-125184有进位舍弃进位\"><a class=\"anchor\" href=\"#309-125184有进位舍弃进位\">#</a> 309-125=184 (有进位，舍弃进位)</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018194656730.png\" alt=\"image-20221018194656730\" /></p>\n<p>当得到的结果在 <code>10~19</code>  时，都需要进行修正。 <code>10~15</code>  时，加上 6 进行修正。</p>\n<p>例如，1110 + 0110 进 1 得到 0100. 即 13+6-16 (-10) 得到 3。</p>\n<p>有进位相当于，a-b 的时候 a&gt;b，所以 a-b = a + (999 - b) + 1 - 1000。</p>\n<h4 id=\"125-309-184无进位取反加1符号位设为负\"><a class=\"anchor\" href=\"#125-309-184无进位取反加1符号位设为负\">#</a> 125-309 = -184（无进位，取反加 1，符号位设为负）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018194641391.png\" alt=\"image-20221018194641391\" /></p>\n<p>相当于此时 a &lt; b</p>\n<p>a - b =  -[1000 - [a + (999 - b) + 1]]</p>\n<p>【以上部分可参考 Lecture05 中，尾数的原码加法示例，是一样的道理】</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164912432.png\" alt=\"image-20221018164912432\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/14/COA/Lecture05-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/14/COA/Lecture05-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/",
            "title": "Lecture05-浮点数计算",
            "date_published": "2022-10-14T02:57:07.000Z",
            "content_html": "<p>浮点数的加减乘除。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"lecture05-浮点数运算\"><a class=\"anchor\" href=\"#lecture05-浮点数运算\">#</a> Lecture05 - 浮点数运算</h1>\n<h2 id=\"回顾\"><a class=\"anchor\" href=\"#回顾\">#</a> 回顾</h2>\n<p>记忆 1+8+23 的（符号位移码原码）</p>\n<p>记忆各种情况对应的表示</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013162002689.png\" alt=\"image-20221013162002689\" /></p>\n<h2 id=\"加法和减法\"><a class=\"anchor\" href=\"#加法和减法\">#</a> 加法和减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013162704448.png\" alt=\"image-20221013162704448\" /></p>\n<ol>\n<li>\n<p>检查 0：如果有 0 存在可以不用计算</p>\n</li>\n<li>\n<p>对齐有效位：阶码向<strong>大值</strong>对齐，因为右移较小的数而丢失的数字所造成的的影响较小。右移较小的数有效值的幅值部分 1 位，并将阶值加 1。<strong>如果两个数的阶值差别非常大，则较小的数丢失</strong></p>\n</li>\n<li>\n<p>加或减有效值：<strong>原码加减法</strong></p>\n</li>\n<li>\n<p>规格化结果：把结果调整为左移有效值直到<strong>最高有效数字为非 0</strong>。</p>\n<p>（右规最多是两位，最多是 1.1111...+1.xxxx，对应有效值的上溢）</p>\n</li>\n</ol>\n<h3 id=\"溢出\"><a class=\"anchor\" href=\"#溢出\">#</a> 溢出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013164459041.png\" alt=\"image-20221013164459041\" /></p>\n<ol>\n<li>阶值上溢</li>\n</ol>\n<p>​\t\t最大允许阶值 127（11111110）</p>\n<p>​\t\t右移可能会导致阶值的上溢</p>\n<ol start=\"2\">\n<li>\n<p>阶值下溢</p>\n<p>最小阶值为 - 126（00000001）</p>\n<p>左移可能会引起阶值的下溢</p>\n</li>\n<li>\n<p>有效值的上下溢只存在于右规</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013171505053.png\" alt=\"image-20221013171503186\" /></p>\n</li>\n</ol>\n<h3 id=\"异常\"><a class=\"anchor\" href=\"#异常\">#</a> 异常</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014093204887.png\" alt=\"image-20221014093204887\" /></p>\n<p>关于<strong>数太小</strong>阶下溢的问题，在 cpp 中，如果是单精度浮点数，会用非规格化数表示，如果是双精度浮点数，会直接用 0 表示。</p>\n<h3 id=\"原码的加法\"><a class=\"anchor\" href=\"#原码的加法\">#</a> 原码的加法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013165531300.png\" alt=\"image-20221013165531300\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013165721396.png\" alt=\"image-20221013165721396\" /></p>\n<p>求补的时候加了 2 的 n 次方</p>\n<p>有进位说明 a&gt;b</p>\n<p>无进位说明 a&lt;b</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014103516514.png\" alt=\"image-20221014103516514\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013172902710.png\" alt=\"image-20221013172902710\" /></p>\n<p>01111110 ——127    23 表示有 23 个零</p>\n<p>01111101 ——126    21 表示有 21 个零</p>\n<p>差了一位，左移一位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173317582.png\" alt=\"image-20221013173317582\" /></p>\n<p>1111110 127</p>\n<p>1111101 126</p>\n<p>然后给 0.4375 取个反</p>\n<h2 id=\"乘法和除法\"><a class=\"anchor\" href=\"#乘法和除法\">#</a> 乘法和除法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013163420919.png\" alt=\"image-20221013163420919\" /></p>\n<p>注意乘法和除法的阶值计算 ——</p>\n<ul>\n<li>乘法加 bias</li>\n<li>除法减 bias</li>\n<li>bias 的值为 127【通常，移码的偏移量为 2<sup>k-1</sup> -1，移码的偏移量主要是看想表示多少个负数和多少个正数，阶码的范围是 - 126~127，-127 和 128 分别表示特殊的数】</li>\n</ul>\n<h3 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173727304.png\" alt=\"image-20221013173727304\" /></p>\n<p>对于乘法来说，只有右规。【1.x * 1.x 只可能超出】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173847536.png\" alt=\"image-20221013173847536\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174221322.png\" alt=\"image-20221013174221322\" /></p>\n<p>最高两位为 01，不用处理。</p>\n<h3 id=\"除法\"><a class=\"anchor\" href=\"#除法\">#</a> 除法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174335704.png\" alt=\"image-20221013174335704\" /></p>\n<p>x 和 y 可能都是 0，可能会报错或者是正负无穷</p>\n<p>对于除法来说，只有左规。【1.x/ 1.x 】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174656673.png\" alt=\"image-20221013174656673\" /></p>\n<h3 id=\"精度保护\"><a class=\"anchor\" href=\"#精度保护\">#</a> 精度保护</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174820265.png\" alt=\"image-20221013174820265\" /></p>\n<p>y 需要左移一位对齐，所以最后一位 1 在不使用附加位的情况下会丢失。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013175053246.png\" alt=\"image-20221013175053246\" /></p>\n<p>一般而言，多余位的值超过了最低可表示位值的一半，则进位。</p>\n<p>重点关注 “10” 强制结果为偶数的分类讨论。如果结果的最低可表示位是 1，结果向上入；当最低可表示位是 0，结果向下入。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013175347832.png\" alt=\"image-20221013175347832\" /></p>\n<p>朝 0 摄入，被截断值的幅值总是小于或等于更精确原值的幅值，在计算中产生一致的向下偏差。</p>\n<h3 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014105545840.png\" alt=\"image-20221014105545840\" /></p>\n<p>x == (int)(float) x</p>\n<p>int 型有 32 位，但是 float 精度只能保存 24 位，会有精度的损失。</p>\n<p>x * x &gt;=  0 否</p>\n<p><strong>(D + F)  - D == F 什么时候不成立？</strong></p>\n<p>右边计算出来为 double 型，左边是 float</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">+</span> f <span class=\"token operator\">-</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>对于此例情况，当<strong> i 大于 53 或等于 - 53</strong> 时，会输出。</p>\n<p>因为此时 f 相对于 d 较小，相当于 0。</p>\n<p>补充：双精度 64（1+11+52）小数部分有 <code>52</code>  位。别的情况，i 会有不同的值对应。</p>\n<ol>\n<li>\n<p>i 大于 53 的情况</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190250710.png\" alt=\"image-20221018190250710\" /></p>\n<p>舍入位虽然是 10，但前置位已经是 0（偶数），因此不进位，所以有精度的丢失。</p>\n</li>\n<li>\n<p>i 等于 - 53 的情况</p>\n</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190243583.png\" alt=\"image-20221018190243583\" /></p>\n<p>​\t\t舍入位是 10，前置位是 1，因此要进位，从而造成了误差。</p>\n<p>只要有精度的丢失，就是 “否”</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/04/COA/Lecture04-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/04/COA/Lecture04-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "title": "Lecture04-整数运算",
            "date_published": "2022-10-04T13:32:43.000Z",
            "content_html": "<p>整数的加减乘除计算的实现。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"整数运算\"><a class=\"anchor\" href=\"#整数运算\">#</a> 整数运算</h1>\n<h2 id=\"算术逻辑单元alu\"><a class=\"anchor\" href=\"#算术逻辑单元alu\">#</a> 算术逻辑单元 ALU</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110026189.png\" alt=\"image-20221012110026189\" /></p>\n<p>寄存器存储数据、结果、flags</p>\n<p>控制器控制 ALU 操作和数据传入的信号</p>\n<h2 id=\"全加器\"><a class=\"anchor\" href=\"#全加器\">#</a> 全加器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110035166.png\" alt=\"image-20221012110035166\" /></p>\n<p><strong>关注与或异或的符号</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110051989.png\" alt=\"image-20221012110051989\" /></p>\n<p><strong>计算结果和进位</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110059850.png\" alt=\"image-20221012110059850\" /></p>\n<p>F 可以理解为，是奇数个 1 的时候，结果为 1；是偶数个 1 的时候，结果为 0。</p>\n<p>进位则是，有两个 1 的时候即可进位。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110111693.png\" alt=\"image-20221012110111693\" /></p>\n<p>异或门只能有<strong>两个</strong>输入端，异或门的时延<strong>不一定为 3ty</strong>。</p>\n<p>在网上找了一些实现异或的方法，可以看出，时延可以是 2ty 也可以是 3ty，应该是由异或门实现的方式决定的。</p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log29.gif\" alt=\"logic equivalent\" /></p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log30.gif\" alt=\"implimentation using NAND\" /></p>\n<p>非门算不算时延？ <strong>非门算时延</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110147229.png\" alt=\"image-20221012110147229\" /></p>\n<p>减少了一个与门，但是时延仍然是 6ty</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110159471.png\" alt=\"image-20221012110159471\" /></p>\n<p>这里可以解释为，因为 X 和 Y 的或和异或仅在 X、Y 均为 1 时不同，但 X、Y 均为 1 时，前面的与为 1，并不影响结果，所以两个式子相等。</p>\n<h2 id=\"串行进位行波进位加法器\"><a class=\"anchor\" href=\"#串行进位行波进位加法器\">#</a> 串行进位（行波进位）加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110210316.png\" alt=\"image-20221012110210316\" /></p>\n<p>公式来源于前面的全加法器，理解一样。</p>\n<p>需要等待 “进位输出信号”，所以缺点是延迟慢。</p>\n<h2 id=\"全先行进位加法器\"><a class=\"anchor\" href=\"#全先行进位加法器\">#</a> 全先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110215735.png\" alt=\"image-20221012110215735\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110224827.png\" alt=\"image-20221012110224827\" /></p>\n<p>不需要等待 n-1 位算完，就可以开始计算第 n 位，把能计算的先提前计算好。</p>\n<p>1ty：Gi 和 Pi 的计算，Gi 和 Pi 的计算可以同时进行，只需要 1ty</p>\n<p>2ty：计算 C 的值，因为需要先进行与操作，再进行或操作，所以需要 2ty，因为 Ci 只和 P\\G\\C0 的值有关，所以不需要等前一位的进位算好。</p>\n<p>3ty：Xi 和 Yi 的异或可在前三个时延做好，只需要再和 Ci-1 做异或即可算出 F。</p>\n<h2 id=\"部分先行进位加法器\"><a class=\"anchor\" href=\"#部分先行进位加法器\">#</a> 部分先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110230663.png\" alt=\"image-20221012110230663\" /></p>\n<p>加法器延迟过于严重，但是全先行进位又难以实现，所以采用了两者的混合杂交。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110240165.png\" alt=\"image-20221012110240165\" /></p>\n<p>3ty：第一个全先行加法器需要算出 G、P，耗时 1ty；然后需要算出所有的进位，耗时 2ty；与此同时，其他三个 CLA 也算好了自己的 G 和 P。</p>\n<p>2ty：第二个 CLA 收到 Cin 之后，需要 2ty 计算 Cout。</p>\n<p>2ty：同上，为第三个 CLA 的计算。</p>\n<p>5ty：2ty+3ty，第四个 CLA 计算 C 需要 2ty，然后再和 X、Y 进行异或操作，需要 3ty。在此之前，其余的 CLA 已经完成了异或计算。</p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110246821.png\" alt=\"image-20221012110246821\" /></p>\n<p>溢出的情况只能是两个正的变成负的，或者两个负的变成正的。</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>C</th>\n<th>Fn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<p>判断是否溢出的 flag 就是在 Cn-1 和 Cn 上加一个异或器</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>Cn-1</th>\n<th>Cn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110254314.png\" alt=\"image-20221012110254314\" /></p>\n<p>减法就是在加法器上加一个选择器，sub 给一个信号</p>\n<h2 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110300471.png\" alt=\"image-20221012110300471\" /></p>\n<p>实际上，加法和移位可以合并，因为始终上升沿到来之前，各寄存器中的数据会被取出，因此不需要 2-3 个时钟周期，1 个时钟周期即可完成。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110306067.png\" alt=\"image-20221012110306067\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110312495.png\" alt=\"image-20221012110312495\" /></p>\n<p>由于乘法会出现溢出的问题，所以出现了原码一位乘法和布斯算法。</p>\n<h3 id=\"原位一位乘法\"><a class=\"anchor\" href=\"#原位一位乘法\">#</a> 原位一位乘法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110326698.png\" alt=\"image-20221012110326698\" /></p>\n<h3 id=\"补码一位乘法布斯算法\"><a class=\"anchor\" href=\"#补码一位乘法布斯算法\">#</a> 补码一位乘法：布斯算法</h3>\n<h4 id=\"基本思路和证明\"><a class=\"anchor\" href=\"#基本思路和证明\">#</a> 基本思路和证明</h4>\n<p>每次根据两位决定直接移位 / 加 / 减（共四种情况）</p>\n<ol>\n<li>00、11—— 直接移位</li>\n<li><strong>10</strong> —— 减</li>\n<li><strong>01</strong> —— 加</li>\n</ol>\n<h4 id=\"黑书证明\"><a class=\"anchor\" href=\"#黑书证明\">#</a> 黑书证明</h4>\n<p>用 **2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup>** 可以表示正乘数和负乘数</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221009234843548.png\" alt=\"image-20221009234843548\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221009235208579.png\" alt=\"image-20221009235208579\" /></p>\n<h4 id=\"ppt证明\"><a class=\"anchor\" href=\"#ppt证明\">#</a> PPT 证明</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110337646.png\" alt=\"image-20221012110337646\" /></p>\n<p>为什么可以这样用布斯算法计算？</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/6D18DEB3A3D802AB3B7AE9DB900A475C.png\" alt=\"img\" /><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110345029.png\" alt=\"image-20221012110345029\" /></p>\n<h4 id=\"易错点算数移位\"><a class=\"anchor\" href=\"#易错点算数移位\">#</a> 易错点：算数移位</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110426386.png\" alt=\"image-20221012110426386\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110429745.png\" alt=\"image-20221012110429745\" /></p>\n<p>错误原因：补位负数补 1，不论是何种情况，右移都使得 A 的最左位，即 A<sub>n-1</sub> 不仅移入 A<sub>n-2</sub> 中，而且还保留在 A<sub>n-1</sub> 中。这是为了保持 A 和 Q 中数的符号，因为它<strong>保留了符号位</strong>，所以被称为<strong>算数移位</strong>。</p>\n<p>实际上，根据黑书，应该还有一位 Q<sub>-1</sub> 寄存器，放在 Q 最低有效位的右边，负责保存丢失的那位。</p>\n<h3 id=\"乘法溢出\"><a class=\"anchor\" href=\"#乘法溢出\">#</a> 乘法溢出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110434583.png\" alt=\"image-20221012110434583\" /></p>\n<p>带符号整数：因为乘法的补位是根据当前最高位计算的，如果有变化，则说明有溢出</p>\n<p>无符号整数：无符号整数应该没有 1 的出现</p>\n<h2 id=\"除法\"><a class=\"anchor\" href=\"#除法\">#</a> 除法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013100038320.png\" alt=\"image-20221013100038320\" /></p>\n<p>不同的高级算法对于 1/0 0/0 的计算结果处理是不同的</p>\n<p>如在 js 中，1/0 为正无穷；c 中会报错</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110438424.png\" alt=\"image-20221012110438424\" /></p>\n<p>在十进制除法中，需要用到乘法；在二进制中则不需要。</p>\n<p>除数和被除数符号不一样时，不同的编程语言也会得到不一样的答案。</p>\n<p>注意补齐被除数的符号位，从<strong>次高位</strong>开始计算。</p>\n<h3 id=\"除法器\"><a class=\"anchor\" href=\"#除法器\">#</a> 除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110445518.png\" alt=\"image-20221012110445518\" /></p>\n<p>对应于手工进行除法运算，</p>\n<p>因为需要补全被除数的位数，所以需要 2n 寄存器；</p>\n<p>因为除数相对于被除数的次高位开始移动，所以需要 2n 位支持右移的寄存器；</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110451162.png\" alt=\"image-20221012110451162\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110454561.png\" alt=\"image-20221012110454561\" /></p>\n<p>除法流程图 —— “是否为第<strong> N+1</strong> 次循环”</p>\n<p>和乘法不同 ——<strong>N</strong> 次循环</p>\n<p><strong>如何做优化？</strong></p>\n<p>常见的思路 —— 并行操作 / 硬件节省</p>\n<blockquote>\n<p>不能够做并行操作</p>\n<p>可以做一些硬件的优化</p>\n</blockquote>\n<h3 id=\"优化的除法器\"><a class=\"anchor\" href=\"#优化的除法器\">#</a> 优化的除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110458490.png\" alt=\"image-20221012110458490\" /></p>\n<h3 id=\"异号的除法如何处理\"><a class=\"anchor\" href=\"#异号的除法如何处理\">#</a> 异号的除法如何处理？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110504455.png\" alt=\"image-20221012110504455\" /><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110514117.png\" alt=\"image-20221012110514117\" /></p>\n<p>结果都是<strong>和余数进行比较</strong>，操作之后，如果相对于余数的符号改变，则不够；如果相对于余数的符号不变，则够。</p>\n<p>例子：</p>\n<p>可以对照上下（36、37）两张图理解异号的除法，</p>\n<p>被除数为 11111001，它的值为 - 7</p>\n<ol>\n<li>1111 + 0011 为 10010 符号改变</li>\n<li>1110 + 0011 为 10001 符号改变</li>\n<li>1100 + 0011 为 1111 符号不变，且绝对值减小，因此可以加，且商上 1</li>\n<li>1111 + 0011 符号改变</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221010003001858.png\" alt=\"img\" /></p>\n<p>参考黑书的话，</p>\n<p>余数的符号 = 被除数</p>\n<p>商的符号 = 被除数 * 除数</p>\n<p>因此，此题中，商和余数都需要取负数，所以商要取补码</p>\n<h3 id=\"补码除法运算过程\"><a class=\"anchor\" href=\"#补码除法运算过程\">#</a> 补码除法运算过程</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110521683.png\" alt=\"image-20221012110521683\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110524618.png\" alt=\"image-20221012110524618\" /></p>\n<h3 id=\"不恢复余数除法\"><a class=\"anchor\" href=\"#不恢复余数除法\">#</a> 不恢复余数除法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110534163.png\" alt=\"image-20221012110534163\" /></p>\n<p>可以参考之前的恢复余数的操作理解</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110539289.png\" alt=\"image-20221012110539289\" /></p>\n<p>如何理解大致思路：</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/4C93EBA825F2B3B083A9B5CC5D1E567D.png\" alt=\"img\" /></p>\n<p>由下面的通式表示：</p>\n<p><strong>ri+1=2ri+(1-2Qi)Y</strong></p>\n<blockquote>\n<p>式中 Qi 为第 i 次所得的商，若部分余数为正，则 Qi=1，部分余数左移一位，下一次继续减除数；若部分余数为负，则 Qi=0，部分余数左移一位，下一次加除数。由于加减运算交替地进行，故称为原码加减交替法。</p>\n</blockquote>\n<h3 id=\"补码不恢复余数除法流程图\"><a class=\"anchor\" href=\"#补码不恢复余数除法流程图\">#</a> 补码不恢复余数除法流程图</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221006172646381.png\" alt=\"img\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110545429.png\" alt=\"image-20221012110545429\" /></p>\n<p>同号说明 “够大”，异号说明 “不够大”</p>\n<p>注意不恢复余数补码除法分为两个流程，首先需要判断符号然后初始化。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110550193.png\" alt=\"image-20221012110550193\" /></p>\n<p><strong>计算流程</strong>理解：</p>\n<p>流程一：因为余数和除数异号，所以采用加的方式。加完后发现同号（实际上是由异号变为同号），补 1，实际上是取反的操作。</p>\n<p>流程二：根据 X 和 Y 是否同号，继续操作。</p>\n<p><strong>关于商的修正</strong>：</p>\n<p>Z 左移一位，根据是否够加，上 1 或 0。</p>\n<p>如果被除数和除数异号，说明商是负数。在求每一位的时候，已经取了反，因此再加 1 即可。这样的操作，比最后再计算商的总体的补码简单。</p>\n<p><strong>关于余数的修正</strong>：</p>\n<p>余数和被除数的符号相同。</p>\n<p>如果符号不同，则说明余数多加 / 多减了一个除数。如果被除数和除数的符号相同，说明余数和除数符号不相同，加上除数进行修正；如果被除数和除数符号不同，说明余数和除数符号相同，减去除数进行修正。</p>\n<p>在最后多加了一个 Y</p>\n<p>符号位，不恢复余数补码除法运算和除数比，恢复的和被除数相比</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110557310.png\" alt=\"image-20221012110557310\" /></p>\n<p>因为除法器效率不高，所以用右移运算实现简化</p>\n<p>能整除的时候，被移除的全为 0；</p>\n<p>不能整除的时候，移除的数存在非 0，</p>\n<p>-14/4 负数补位 1</p>\n<h3 id=\"阵列除法器\"><a class=\"anchor\" href=\"#阵列除法器\">#</a> 阵列除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110601896.png\" alt=\"image-20221012110601896\" /></p>\n<p>实际生活中并不是斜着排列的</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110605353.png\" alt=\"image-20221012110605353\" /></p>\n<p>全加器是两个半加器组合起来的，半加器不考虑进位。</p>\n<p>全加器算了两次 X+Y：第一次 X+Y 得到 Z，第二次 Z+Cin 得到结果。</p>\n<p>注意各整数运算的优化过程</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture03-数据的机器级表表示",
            "date_published": "2022-09-22T23:41:11.000Z",
            "content_html": "<p>仅记录有用部分，课件详细内容在 ppt 上已经很清楚了。</p>\n<p>需要加强的地方：二进制转十进制，十进制转二进制，补码的模不懂，静默式和通知式，非规格化数不懂、精度保护中的舍入看不懂，大端小端</p>\n<p>好难…… 呜呜看不懂</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"第一次作业讲解\"><a class=\"anchor\" href=\"#第一次作业讲解\">#</a> 第一次作业讲解</h2>\n<p>作业 1：. 为什么速率的总和没有意义？</p>\n<p>作业 2：指令集结构不同的计算机，只比较 MIPS 是没有意义的，例如此题当中，A 的 MIPS 大，但是运行时间较长。</p>\n<p>作业 3：采用不同指令集、<strong>流水线</strong>和并行</p>\n<p>作业 4：MIPS 求和有意义吗？</p>\n<p>组织不可见，结构可见</p>\n<h1 id=\"lecture0304-数据的机器级表示\"><a class=\"anchor\" href=\"#lecture0304-数据的机器级表示\">#</a> lecture03/04 - 数据的机器级表示</h1>\n<p>参考紫书第 2 章 / 黑书第 9 章 计算机算数</p>\n<h2 id=\"课堂ppt结合黑书版本\"><a class=\"anchor\" href=\"#课堂ppt结合黑书版本\">#</a> 课堂 /ppt—— 结合黑书版本</h2>\n<h3 id=\"信息的二进制编码\"><a class=\"anchor\" href=\"#信息的二进制编码\">#</a> 信息的二进制编码</h3>\n<h3 id=\"整数的二进制表示\"><a class=\"anchor\" href=\"#整数的二进制表示\">#</a> 整数的二进制表示</h3>\n<h4 id=\"无符号整数\"><a class=\"anchor\" href=\"#无符号整数\">#</a> 无符号整数</h4>\n<h4 id=\"有符号整数\"><a class=\"anchor\" href=\"#有符号整数\">#</a> 有符号整数</h4>\n<h5 id=\"原码-符号幅值表示法\"><a class=\"anchor\" href=\"#原码-符号幅值表示法\">#</a> 原码 符号幅值表示法</h5>\n<p>符号位不同，数值位相同</p>\n<p>不同位长间的转换：符号位左移，空余的填补 0</p>\n<p>浮点数的尾数用原码定点小数表示</p>\n<p>零的表示不唯一，不利于程序员编程</p>\n<h5 id=\"反码\"><a class=\"anchor\" href=\"#反码\">#</a> 反码</h5>\n<p>符号位和数值位均取反</p>\n<h5 id=\"移码\"><a class=\"anchor\" href=\"#移码\">#</a> 移码</h5>\n<p>是一种有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbmVkX251bWJlcl9yZXByZXNlbnRhdGlvbg==\">符号数表示</span>的方法，其中有符号数 n 是由对应于<strong>无符号数 n + K</strong> 的位模式表示，K 是<em>偏置值</em>或<em>偏移量</em>。</p>\n<p>bias 通常取 2 的 n-1 次方或者 2 的 n-1 次方减 1<br />\n 当 bias 为 2 的 n-1 次方时，移码和补码仅第一位不同，0 的表示唯一<br />\n<strong>浮点数的阶用移码表示</strong>：当两个数都是负数的时候，移码更容易比较</p>\n<h5 id=\"补码\"><a class=\"anchor\" href=\"#补码\">#</a> 补码</h5>\n<p>计算机处理中，<strong>通常使用补码</strong><br />\n负数的数值部分 <strong>各位取反，末尾加 1</strong></p>\n<p>不同位长间的转换：符号位移到最左位，其余空出位用符号位的值替代</p>\n<p>加和减的统一：<br />\n一个负数的补码等于模减该负数的绝对值<br />\n对于一个确定的模，某数减去小于模的另一数，总可以加上另一数负数的补码来代替。</p>\n<p><strong>求真值的补码</strong></p>\n<p>全 0：0</p>\n<p>全 1：-1</p>\n<p>10000...：- 2 <sup>n-1</sup></p>\n<p><strong>求补码的真值</strong></p>\n<p>**X = - x<sub>n-1</sub> * 2 <sup>n-1</sup> + ... + x <sub>2</sub> * 2 <sup>1</sup>+ x <sub>1</sub>*2<sup>0</sup> **</p>\n<p><strong>若对负数的补码再取负，得到原来那个数</strong>【其中的特例是，-2<sup>n-1</sup> 在取负之后仍然为本身，因为范围内并没有 2<sup>n-1</sup> 与之相对应】</p>\n<h3 id=\"浮点数\"><a class=\"anchor\" href=\"#浮点数\">#</a> 浮点数</h3>\n<p>单精度 32 位（1+8+23）<strong>仍然表示 2<sup>32</sup> 个数</strong></p>\n<p>双精度 64 位（1+11+52）</p>\n<p>基底为 2（也存在基底为 16 的情况）—— 基数越大，范围越大，精度越低</p>\n<h4 id=\"表示方法\"><a class=\"anchor\" href=\"#表示方法\">#</a> 表示方法</h4>\n<p>S E M</p>\n<ol>\n<li>\n<p>符号位</p>\n</li>\n<li>\n<p>8 位移码表示阶码（指数） —— 范围为 - 126~127，全 0 和全 1 为特殊值</p>\n</li>\n<li>\n<p>23 位原码表示 24 位尾数，最高位总为 1</p>\n</li>\n</ol>\n<h4 id=\"表示的数\"><a class=\"anchor\" href=\"#表示的数\">#</a> 表示的数</h4>\n<p><strong>规格化数</strong>，关注上溢出和下溢出，</p>\n<p>下溢出部分用<strong>非格式化数</strong>表示，它的间距是等距的</p>\n<p>越靠近原点，数越密集；越远离原点，数越稀疏</p>\n<p><strong>静默式和通知式非数</strong> —— 静默式表示未定义的算数结果，通知式非数表示未初始化的值。</p>\n<h2 id=\"计算机组成与体系结构性能设计\"><a class=\"anchor\" href=\"#计算机组成与体系结构性能设计\">#</a> 计算机组成与体系结构：性能设计</h2>\n<h3 id=\"整数的加法与减法补码\"><a class=\"anchor\" href=\"#整数的加法与减法补码\">#</a> 整数的加法与减法（补码）</h3>\n<p>上溢规则</p>\n<p>减法规则 —— 减法，即加上减数的 2 的补</p>\n<p>在实际的操作中，有 OF 溢出位记录是否溢出</p>\n<h3 id=\"整数的乘法\"><a class=\"anchor\" href=\"#整数的乘法\">#</a> 整数的乘法</h3>\n<h4 id=\"无符号整数的乘法\"><a class=\"anchor\" href=\"#无符号整数的乘法\">#</a> 无符号整数的乘法</h4>\n<p>两个 n 为二进制整数的乘法可产生最大长度为 2n 位的积</p>\n<p>乘</p>\n<p>移位</p>\n<p>计数 - 1</p>\n<h4 id=\"有符号整数的乘法\"><a class=\"anchor\" href=\"#有符号整数的乘法\">#</a> 有符号整数的乘法</h4>\n<p>只要有一个是负数，原来的方法就不奏效</p>\n<ol>\n<li>\n<p>把被乘数和乘数都转变成正数再相乘，当两者初始的符号不相同时，结果取 2 的补</p>\n</li>\n<li>\n<p>布斯（Booth）算法</p>\n<p>分为 10 01 【00 11】三种情况讨论</p>\n<p>运用公式，   <strong>2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup></strong></p>\n<p>很巧妙，优雅，实在是太优雅了！</p>\n</li>\n</ol>\n<h3 id=\"整数的除法\"><a class=\"anchor\" href=\"#整数的除法\">#</a> 整数的除法</h3>\n<p>搞来搞去，也很优雅</p>\n<h3 id=\"浮点数加法和减法\"><a class=\"anchor\" href=\"#浮点数加法和减法\">#</a> 浮点数加法和减法</h3>\n<ol>\n<li>检查 0</li>\n<li>对齐有效值</li>\n<li>加法</li>\n<li>规格化</li>\n</ol>\n<p>注意时时检查是否有效值为 0，以及是否溢出</p>\n<p>若两个数的阶值差别非常大，则较小的数丢失</p>\n<h3 id=\"浮点数乘法和除法\"><a class=\"anchor\" href=\"#浮点数乘法和除法\">#</a> 浮点数乘法和除法</h3>\n<p>由于阶值是移码的形式，相乘的时候，两个阶值的和要减去一个偏移量，相除的时候，两个阶值的差要加上一个偏移量</p>\n<h4 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h4>\n<ol>\n<li>\n<p>保护位</p>\n<p>对齐的时候会导致丢失，在末尾增加保护位，可以扩展有效值的右端</p>\n</li>\n<li>\n<p>舍入（不懂）</p>\n</li>\n</ol>\n<h2 id=\"计算机组成与系统结构习题解答和教学指导\"><a class=\"anchor\" href=\"#计算机组成与系统结构习题解答和教学指导\">#</a> 计算机组成与系统结构习题解答和教学指导</h2>\n<h3 id=\"数据的表示\"><a class=\"anchor\" href=\"#数据的表示\">#</a> 数据的表示</h3>\n<ul>\n<li>\n<p>数值数据 —— 二进制、十进制（BCD binary coded decimal）</p>\n</li>\n<li>\n<p>非数值数据</p>\n</li>\n</ul>\n<h3 id=\"数据的宽度\"><a class=\"anchor\" href=\"#数据的宽度\">#</a> 数据的宽度</h3>\n<p>数据容量和宽度</p>\n<p>比特</p>\n<p>字节</p>\n<p>字（2 个 / 4 个 / 8 个 / 16 个字节）</p>\n<h3 id=\"数据的排列\"><a class=\"anchor\" href=\"#数据的排列\">#</a> 数据的排列</h3>\n<ul>\n<li>大端排列 —— 最低有效字节 LSB 存放在大地址单元中，MSB 所在地址为数据的地址</li>\n<li>小端排列 —— 最低有效字节 LSB 存放在小地址单元中，LSB 所在地址为数据的地址</li>\n</ul>\n<h3 id=\"数据校验方式\"><a class=\"anchor\" href=\"#数据校验方式\">#</a> 数据校验方式</h3>\n<ul>\n<li>\n<p>奇偶校验</p>\n</li>\n<li>\n<p>海明校验</p>\n</li>\n<li>\n<p>循环冗余码校验</p>\n</li>\n</ul>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "Lecture02-计算机体系结构的问题及解决方案",
            "date_published": "2022-09-15T10:01:24.000Z",
            "content_html": "<p>讲述了六个计算机体系结构的问题以及解决方案<br />\n<span id=\"more\"></span></p>\n<h2 id=\"冯诺依曼最重要的思想存储程序\"><a class=\"anchor\" href=\"#冯诺依曼最重要的思想存储程序\">#</a> 冯诺依曼最重要的思想 —— 存储程序</h2>\n<p>任何要计算机完成的工作都要先被编写成程序，然后将<strong>程序和原始数据送入主存</strong>并启动执行。一旦程序被启动，计算机应能在不需要操作人员干预下，自动完成逐条取出指令和执行指令的任务。</p>\n<p>区分中央处理单元（CPU）和处理器。</p>\n<p>CPU 的制作工艺逐渐在提高，几乎不变的是 CPU 的大小，一直在增加的是晶体管的数量。</p>\n<p>目前，苹果 M2 以及可以集成 200 亿的晶体管。</p>\n<h2 id=\"问题与解决思路\"><a class=\"anchor\" href=\"#问题与解决思路\">#</a> 问题与解决思路</h2>\n<h3 id=\"可以通过无限增加cpu的大小来增加性能嘛\"><a class=\"anchor\" href=\"#可以通过无限增加cpu的大小来增加性能嘛\">#</a> 可以通过无限增加 CPU 的大小来增加性能嘛？</h3>\n<p>不可以，面积越大，意味着<strong>互联延迟</strong>越大。一个时钟周期需要大于最长互联延迟。存在物理极限。</p>\n<h3 id=\"问题1cpu的频率不能无限提高\"><a class=\"anchor\" href=\"#问题1cpu的频率不能无限提高\">#</a> 问题 1：CPU 的频率不能无限提高</h3>\n<p>MOS 管开关、脉冲通过门电路需要时间</p>\n<p>为了信号同步，每个脉冲信号需要持续一定的时间</p>\n<p>面积大，连线延迟大；</p>\n<p>频率越高，开关损耗高，CPU 耗电和散热提高；</p>\n<h3 id=\"解决1改变cpu芯片结构\"><a class=\"anchor\" href=\"#解决1改变cpu芯片结构\">#</a> 解决 1：改变 CPU 芯片结构</h3>\n<ol>\n<li>\n<p>采用各种技术，对芯片体系结构进行优化：指令流水线、每周期多条指令、cache、更长流水线和双速算术</p>\n</li>\n<li>\n<p>领域定制，如面向人工智能的芯片</p>\n</li>\n</ol>\n<h3 id=\"问题2内存墙的存在-memory-wall\"><a class=\"anchor\" href=\"#问题2内存墙的存在-memory-wall\">#</a> 问题 2：内存墙的存在 memory wall</h3>\n<p>主存和 CPU 之间传输数据的速度跟不上 CPU 的速度</p>\n<h3 id=\"解决2采用高速缓存cache\"><a class=\"anchor\" href=\"#解决2采用高速缓存cache\">#</a> 解决 2：采用高速缓存（cache）</h3>\n<ol>\n<li>添加一级或多级缓存以减少存储器访问频率并提高数据传输速率</li>\n<li>增大总线的数据宽度，来增加每次所能取出的位数</li>\n</ol>\n<h3 id=\"问题3cpu等待io传输数据\"><a class=\"anchor\" href=\"#问题3cpu等待io传输数据\">#</a> 问题 3：CPU 等待 I/O 传输数据</h3>\n<p>CPU 在等待 I/O 设备时保持空闲</p>\n<h3 id=\"解决3中断\"><a class=\"anchor\" href=\"#解决3中断\">#</a> 解决 3：中断</h3>\n<p>其他模块（例如 IO）可以中断正常处理顺序的机制</p>\n<p>中断周期加入指令周期中</p>\n<p>多重中断：顺序中断处理、嵌套中断处理</p>\n<h3 id=\"问题4兼顾存储容量-速度和成本\"><a class=\"anchor\" href=\"#问题4兼顾存储容量-速度和成本\">#</a> 问题 4：兼顾存储容量、速度和成本</h3>\n<p>约束</p>\n<ul>\n<li>容量：越大越好</li>\n<li>速度：跟上处理器</li>\n<li>成本：相较于其他组件合理</li>\n</ul>\n<p>约束之间的关系</p>\n<p>​\t更短的访问时间，更高的每比特成本</p>\n<h3 id=\"解决4层次式存储结构\"><a class=\"anchor\" href=\"#解决4层次式存储结构\">#</a> 解决 4：层次式存储结构</h3>\n<p>需求</p>\n<ul>\n<li>大容量数据存储</li>\n<li>高速性能</li>\n</ul>\n<p>解决方案</p>\n<ul>\n<li>使用存储器层次结构而不是依赖单个存储器组件</li>\n</ul>\n<p><strong>寄存器 ——cache—— 主存 —— 磁盘 —— 磁带</strong></p>\n<p>存储量越来越大，速度越来越慢，离 CPU 越来越远</p>\n<h3 id=\"问题5io设备传输速率差异大\"><a class=\"anchor\" href=\"#问题5io设备传输速率差异大\">#</a> 问题 5：I/O 设备传输速率差异大</h3>\n<p>I/O 性能跟不上 CPU 速度的提升</p>\n<h3 id=\"解决5采用缓冲区和改进io操作技术\"><a class=\"anchor\" href=\"#解决5采用缓冲区和改进io操作技术\">#</a> 解决 5：采用缓冲区和改进 I/O 操作技术</h3>\n<p>设立缓存区</p>\n<h3 id=\"问题6计算机部件互连复杂\"><a class=\"anchor\" href=\"#问题6计算机部件互连复杂\">#</a> 问题 6：计算机部件互连复杂</h3>\n<h3 id=\"解决6采用总线\"><a class=\"anchor\" href=\"#解决6采用总线\">#</a> 解决 6：采用总线</h3>\n<h4 id=\"总线\"><a class=\"anchor\" href=\"#总线\">#</a> 总线</h4>\n<p>目前，对通用计算机而言，各种点对点互连结构逐渐取代总线互连的方式。但是总线结构依然普遍用于嵌入式系统。</p>\n<h5 id=\"共享\"><a class=\"anchor\" href=\"#共享\">#</a> 共享</h5>\n<p>所有部件都通过总线传递数据</p>\n<h5 id=\"分时\"><a class=\"anchor\" href=\"#分时\">#</a> 分时</h5>\n<p>只有一个部件能够传输数据</p>\n<h5 id=\"功能组\"><a class=\"anchor\" href=\"#功能组\">#</a> 功能组</h5>\n<p><strong>控制线</strong> —— 控制对数据线路与地址线路的访问和使用，控制信号传递<strong>命令和定时信息</strong>。</p>\n<p><strong>地址线</strong> —— 指定数据总线上数据的源或目的，地址总线的宽度决定了系统可能的<strong>最大内存容量</strong></p>\n<p><strong>数据线</strong> —— 为系统模块之间的数据传输提供路径，一般而言，线路的条数决定了<strong>一次能传输的位数</strong>，数据总线的宽度是决定系统整体性能的一个关键因素</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "Lecture01-计算机系统概述",
            "date_published": "2022-09-08T12:30:32.000Z",
            "content_html": "<p>第一讲，以及对于书籍的第一章重点知识点整理</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"课程随笔\"><a class=\"anchor\" href=\"#课程随笔\">#</a> 课程随笔</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<p><strong>通用 电子 数字 计算机</strong></p>\n<p>通用</p>\n<p>电子</p>\n<p>数字</p>\n<h3 id=\"组织与结构\"><a class=\"anchor\" href=\"#组织与结构\">#</a> 组织与结构</h3>\n<ol>\n<li>结构 (对于程序员是可见的)\n<ul>\n<li>一个提供乘法算法的计算机和另一个不提供乘法算法的计算机之间的区别</li>\n<li>包括：指令集、各类数据类型的大小</li>\n</ul>\n</li>\n<li>组织 (对于程序员是不可见的)\n<ul>\n<li>一个用乘法器完成乘法的计算机和一个用加法器通过算法完成乘法的计算机之间的不同。</li>\n<li>包括：控制信号、存储技术</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"计算机发展历史\"><a class=\"anchor\" href=\"#计算机发展历史\">#</a> 计算机发展历史</h2>\n<p>真空管</p>\n<p>晶体管</p>\n<p>集成电路（scale 越来越大，SSI-&gt;MSI-&gt;LSI-&gt;VLSI-&gt;ULSI）</p>\n<p>摩尔定律（集成电路芯片上集成的晶体管数将番一番，速度将提高一倍，而价格将降低一半）</p>\n<h2 id=\"冯诺依曼结构的实现与演变\"><a class=\"anchor\" href=\"#冯诺依曼结构的实现与演变\">#</a> 冯诺依曼结构的实现与演变</h2>\n<h3 id=\"cpu-北桥-南桥\"><a class=\"anchor\" href=\"#cpu-北桥-南桥\">#</a> CPU + 北桥 + 南桥</h3>\n<p>芯片近北桥，远离南桥。</p>\n<h4 id=\"南桥\"><a class=\"anchor\" href=\"#南桥\">#</a> 南桥</h4>\n<p>南桥（英语：Southbridge）是基于个人计算机主板芯片组架构中的其中一枚芯片。南桥设计用来处理<strong>低速信号</strong>，通过北桥与中央处理器联系。<br />\n南桥芯片负责 I/O 总线之间的通信，如 PCI 总线、USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等。<br />\nPCI、SATA、IDE、USB。</p>\n<h4 id=\"北桥\"><a class=\"anchor\" href=\"#北桥\">#</a> 北桥</h4>\n<p>北桥设计用来处理<strong>高速信号</strong>，通常处理中央处理器、存储器、PCI Express 显卡（早年是 AGP 显卡）、高速 PCI Express X16/X8 的端口，还有与南桥之间的通信。<br />\n芯片组（chipset）的名称就是以北桥芯片的名称来命名的。<br />\n北桥被用来处理高速信号，通常处理 CPU（处理器），RAM（内存），AGP 端口或 PCI Express, 和南桥芯片之间的通信。<br />\nPCIE/AGP、Memory、CPU。</p>\n<h3 id=\"cpu-pch集成显卡-显示部件\"><a class=\"anchor\" href=\"#cpu-pch集成显卡-显示部件\">#</a> CPU + PCH（集成显卡 - 显示部件）</h3>\n<p>PCH 全称为 Platform Controller Hub，是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9pbnRlbCVFNSU4NSVBQyVFNSU4RiVCOA==\"> intel 公司</span>的集成南桥。</p>\n<p>北桥中的内存控制器和 PCIe 控制器都集成到了 CPU 内部，相当于整个北桥芯片都集成到了 CPU 内部，主板上只剩下南桥。所以 PCH 可以理解成南桥。目前 Intel 的有些 SOC 就是连 PCH 也集成到了 CPU 内部，比如：Intel Xeon D 系列.</p>\n<h2 id=\"计算机性能\"><a class=\"anchor\" href=\"#计算机性能\">#</a> 计算机性能</h2>\n<h3 id=\"cpu性能\"><a class=\"anchor\" href=\"#cpu性能\">#</a> CPU 性能</h3>\n<p>时钟频率 / 时钟周期</p>\n<p>CPI</p>\n<p>MIPS（每秒百万条指令）</p>\n<p>MRLOPS（每秒百万条浮点操作）</p>\n<p>基准程序</p>\n<h3 id=\"性能设计的基本原则\"><a class=\"anchor\" href=\"#性能设计的基本原则\">#</a> 性能设计的基本原则</h3>\n<ul>\n<li>\n<p>大概率事件优先原则</p>\n</li>\n<li>\n<p>阿姆代尔定律 Amdahl 定律</p>\n<p>技术或设计的某一部分的加速不会导致性能产生相应的改进。性能的提高是有限度的。</p>\n</li>\n<li>\n<p>Little 定律</p>\n</li>\n</ul>\n<h1 id=\"对应书籍整理-计算机系统概述\"><a class=\"anchor\" href=\"#对应书籍整理-计算机系统概述\">#</a> 对应书籍整理 - 计算机系统概述</h1>\n<h2 id=\"计算机结构\"><a class=\"anchor\" href=\"#计算机结构\">#</a> 计算机结构</h2>\n<h3 id=\"硬件\"><a class=\"anchor\" href=\"#硬件\">#</a> 硬件</h3>\n<ol>\n<li>\n<p>CPU</p>\n<ul>\n<li>运算器 —— 各种算数逻辑运算</li>\n<li>控制器 —— 对指令译码并送出操作控制信号</li>\n</ul>\n</li>\n<li>\n<p>存储器 —— 存放指令和数据</p>\n<p>包括 ROM 芯片和 RAM 芯片。</p>\n<ul>\n<li>\n<p>内存储器</p>\n<ul>\n<li>主存</li>\n<li>高速缓存（cache）</li>\n</ul>\n</li>\n<li>\n<p>外存储器</p>\n<p>磁盘、磁带存储器、光盘存储器等</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I/O 设备 —— 计算机和用户之间的信息交换</p>\n</li>\n</ol>\n<h3 id=\"软件\"><a class=\"anchor\" href=\"#软件\">#</a> 软件</h3>\n<ol>\n<li>系统软件 —— 介于计算机硬件和应用软件之间的各种软件\n<ul>\n<li>操作系统软件</li>\n<li>语言处理系统</li>\n<li>数据库管理系统</li>\n<li>各类实用程序</li>\n</ul>\n</li>\n<li>应用软件\n<ul>\n<li>办公自动化软件</li>\n<li>互联网应用软件</li>\n<li>多媒体处理软件</li>\n<li>股票分析软件</li>\n<li>游戏软件</li>\n<li>管理信息系统</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"程序开发和执行过程\"><a class=\"anchor\" href=\"#程序开发和执行过程\">#</a> 程序开发和执行过程</h3>\n<ol>\n<li>高级语言、低级语言（汇编语言）-&gt; 机器语言</li>\n</ol>\n<p>​\t\t其中，汇编语言和机器语言程序员必须对机器的结构和指令系统等细节非常清楚。</p>\n<ol start=\"2\">\n<li>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>对应计算机用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用程序</td>\n<td>最终用户</td>\n</tr>\n<tr>\n<td>高级语言虚拟机</td>\n<td>高级语言程序员或者应用程序员</td>\n</tr>\n<tr>\n<td>汇编语言虚拟机</td>\n<td>汇编语言程序员</td>\n</tr>\n<tr>\n<td>操作系统虚拟机</td>\n<td>系统管理员</td>\n</tr>\n<tr>\n<td>机器语言虚拟机</td>\n<td>机器语言程序员</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>源程序</strong>通过<strong>编译程序和汇编程序</strong>得到<strong>目标程序</strong></p>\n</li>\n<li>\n<p>编译程序 vs 解释程序（编译程序生成机器码，解释程序生成后立即执行）</p>\n</li>\n</ol>\n<h3 id=\"cpu性能-2\"><a class=\"anchor\" href=\"#cpu性能-2\">#</a> CPU 性能</h3>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        }
    ]
}