{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io",
    "items": [
        {
            "id": "https://quas-modo.github.io/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/",
            "url": "https://quas-modo.github.io/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/",
            "title": "Lecture07-存储器",
            "date_published": "2022-10-24T05:30:15.000Z",
            "content_html": "<p>存储器相关，聚焦于半导体存储器，主要分为读写存储器、只读存储器以及读为主的存储器。接着叙述芯片逻辑，以及芯片优化。<br />\n<span id=\"more\"></span></p>\n<h2 id=\"回顾存储器\"><a class=\"anchor\" href=\"#回顾存储器\">#</a> 回顾：存储器</h2>\n<h2 id=\"回顾存储器-2\"><a class=\"anchor\" href=\"#回顾存储器-2\">#</a> 回顾：存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221020163158122.png\" alt=\"image-20221020163158122\" /></p>\n<p>1Byte（字节） = 8 bit（比特）</p>\n<p>1 字 可能是 4 字节，也可能是 8 字节。根据计算机是 32 位还是 64 位有所不同，不同计算机有不同的字长。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171557660.png\" alt=\"image-20221101171557660\" /></p>\n<h2 id=\"存储器层次结构\"><a class=\"anchor\" href=\"#存储器层次结构\">#</a> 存储器层次结构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221021202852887.png\" alt=\"image-20221021202852887\" /></p>\n<h2 id=\"半导体存储器\"><a class=\"anchor\" href=\"#半导体存储器\">#</a> 半导体存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124316886.png\" alt=\"image-20221024124316886\" /></p>\n<p><strong>半导体</strong></p>\n<p>位元 存储 1 位数据</p>\n<h3 id=\"半导体存储器类型\"><a class=\"anchor\" href=\"#半导体存储器类型\">#</a> 半导体存储器类型</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124432370.png\" alt=\"image-20221024124432370\" /></p>\n<p>表中列出的而<strong>所有类型的存储器都是随机存取</strong>的。</p>\n<p>快闪 flash——U 盘是其中的一种。</p>\n<h3 id=\"读-写存储器随机存取存储器ram\"><a class=\"anchor\" href=\"#读-写存储器随机存取存储器ram\">#</a> 读 - 写存储器 —— 随机存取存储器 RAM</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124536588.png\" alt=\"image-20221024124536588\" /></p>\n<p>RAM 的明显特征是，可以<strong>方便快捷</strong>地从存储器读取数据和向存储器写入新数据，且读写操作都是通过使用<strong>电信号</strong>来实现的。</p>\n<p><strong>易失</strong> —— 必须持续供电，一旦断电，数据就会丢失。</p>\n<h4 id=\"sram-静态ram\"><a class=\"anchor\" href=\"#sram-静态ram\">#</a> SRAM 静态 RAM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124554411.png\" alt=\"image-20221024124554411\" /></p>\n<p>CS 片送</p>\n<p>RW 控制读写</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124714978.png\" alt=\"image-20221024124714978\" /></p>\n<p>推导过程</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130157726.png\" alt=\"image-20221024130157726\" /></p>\n<h4 id=\"dram-动态ram\"><a class=\"anchor\" href=\"#dram-动态ram\">#</a> DRAM 动态 RAM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124958784.png\" alt=\"image-20221024124958784\" /></p>\n<p>通过电容充电来存储数据。</p>\n<p>电容器有漏电趋势，动态 RAM 需要周期地充电刷新来维持数据的存储。</p>\n<p>动态一词就是在描述存储电荷丢失的趋势，即使电源一直在供电。</p>\n<h4 id=\"sram与dram的对比\"><a class=\"anchor\" href=\"#sram与dram的对比\">#</a> SRAM 与 DRAM 的对比</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024125105338.png\" alt=\"image-20221024125105338\" /></p>\n<p>DRAM 密度高，价格便宜，趋向于满足大容量存储器的要求。但是 SRAM 更快。</p>\n<p>SRAM 一般用于 cache 存储器（片上或者片外的）【CPU 中】，而 DRAM 则用于主存储器中。</p>\n<h3 id=\"只读存储器\"><a class=\"anchor\" href=\"#只读存储器\">#</a> 只读存储器</h3>\n<h4 id=\"rom-只读存储器\"><a class=\"anchor\" href=\"#rom-只读存储器\">#</a> ROM 只读存储器</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130516422.png\" alt=\"image-20221024130516422\" /></p>\n<p>问题补充：固化数据需要较大的固定成本，无论是制造一片或者复制上千片特殊的 ROM。但是可以通过批量生产降低单片芯片的成本。</p>\n<h4 id=\"可编程romprom\"><a class=\"anchor\" href=\"#可编程romprom\">#</a> 可编程 ROM（PROM）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130821252.png\" alt=\"image-20221024130821252\" /></p>\n<p>需要少量的存储特定内容的 ROM 芯片，可以选择较为廉价的可编程 PROM</p>\n<p>可由供应商或者用户在芯片出厂后写入一次、</p>\n<h3 id=\"主要进行读操作的存储器\"><a class=\"anchor\" href=\"#主要进行读操作的存储器\">#</a> 主要进行读操作的存储器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131021140.png\" alt=\"image-20221024131021140\" /></p>\n<h4 id=\"eprom\"><a class=\"anchor\" href=\"#eprom\">#</a> EPROM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131047438.png\" alt=\"image-20221024131047438\" /></p>\n<p>使芯片暴露在紫外线辐射下使所有的存储位元都被擦除，没有办法做到很精确，因此是芯片级的可擦除性。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131226634.png\" alt=\"image-20221024131226634\" /></p>\n<h4 id=\"eeprom\"><a class=\"anchor\" href=\"#eeprom\">#</a> EEPROM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131245626.png\" alt=\"image-20221024131245626\" /></p>\n<p>任何时候都可以写入，无需擦除原先内容，只更新寻址到的一个或多个字节。</p>\n<p>将非易失性和数据修改灵活的优点结合起来。修改数据只需要使用常规的控制、地址和地址总线。</p>\n<p><strong>电写入，从 1 变成 0； 电擦除，从 0 变成 1。</strong></p>\n<h4 id=\"快闪存储器\"><a class=\"anchor\" href=\"#快闪存储器\">#</a> 快闪存储器</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131457113.png\" alt=\"image-20221024131457113\" /></p>\n<p>NAND Flash 共用一条线 —— 外部存储器</p>\n<h3 id=\"各类rom对比\"><a class=\"anchor\" href=\"#各类rom对比\">#</a> 各类 ROM 对比</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131557564.png\" alt=\"image-20221024131557564\" /></p>\n<h2 id=\"芯片逻辑\"><a class=\"anchor\" href=\"#芯片逻辑\">#</a> 芯片逻辑</h2>\n<h3 id=\"从位元到主存\"><a class=\"anchor\" href=\"#从位元到主存\">#</a> 从位元到主存</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131723140.png\" alt=\"image-20221024131723140\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131744592.png\" alt=\"image-20221024131744592\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131758270.png\" alt=\"image-20221024131758270\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131957375.png\" alt=\"image-20221024131957375\" /></p>\n<p>位扩展，从 1bit 增加到 8bit，需要增加 7 根线。</p>\n<p>字扩展，从 16K 变成 64K，16K 需要 7 根线，64K 需要 8 根线【因为行列复用】，只需要增加一根线，就可以实现 16K 到 64K。</p>\n<p>1K = 2 <sup>10</sup></p>\n<p>有多少位数据，就需要有多少根数据线。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101172926489.png\" alt=\"image-20221101172926489\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132007925.png\" alt=\"image-20221024132007925\" /></p>\n<h3 id=\"如何寻址地址译码器\"><a class=\"anchor\" href=\"#如何寻址地址译码器\">#</a> 如何寻址：地址译码器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131851948.png\" alt=\"image-20221024131851948\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131815432.png\" alt=\"image-20221024131815432\" /></p>\n<p>DRAM 不用刷新，采用行列复用 —— 用 11 位分别计算出行地址和列地址进行访问， 因为 DRAM 的存储空间较大，且行列复用耗时较高，所以只在 DRAM 中使用。</p>\n<p>SRAM 且没有 RAS（行地址选通）和 CAS（列地址选通），也没有数据输入输出缓冲器，SRAM 常作为缓存，需要更快的速度。</p>\n<p>WE 写允许</p>\n<p>OE 输出允许</p>\n<h3 id=\"如何刷新\"><a class=\"anchor\" href=\"#如何刷新\">#</a> 如何刷新</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131911336.png\" alt=\"image-20221024131911336\" /></p>\n<p>集中式刷新会造成死区，影响使用，因此开发分散式刷新和异步刷新进行优化。</p>\n<p>译码阶段不需要进行缓存，每行的刷新相对独立，不需要按照顺序。</p>\n<h2 id=\"高级的dram架构\"><a class=\"anchor\" href=\"#高级的dram架构\">#</a> 高级的 DRAM 架构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132123622.png\" alt=\"image-20221024132123622\" /></p>\n<h3 id=\"同步dramsynchorounous-dram-sdram\"><a class=\"anchor\" href=\"#同步dramsynchorounous-dram-sdram\">#</a> 同步 DRAM (Synchorounous DRAM, SDRAM)</h3>\n<h3 id=\"双频率sdramdouble-data-rate-sdram\"><a class=\"anchor\" href=\"#双频率sdramdouble-data-rate-sdram\">#</a> 双频率 SDRAM (Double-Data-Rate SDRAM)</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132312999.png\" alt=\"image-20221024132312999\" /></p>\n<p>SDRAM</p>\n<p>在每一次行选之前，都需要做预充电</p>\n<p>如果下一次仍然是同一行的数据，不需要行选。</p>\n<p>在时钟上升沿才能发数据</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132326001.png\" alt=\"image-20221024132326001\" /></p>\n<p>DDR SDRAM</p>\n<p>在时钟下升沿也可以发数据</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132335364.png\" alt=\"image-20221024132335364\" /></p>\n<p>核心频率无法改变 —— 电容很难提升</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101162647755.png\" alt=\"image-20221101162647755\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101162656519.png\" alt=\"image-20221101162656519\" /></p>\n<h2 id=\"寄存器基本原理\"><a class=\"anchor\" href=\"#寄存器基本原理\">#</a> 寄存器基本原理</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164208668.png\" alt=\"image-20221101164208668\" /></p>\n<p>边沿 D 触发器，RS 锁存器以及增加了 input 和 clock（？</p>\n<p>寄存器和 CPU 的时钟同步</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132047639.png\" alt=\"image-20221024132047639\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/18/COA/Lecture06-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%8D%81%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/10/18/COA/Lecture06-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%8D%81%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture06-加减法十进制表示",
            "date_published": "2022-10-18T11:50:47.000Z",
            "content_html": "<p>十进制表示的加减法<br />\n &lt;!--more&gt;</p>\n<h1 id=\"lecture06-加减法十进制数表示\"><a class=\"anchor\" href=\"#lecture06-加减法十进制数表示\">#</a> Lecture06 加减法十进制数表示</h1>\n<h2 id=\"回顾二进制编码的十进制表示\"><a class=\"anchor\" href=\"#回顾二进制编码的十进制表示\">#</a> 回顾：二进制编码的十进制表示</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161625312.png\" alt=\"image-20221018161625312\" /></p>\n<h2 id=\"回顾补码表示整数的加减法\"><a class=\"anchor\" href=\"#回顾补码表示整数的加减法\">#</a> 回顾：补码表示整数的加减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161749133.png\" alt=\"image-20221018161749133\" /></p>\n<h3 id=\"加法溢出判定\"><a class=\"anchor\" href=\"#加法溢出判定\">#</a> 加法溢出判定</h3>\n<p>正负 进位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162304448.png\" alt=\"image-20221018162304448\" /></p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162440184.png\" alt=\"image-20221018162440184\" /></p>\n<h3 id=\"25-31-56\"><a class=\"anchor\" href=\"#25-31-56\">#</a> 25 + 31 = 56</h3>\n<p>用 0010 表示 2，用 0101 表示 5</p>\n<p>用 0011 表示 3，用 0001 表示 1</p>\n<p>个位数和十位数的和均小于 9</p>\n<h3 id=\"28-39-67\"><a class=\"anchor\" href=\"#28-39-67\">#</a> 28 + 39 = 67</h3>\n<p>0001 要再加上一个 0110 等于 0111</p>\n<p><strong>为什么加上 6？</strong></p>\n<p>二进制 10000 的第 5 位表示 16，但在十进制中实际上表示的是 10，少进了 6，所以在个位还需要再加上 6。</p>\n<h3 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163500884.png\" alt=\"image-20221018163500884\" /></p>\n<p>左边表格分别表示 10-19 的数，右边为实际的硬件实现。</p>\n<p>C4 表达式的意思是，如果（S1 和 S3 为 1）或者（S2 和 S3 为 1）则肯定大于 10，若 C4 * 为 1，则肯定大于 16。【公式中的 S1、2、3 应该有星号）</p>\n<p>C4 作为输出的同时，也对 S2 和 S1 的真正输出产生了影响。</p>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164311877.png\" alt=\"image-20221018164311877\" /></p>\n<p>9-x 不会出现借位的情况。</p>\n<h3 id=\"反转数字\"><a class=\"anchor\" href=\"#反转数字\">#</a> “反转” 数字：</h3>\n<ul>\n<li>按位反转，并添加 <code>1010</code> （10）</li>\n<li>添加 <code>0110</code> （6），并按位反转</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190527126.png\" alt=\"image-20221018190527126\" /></p>\n<h3 id=\"结果调整\"><a class=\"anchor\" href=\"#结果调整\">#</a> 结果调整</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164745084.png\" alt=\"image-20221018164745084\" /></p>\n<h4 id=\"309-125184有进位舍弃进位\"><a class=\"anchor\" href=\"#309-125184有进位舍弃进位\">#</a> 309-125=184 (有进位，舍弃进位)</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018194656730.png\" alt=\"image-20221018194656730\" /></p>\n<p>当得到的结果在 <code>10~19</code>  时，都需要进行修正。 <code>10~15</code>  时，加上 6 进行修正。</p>\n<p>例如，1110 + 0110 进 1 得到 0100. 即 13+6-16 (-10) 得到 3。</p>\n<p>有进位相当于，a-b 的时候 a&gt;b，所以 a-b = a + (999 - b) + 1 - 1000。</p>\n<h4 id=\"125-309-184无进位取反加1符号位设为负\"><a class=\"anchor\" href=\"#125-309-184无进位取反加1符号位设为负\">#</a> 125-309 = -184（无进位，取反加 1，符号位设为负）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018194641391.png\" alt=\"image-20221018194641391\" /></p>\n<p>相当于此时 a &lt; b</p>\n<p>a - b =  -[1000 - [a + (999 - b) + 1]]</p>\n<p>【以上部分可参考 Lecture05 中，尾数的原码加法示例，是一样的道理】</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164912432.png\" alt=\"image-20221018164912432\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/14/COA/Lecture05-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/14/COA/Lecture05-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/",
            "title": "Lecture05-浮点数计算",
            "date_published": "2022-10-14T02:57:07.000Z",
            "content_html": "<p>浮点数的加减乘除。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"lecture05-浮点数运算\"><a class=\"anchor\" href=\"#lecture05-浮点数运算\">#</a> Lecture05 - 浮点数运算</h1>\n<h2 id=\"回顾\"><a class=\"anchor\" href=\"#回顾\">#</a> 回顾</h2>\n<p>记忆 1+8+23 的（符号位移码原码）</p>\n<p>记忆各种情况对应的表示</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013162002689.png\" alt=\"image-20221013162002689\" /></p>\n<h2 id=\"加法和减法\"><a class=\"anchor\" href=\"#加法和减法\">#</a> 加法和减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013162704448.png\" alt=\"image-20221013162704448\" /></p>\n<ol>\n<li>\n<p>检查 0：如果有 0 存在可以不用计算</p>\n</li>\n<li>\n<p>对齐有效位：阶码向<strong>大值</strong>对齐，因为右移较小的数而丢失的数字所造成的的影响较小。右移较小的数有效值的幅值部分 1 位，并将阶值加 1。<strong>如果两个数的阶值差别非常大，则较小的数丢失</strong></p>\n</li>\n<li>\n<p>加或减有效值：<strong>原码加减法</strong></p>\n</li>\n<li>\n<p>规格化结果：把结果调整为左移有效值直到<strong>最高有效数字为非 0</strong>。</p>\n<p>（右规最多是两位，最多是 1.1111...+1.xxxx，对应有效值的上溢）</p>\n</li>\n</ol>\n<h3 id=\"溢出\"><a class=\"anchor\" href=\"#溢出\">#</a> 溢出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013164459041.png\" alt=\"image-20221013164459041\" /></p>\n<ol>\n<li>阶值上溢</li>\n</ol>\n<p>​\t\t最大允许阶值 127（11111110）</p>\n<p>​\t\t右移可能会导致阶值的上溢</p>\n<ol start=\"2\">\n<li>\n<p>阶值下溢</p>\n<p>最小阶值为 - 126（00000001）</p>\n<p>左移可能会引起阶值的下溢</p>\n</li>\n<li>\n<p>有效值的上下溢只存在于右规</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013171505053.png\" alt=\"image-20221013171503186\" /></p>\n</li>\n</ol>\n<h3 id=\"异常\"><a class=\"anchor\" href=\"#异常\">#</a> 异常</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014093204887.png\" alt=\"image-20221014093204887\" /></p>\n<p>关于<strong>数太小</strong>阶下溢的问题，在 cpp 中，如果是单精度浮点数，会用非规格化数表示，如果是双精度浮点数，会直接用 0 表示。</p>\n<h3 id=\"原码的加法\"><a class=\"anchor\" href=\"#原码的加法\">#</a> 原码的加法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013165531300.png\" alt=\"image-20221013165531300\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013165721396.png\" alt=\"image-20221013165721396\" /></p>\n<p>求补的时候加了 2 的 n 次方</p>\n<p>有进位说明 a&gt;b</p>\n<p>无进位说明 a&lt;b</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014103516514.png\" alt=\"image-20221014103516514\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013172902710.png\" alt=\"image-20221013172902710\" /></p>\n<p>01111110 ——127    23 表示有 23 个零</p>\n<p>01111101 ——126    21 表示有 21 个零</p>\n<p>差了一位，左移一位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173317582.png\" alt=\"image-20221013173317582\" /></p>\n<p>1111110 127</p>\n<p>1111101 126</p>\n<p>然后给 0.4375 取个反</p>\n<h2 id=\"乘法和除法\"><a class=\"anchor\" href=\"#乘法和除法\">#</a> 乘法和除法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013163420919.png\" alt=\"image-20221013163420919\" /></p>\n<p>注意乘法和除法的阶值计算 ——</p>\n<ul>\n<li>乘法加 bias</li>\n<li>除法减 bias</li>\n<li>bias 的值为 127【通常，移码的偏移量为 2<sup>k-1</sup> -1，移码的偏移量主要是看想表示多少个负数和多少个正数，阶码的范围是 - 126~127，-127 和 128 分别表示特殊的数】</li>\n</ul>\n<h3 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173727304.png\" alt=\"image-20221013173727304\" /></p>\n<p>对于乘法来说，只有右规。【1.x * 1.x 只可能超出】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173847536.png\" alt=\"image-20221013173847536\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174221322.png\" alt=\"image-20221013174221322\" /></p>\n<p>最高两位为 01，不用处理。</p>\n<h3 id=\"除法\"><a class=\"anchor\" href=\"#除法\">#</a> 除法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174335704.png\" alt=\"image-20221013174335704\" /></p>\n<p>x 和 y 可能都是 0，可能会报错或者是正负无穷</p>\n<p>对于除法来说，只有左规。【1.x/ 1.x 】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174656673.png\" alt=\"image-20221013174656673\" /></p>\n<h3 id=\"精度保护\"><a class=\"anchor\" href=\"#精度保护\">#</a> 精度保护</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174820265.png\" alt=\"image-20221013174820265\" /></p>\n<p>y 需要左移一位对齐，所以最后一位 1 在不使用附加位的情况下会丢失。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013175053246.png\" alt=\"image-20221013175053246\" /></p>\n<p>一般而言，多余位的值超过了最低可表示位值的一半，则进位。</p>\n<p>重点关注 “10” 强制结果为偶数的分类讨论。如果结果的最低可表示位是 1，结果向上入；当最低可表示位是 0，结果向下入。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013175347832.png\" alt=\"image-20221013175347832\" /></p>\n<p>朝 0 摄入，被截断值的幅值总是小于或等于更精确原值的幅值，在计算中产生一致的向下偏差。</p>\n<h3 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014105545840.png\" alt=\"image-20221014105545840\" /></p>\n<p>x == (int)(float) x</p>\n<p>int 型有 32 位，但是 float 精度只能保存 24 位，会有精度的损失。</p>\n<p>x * x &gt;=  0 否</p>\n<p><strong>(D + F)  - D == F 什么时候不成立？</strong></p>\n<p>右边计算出来为 double 型，左边是 float</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">+</span> f <span class=\"token operator\">-</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>对于此例情况，当<strong> i 大于 53 或等于 - 53</strong> 时，会输出。</p>\n<p>因为此时 f 相对于 d 较小，相当于 0。</p>\n<p>补充：双精度 64（1+11+52）小数部分有 <code>52</code>  位。别的情况，i 会有不同的值对应。</p>\n<ol>\n<li>\n<p>i 大于 53 的情况</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190250710.png\" alt=\"image-20221018190250710\" /></p>\n<p>舍入位虽然是 10，但前置位已经是 0（偶数），因此不进位，所以有精度的丢失。</p>\n</li>\n<li>\n<p>i 等于 - 53 的情况</p>\n</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190243583.png\" alt=\"image-20221018190243583\" /></p>\n<p>​\t\t舍入位是 10，前置位是 1，因此要进位，从而造成了误差。</p>\n<p>只要有精度的丢失，就是 “否”</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/04/COA/Lecture04-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/04/COA/Lecture04-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "title": "Lecture04-整数运算",
            "date_published": "2022-10-04T13:32:43.000Z",
            "content_html": "<p>整数的加减乘除计算的实现。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"整数运算\"><a class=\"anchor\" href=\"#整数运算\">#</a> 整数运算</h1>\n<h2 id=\"算术逻辑单元alu\"><a class=\"anchor\" href=\"#算术逻辑单元alu\">#</a> 算术逻辑单元 ALU</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110026189.png\" alt=\"image-20221012110026189\" /></p>\n<p>寄存器存储数据、结果、flags</p>\n<p>控制器控制 ALU 操作和数据传入的信号</p>\n<h2 id=\"全加器\"><a class=\"anchor\" href=\"#全加器\">#</a> 全加器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110035166.png\" alt=\"image-20221012110035166\" /></p>\n<p><strong>关注与或异或的符号</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110051989.png\" alt=\"image-20221012110051989\" /></p>\n<p><strong>计算结果和进位</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110059850.png\" alt=\"image-20221012110059850\" /></p>\n<p>F 可以理解为，是奇数个 1 的时候，结果为 1；是偶数个 1 的时候，结果为 0。</p>\n<p>进位则是，有两个 1 的时候即可进位。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110111693.png\" alt=\"image-20221012110111693\" /></p>\n<p>异或门只能有<strong>两个</strong>输入端，异或门的时延<strong>不一定为 3ty</strong>。</p>\n<p>在网上找了一些实现异或的方法，可以看出，时延可以是 2ty 也可以是 3ty，应该是由异或门实现的方式决定的。</p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log29.gif\" alt=\"logic equivalent\" /></p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log30.gif\" alt=\"implimentation using NAND\" /></p>\n<p>非门算不算时延？ <strong>非门算时延</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110147229.png\" alt=\"image-20221012110147229\" /></p>\n<p>减少了一个与门，但是时延仍然是 6ty</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110159471.png\" alt=\"image-20221012110159471\" /></p>\n<p>这里可以解释为，因为 X 和 Y 的或和异或仅在 X、Y 均为 1 时不同，但 X、Y 均为 1 时，前面的与为 1，并不影响结果，所以两个式子相等。</p>\n<h2 id=\"串行进位行波进位加法器\"><a class=\"anchor\" href=\"#串行进位行波进位加法器\">#</a> 串行进位（行波进位）加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110210316.png\" alt=\"image-20221012110210316\" /></p>\n<p>公式来源于前面的全加法器，理解一样。</p>\n<p>需要等待 “进位输出信号”，所以缺点是延迟慢。</p>\n<h2 id=\"全先行进位加法器\"><a class=\"anchor\" href=\"#全先行进位加法器\">#</a> 全先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110215735.png\" alt=\"image-20221012110215735\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110224827.png\" alt=\"image-20221012110224827\" /></p>\n<p>不需要等待 n-1 位算完，就可以开始计算第 n 位，把能计算的先提前计算好。</p>\n<p>1ty：Gi 和 Pi 的计算，Gi 和 Pi 的计算可以同时进行，只需要 1ty</p>\n<p>2ty：计算 C 的值，因为需要先进行与操作，再进行或操作，所以需要 2ty，因为 Ci 只和 P\\G\\C0 的值有关，所以不需要等前一位的进位算好。</p>\n<p>3ty：Xi 和 Yi 的异或可在前三个时延做好，只需要再和 Ci-1 做异或即可算出 F。</p>\n<h2 id=\"部分先行进位加法器\"><a class=\"anchor\" href=\"#部分先行进位加法器\">#</a> 部分先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110230663.png\" alt=\"image-20221012110230663\" /></p>\n<p>加法器延迟过于严重，但是全先行进位又难以实现，所以采用了两者的混合杂交。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110240165.png\" alt=\"image-20221012110240165\" /></p>\n<p>3ty：第一个全先行加法器需要算出 G、P，耗时 1ty；然后需要算出所有的进位，耗时 2ty；与此同时，其他三个 CLA 也算好了自己的 G 和 P。</p>\n<p>2ty：第二个 CLA 收到 Cin 之后，需要 2ty 计算 Cout。</p>\n<p>2ty：同上，为第三个 CLA 的计算。</p>\n<p>5ty：2ty+3ty，第四个 CLA 计算 C 需要 2ty，然后再和 X、Y 进行异或操作，需要 3ty。在此之前，其余的 CLA 已经完成了异或计算。</p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110246821.png\" alt=\"image-20221012110246821\" /></p>\n<p>溢出的情况只能是两个正的变成负的，或者两个负的变成正的。</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>C</th>\n<th>Fn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<p>判断是否溢出的 flag 就是在 Cn-1 和 Cn 上加一个异或器</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>Cn-1</th>\n<th>Cn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110254314.png\" alt=\"image-20221012110254314\" /></p>\n<p>减法就是在加法器上加一个选择器，sub 给一个信号</p>\n<h2 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110300471.png\" alt=\"image-20221012110300471\" /></p>\n<p>实际上，加法和移位可以合并，因为始终上升沿到来之前，各寄存器中的数据会被取出，因此不需要 2-3 个时钟周期，1 个时钟周期即可完成。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110306067.png\" alt=\"image-20221012110306067\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110312495.png\" alt=\"image-20221012110312495\" /></p>\n<p>由于乘法会出现溢出的问题，所以出现了原码一位乘法和布斯算法。</p>\n<h3 id=\"原位一位乘法\"><a class=\"anchor\" href=\"#原位一位乘法\">#</a> 原位一位乘法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110326698.png\" alt=\"image-20221012110326698\" /></p>\n<h3 id=\"补码一位乘法布斯算法\"><a class=\"anchor\" href=\"#补码一位乘法布斯算法\">#</a> 补码一位乘法：布斯算法</h3>\n<h4 id=\"基本思路和证明\"><a class=\"anchor\" href=\"#基本思路和证明\">#</a> 基本思路和证明</h4>\n<p>每次根据两位决定直接移位 / 加 / 减（共四种情况）</p>\n<ol>\n<li>00、11—— 直接移位</li>\n<li><strong>10</strong> —— 减</li>\n<li><strong>01</strong> —— 加</li>\n</ol>\n<h4 id=\"黑书证明\"><a class=\"anchor\" href=\"#黑书证明\">#</a> 黑书证明</h4>\n<p>用 **2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup>** 可以表示正乘数和负乘数</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221009234843548.png\" alt=\"image-20221009234843548\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221009235208579.png\" alt=\"image-20221009235208579\" /></p>\n<h4 id=\"ppt证明\"><a class=\"anchor\" href=\"#ppt证明\">#</a> PPT 证明</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110337646.png\" alt=\"image-20221012110337646\" /></p>\n<p>为什么可以这样用布斯算法计算？</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/6D18DEB3A3D802AB3B7AE9DB900A475C.png\" alt=\"img\" /><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110345029.png\" alt=\"image-20221012110345029\" /></p>\n<h4 id=\"易错点算数移位\"><a class=\"anchor\" href=\"#易错点算数移位\">#</a> 易错点：算数移位</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110426386.png\" alt=\"image-20221012110426386\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110429745.png\" alt=\"image-20221012110429745\" /></p>\n<p>错误原因：补位负数补 1，不论是何种情况，右移都使得 A 的最左位，即 A<sub>n-1</sub> 不仅移入 A<sub>n-2</sub> 中，而且还保留在 A<sub>n-1</sub> 中。这是为了保持 A 和 Q 中数的符号，因为它<strong>保留了符号位</strong>，所以被称为<strong>算数移位</strong>。</p>\n<p>实际上，根据黑书，应该还有一位 Q<sub>-1</sub> 寄存器，放在 Q 最低有效位的右边，负责保存丢失的那位。</p>\n<h3 id=\"乘法溢出\"><a class=\"anchor\" href=\"#乘法溢出\">#</a> 乘法溢出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110434583.png\" alt=\"image-20221012110434583\" /></p>\n<p>带符号整数：因为乘法的补位是根据当前最高位计算的，如果有变化，则说明有溢出</p>\n<p>无符号整数：无符号整数应该没有 1 的出现</p>\n<h2 id=\"除法\"><a class=\"anchor\" href=\"#除法\">#</a> 除法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013100038320.png\" alt=\"image-20221013100038320\" /></p>\n<p>不同的高级算法对于 1/0 0/0 的计算结果处理是不同的</p>\n<p>如在 js 中，1/0 为正无穷；c 中会报错</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110438424.png\" alt=\"image-20221012110438424\" /></p>\n<p>在十进制除法中，需要用到乘法；在二进制中则不需要。</p>\n<p>除数和被除数符号不一样时，不同的编程语言也会得到不一样的答案。</p>\n<p>注意补齐被除数的符号位，从<strong>次高位</strong>开始计算。</p>\n<h3 id=\"除法器\"><a class=\"anchor\" href=\"#除法器\">#</a> 除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110445518.png\" alt=\"image-20221012110445518\" /></p>\n<p>对应于手工进行除法运算，</p>\n<p>因为需要补全被除数的位数，所以需要 2n 寄存器；</p>\n<p>因为除数相对于被除数的次高位开始移动，所以需要 2n 位支持右移的寄存器；</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110451162.png\" alt=\"image-20221012110451162\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110454561.png\" alt=\"image-20221012110454561\" /></p>\n<p>除法流程图 —— “是否为第<strong> N+1</strong> 次循环”</p>\n<p>和乘法不同 ——<strong>N</strong> 次循环</p>\n<p><strong>如何做优化？</strong></p>\n<p>常见的思路 —— 并行操作 / 硬件节省</p>\n<blockquote>\n<p>不能够做并行操作</p>\n<p>可以做一些硬件的优化</p>\n</blockquote>\n<h3 id=\"优化的除法器\"><a class=\"anchor\" href=\"#优化的除法器\">#</a> 优化的除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110458490.png\" alt=\"image-20221012110458490\" /></p>\n<h3 id=\"异号的除法如何处理\"><a class=\"anchor\" href=\"#异号的除法如何处理\">#</a> 异号的除法如何处理？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110504455.png\" alt=\"image-20221012110504455\" /><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110514117.png\" alt=\"image-20221012110514117\" /></p>\n<p>结果都是<strong>和余数进行比较</strong>，操作之后，如果相对于余数的符号改变，则不够；如果相对于余数的符号不变，则够。</p>\n<p>例子：</p>\n<p>可以对照上下（36、37）两张图理解异号的除法，</p>\n<p>被除数为 11111001，它的值为 - 7</p>\n<ol>\n<li>1111 + 0011 为 10010 符号改变</li>\n<li>1110 + 0011 为 10001 符号改变</li>\n<li>1100 + 0011 为 1111 符号不变，且绝对值减小，因此可以加，且商上 1</li>\n<li>1111 + 0011 符号改变</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221010003001858.png\" alt=\"img\" /></p>\n<p>参考黑书的话，</p>\n<p>余数的符号 = 被除数</p>\n<p>商的符号 = 被除数 * 除数</p>\n<p>因此，此题中，商和余数都需要取负数，所以商要取补码</p>\n<h3 id=\"补码除法运算过程\"><a class=\"anchor\" href=\"#补码除法运算过程\">#</a> 补码除法运算过程</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110521683.png\" alt=\"image-20221012110521683\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110524618.png\" alt=\"image-20221012110524618\" /></p>\n<h3 id=\"不恢复余数除法\"><a class=\"anchor\" href=\"#不恢复余数除法\">#</a> 不恢复余数除法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110534163.png\" alt=\"image-20221012110534163\" /></p>\n<p>可以参考之前的恢复余数的操作理解</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110539289.png\" alt=\"image-20221012110539289\" /></p>\n<p>如何理解大致思路：</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/4C93EBA825F2B3B083A9B5CC5D1E567D.png\" alt=\"img\" /></p>\n<p>由下面的通式表示：</p>\n<p><strong>ri+1=2ri+(1-2Qi)Y</strong></p>\n<blockquote>\n<p>式中 Qi 为第 i 次所得的商，若部分余数为正，则 Qi=1，部分余数左移一位，下一次继续减除数；若部分余数为负，则 Qi=0，部分余数左移一位，下一次加除数。由于加减运算交替地进行，故称为原码加减交替法。</p>\n</blockquote>\n<h3 id=\"补码不恢复余数除法流程图\"><a class=\"anchor\" href=\"#补码不恢复余数除法流程图\">#</a> 补码不恢复余数除法流程图</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221006172646381.png\" alt=\"img\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110545429.png\" alt=\"image-20221012110545429\" /></p>\n<p>同号说明 “够大”，异号说明 “不够大”</p>\n<p>注意不恢复余数补码除法分为两个流程，首先需要判断符号然后初始化。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110550193.png\" alt=\"image-20221012110550193\" /></p>\n<p><strong>计算流程</strong>理解：</p>\n<p>流程一：因为余数和除数异号，所以采用加的方式。加完后发现同号（实际上是由异号变为同号），补 1，实际上是取反的操作。</p>\n<p>流程二：根据 X 和 Y 是否同号，继续操作。</p>\n<p><strong>关于商的修正</strong>：</p>\n<p>Z 左移一位，根据是否够加，上 1 或 0。</p>\n<p>如果被除数和除数异号，说明商是负数。在求每一位的时候，已经取了反，因此再加 1 即可。这样的操作，比最后再计算商的总体的补码简单。</p>\n<p><strong>关于余数的修正</strong>：</p>\n<p>余数和被除数的符号相同。</p>\n<p>如果符号不同，则说明余数多加 / 多减了一个除数。如果被除数和除数的符号相同，说明余数和除数符号不相同，加上除数进行修正；如果被除数和除数符号不同，说明余数和除数符号相同，减去除数进行修正。</p>\n<p>在最后多加了一个 Y</p>\n<p>符号位，不恢复余数补码除法运算和除数比，恢复的和被除数相比</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110557310.png\" alt=\"image-20221012110557310\" /></p>\n<p>因为除法器效率不高，所以用右移运算实现简化</p>\n<p>能整除的时候，被移除的全为 0；</p>\n<p>不能整除的时候，移除的数存在非 0，</p>\n<p>-14/4 负数补位 1</p>\n<h3 id=\"阵列除法器\"><a class=\"anchor\" href=\"#阵列除法器\">#</a> 阵列除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110601896.png\" alt=\"image-20221012110601896\" /></p>\n<p>实际生活中并不是斜着排列的</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110605353.png\" alt=\"image-20221012110605353\" /></p>\n<p>全加器是两个半加器组合起来的，半加器不考虑进位。</p>\n<p>全加器算了两次 X+Y：第一次 X+Y 得到 Z，第二次 Z+Cin 得到结果。</p>\n<p>注意各整数运算的优化过程</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture03-数据的机器级表表示",
            "date_published": "2022-09-22T23:41:11.000Z",
            "content_html": "<p>仅记录有用部分，课件详细内容在 ppt 上已经很清楚了。</p>\n<p>需要加强的地方：二进制转十进制，十进制转二进制，补码的模不懂，静默式和通知式，非规格化数不懂、精度保护中的舍入看不懂，大端小端</p>\n<p>好难…… 呜呜看不懂</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"第一次作业讲解\"><a class=\"anchor\" href=\"#第一次作业讲解\">#</a> 第一次作业讲解</h2>\n<p>作业 1：. 为什么速率的总和没有意义？</p>\n<p>作业 2：指令集结构不同的计算机，只比较 MIPS 是没有意义的，例如此题当中，A 的 MIPS 大，但是运行时间较长。</p>\n<p>作业 3：采用不同指令集、<strong>流水线</strong>和并行</p>\n<p>作业 4：MIPS 求和有意义吗？</p>\n<p>组织不可见，结构可见</p>\n<h1 id=\"lecture0304-数据的机器级表示\"><a class=\"anchor\" href=\"#lecture0304-数据的机器级表示\">#</a> lecture03/04 - 数据的机器级表示</h1>\n<p>参考紫书第 2 章 / 黑书第 9 章 计算机算数</p>\n<h2 id=\"课堂ppt结合黑书版本\"><a class=\"anchor\" href=\"#课堂ppt结合黑书版本\">#</a> 课堂 /ppt—— 结合黑书版本</h2>\n<h3 id=\"信息的二进制编码\"><a class=\"anchor\" href=\"#信息的二进制编码\">#</a> 信息的二进制编码</h3>\n<h3 id=\"整数的二进制表示\"><a class=\"anchor\" href=\"#整数的二进制表示\">#</a> 整数的二进制表示</h3>\n<h4 id=\"无符号整数\"><a class=\"anchor\" href=\"#无符号整数\">#</a> 无符号整数</h4>\n<h4 id=\"有符号整数\"><a class=\"anchor\" href=\"#有符号整数\">#</a> 有符号整数</h4>\n<h5 id=\"原码-符号幅值表示法\"><a class=\"anchor\" href=\"#原码-符号幅值表示法\">#</a> 原码 符号幅值表示法</h5>\n<p>符号位不同，数值位相同</p>\n<p>不同位长间的转换：符号位左移，空余的填补 0</p>\n<p>浮点数的尾数用原码定点小数表示</p>\n<p>零的表示不唯一，不利于程序员编程</p>\n<h5 id=\"反码\"><a class=\"anchor\" href=\"#反码\">#</a> 反码</h5>\n<p>符号位和数值位均取反</p>\n<h5 id=\"移码\"><a class=\"anchor\" href=\"#移码\">#</a> 移码</h5>\n<p>是一种有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbmVkX251bWJlcl9yZXByZXNlbnRhdGlvbg==\">符号数表示</span>的方法，其中有符号数 n 是由对应于<strong>无符号数 n + K</strong> 的位模式表示，K 是<em>偏置值</em>或<em>偏移量</em>。</p>\n<p>bias 通常取 2 的 n-1 次方或者 2 的 n-1 次方减 1<br />\n 当 bias 为 2 的 n-1 次方时，移码和补码仅第一位不同，0 的表示唯一<br />\n<strong>浮点数的阶用移码表示</strong>：当两个数都是负数的时候，移码更容易比较</p>\n<h5 id=\"补码\"><a class=\"anchor\" href=\"#补码\">#</a> 补码</h5>\n<p>计算机处理中，<strong>通常使用补码</strong><br />\n负数的数值部分 <strong>各位取反，末尾加 1</strong></p>\n<p>不同位长间的转换：符号位移到最左位，其余空出位用符号位的值替代</p>\n<p>加和减的统一：<br />\n一个负数的补码等于模减该负数的绝对值<br />\n对于一个确定的模，某数减去小于模的另一数，总可以加上另一数负数的补码来代替。</p>\n<p><strong>求真值的补码</strong></p>\n<p>全 0：0</p>\n<p>全 1：-1</p>\n<p>10000...：- 2 <sup>n-1</sup></p>\n<p><strong>求补码的真值</strong></p>\n<p>**X = - x<sub>n-1</sub> * 2 <sup>n-1</sup> + ... + x <sub>2</sub> * 2 <sup>1</sup>+ x <sub>1</sub>*2<sup>0</sup> **</p>\n<p><strong>若对负数的补码再取负，得到原来那个数</strong>【其中的特例是，-2<sup>n-1</sup> 在取负之后仍然为本身，因为范围内并没有 2<sup>n-1</sup> 与之相对应】</p>\n<h3 id=\"浮点数\"><a class=\"anchor\" href=\"#浮点数\">#</a> 浮点数</h3>\n<p>单精度 32 位（1+8+23）<strong>仍然表示 2<sup>32</sup> 个数</strong></p>\n<p>双精度 64 位（1+11+52）</p>\n<p>基底为 2（也存在基底为 16 的情况）—— 基数越大，范围越大，精度越低</p>\n<h4 id=\"表示方法\"><a class=\"anchor\" href=\"#表示方法\">#</a> 表示方法</h4>\n<p>S E M</p>\n<ol>\n<li>\n<p>符号位</p>\n</li>\n<li>\n<p>8 位移码表示阶码（指数） —— 范围为 - 126~127，全 0 和全 1 为特殊值</p>\n</li>\n<li>\n<p>23 位原码表示 24 位尾数，最高位总为 1</p>\n</li>\n</ol>\n<h4 id=\"表示的数\"><a class=\"anchor\" href=\"#表示的数\">#</a> 表示的数</h4>\n<p><strong>规格化数</strong>，关注上溢出和下溢出，</p>\n<p>下溢出部分用<strong>非格式化数</strong>表示，它的间距是等距的</p>\n<p>越靠近原点，数越密集；越远离原点，数越稀疏</p>\n<p><strong>静默式和通知式非数</strong> —— 静默式表示未定义的算数结果，通知式非数表示未初始化的值。</p>\n<h2 id=\"计算机组成与体系结构性能设计\"><a class=\"anchor\" href=\"#计算机组成与体系结构性能设计\">#</a> 计算机组成与体系结构：性能设计</h2>\n<h3 id=\"整数的加法与减法补码\"><a class=\"anchor\" href=\"#整数的加法与减法补码\">#</a> 整数的加法与减法（补码）</h3>\n<p>上溢规则</p>\n<p>减法规则 —— 减法，即加上减数的 2 的补</p>\n<p>在实际的操作中，有 OF 溢出位记录是否溢出</p>\n<h3 id=\"整数的乘法\"><a class=\"anchor\" href=\"#整数的乘法\">#</a> 整数的乘法</h3>\n<h4 id=\"无符号整数的乘法\"><a class=\"anchor\" href=\"#无符号整数的乘法\">#</a> 无符号整数的乘法</h4>\n<p>两个 n 为二进制整数的乘法可产生最大长度为 2n 位的积</p>\n<p>乘</p>\n<p>移位</p>\n<p>计数 - 1</p>\n<h4 id=\"有符号整数的乘法\"><a class=\"anchor\" href=\"#有符号整数的乘法\">#</a> 有符号整数的乘法</h4>\n<p>只要有一个是负数，原来的方法就不奏效</p>\n<ol>\n<li>\n<p>把被乘数和乘数都转变成正数再相乘，当两者初始的符号不相同时，结果取 2 的补</p>\n</li>\n<li>\n<p>布斯（Booth）算法</p>\n<p>分为 10 01 【00 11】三种情况讨论</p>\n<p>运用公式，   <strong>2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup></strong></p>\n<p>很巧妙，优雅，实在是太优雅了！</p>\n</li>\n</ol>\n<h3 id=\"整数的除法\"><a class=\"anchor\" href=\"#整数的除法\">#</a> 整数的除法</h3>\n<p>搞来搞去，也很优雅</p>\n<h3 id=\"浮点数加法和减法\"><a class=\"anchor\" href=\"#浮点数加法和减法\">#</a> 浮点数加法和减法</h3>\n<ol>\n<li>检查 0</li>\n<li>对齐有效值</li>\n<li>加法</li>\n<li>规格化</li>\n</ol>\n<p>注意时时检查是否有效值为 0，以及是否溢出</p>\n<p>若两个数的阶值差别非常大，则较小的数丢失</p>\n<h3 id=\"浮点数乘法和除法\"><a class=\"anchor\" href=\"#浮点数乘法和除法\">#</a> 浮点数乘法和除法</h3>\n<p>由于阶值是移码的形式，相乘的时候，两个阶值的和要减去一个偏移量，相除的时候，两个阶值的差要加上一个偏移量</p>\n<h4 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h4>\n<ol>\n<li>\n<p>保护位</p>\n<p>对齐的时候会导致丢失，在末尾增加保护位，可以扩展有效值的右端</p>\n</li>\n<li>\n<p>舍入（不懂）</p>\n</li>\n</ol>\n<h2 id=\"计算机组成与系统结构习题解答和教学指导\"><a class=\"anchor\" href=\"#计算机组成与系统结构习题解答和教学指导\">#</a> 计算机组成与系统结构习题解答和教学指导</h2>\n<h3 id=\"数据的表示\"><a class=\"anchor\" href=\"#数据的表示\">#</a> 数据的表示</h3>\n<ul>\n<li>\n<p>数值数据 —— 二进制、十进制（BCD binary coded decimal）</p>\n</li>\n<li>\n<p>非数值数据</p>\n</li>\n</ul>\n<h3 id=\"数据的宽度\"><a class=\"anchor\" href=\"#数据的宽度\">#</a> 数据的宽度</h3>\n<p>数据容量和宽度</p>\n<p>比特</p>\n<p>字节</p>\n<p>字（2 个 / 4 个 / 8 个 / 16 个字节）</p>\n<h3 id=\"数据的排列\"><a class=\"anchor\" href=\"#数据的排列\">#</a> 数据的排列</h3>\n<ul>\n<li>大端排列 —— 最低有效字节 LSB 存放在大地址单元中，MSB 所在地址为数据的地址</li>\n<li>小端排列 —— 最低有效字节 LSB 存放在小地址单元中，LSB 所在地址为数据的地址</li>\n</ul>\n<h3 id=\"数据校验方式\"><a class=\"anchor\" href=\"#数据校验方式\">#</a> 数据校验方式</h3>\n<ul>\n<li>\n<p>奇偶校验</p>\n</li>\n<li>\n<p>海明校验</p>\n</li>\n<li>\n<p>循环冗余码校验</p>\n</li>\n</ul>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "Lecture02-计算机体系结构的问题及解决方案",
            "date_published": "2022-09-15T10:01:24.000Z",
            "content_html": "<p>讲述了六个计算机体系结构的问题以及解决方案<br />\n<span id=\"more\"></span></p>\n<h2 id=\"冯诺依曼最重要的思想存储程序\"><a class=\"anchor\" href=\"#冯诺依曼最重要的思想存储程序\">#</a> 冯诺依曼最重要的思想 —— 存储程序</h2>\n<p>任何要计算机完成的工作都要先被编写成程序，然后将<strong>程序和原始数据送入主存</strong>并启动执行。一旦程序被启动，计算机应能在不需要操作人员干预下，自动完成逐条取出指令和执行指令的任务。</p>\n<p>区分中央处理单元（CPU）和处理器。</p>\n<p>CPU 的制作工艺逐渐在提高，几乎不变的是 CPU 的大小，一直在增加的是晶体管的数量。</p>\n<p>目前，苹果 M2 以及可以集成 200 亿的晶体管。</p>\n<h2 id=\"问题与解决思路\"><a class=\"anchor\" href=\"#问题与解决思路\">#</a> 问题与解决思路</h2>\n<h3 id=\"可以通过无限增加cpu的大小来增加性能嘛\"><a class=\"anchor\" href=\"#可以通过无限增加cpu的大小来增加性能嘛\">#</a> 可以通过无限增加 CPU 的大小来增加性能嘛？</h3>\n<p>不可以，面积越大，意味着<strong>互联延迟</strong>越大。一个时钟周期需要大于最长互联延迟。存在物理极限。</p>\n<h3 id=\"问题1cpu的频率不能无限提高\"><a class=\"anchor\" href=\"#问题1cpu的频率不能无限提高\">#</a> 问题 1：CPU 的频率不能无限提高</h3>\n<p>MOS 管开关、脉冲通过门电路需要时间</p>\n<p>为了信号同步，每个脉冲信号需要持续一定的时间</p>\n<p>面积大，连线延迟大；</p>\n<p>频率越高，开关损耗高，CPU 耗电和散热提高；</p>\n<h3 id=\"解决1改变cpu芯片结构\"><a class=\"anchor\" href=\"#解决1改变cpu芯片结构\">#</a> 解决 1：改变 CPU 芯片结构</h3>\n<ol>\n<li>\n<p>采用各种技术，对芯片体系结构进行优化：指令流水线、每周期多条指令、cache、更长流水线和双速算术</p>\n</li>\n<li>\n<p>领域定制，如面向人工智能的芯片</p>\n</li>\n</ol>\n<h3 id=\"问题2内存墙的存在-memory-wall\"><a class=\"anchor\" href=\"#问题2内存墙的存在-memory-wall\">#</a> 问题 2：内存墙的存在 memory wall</h3>\n<p>主存和 CPU 之间传输数据的速度跟不上 CPU 的速度</p>\n<h3 id=\"解决2采用高速缓存cache\"><a class=\"anchor\" href=\"#解决2采用高速缓存cache\">#</a> 解决 2：采用高速缓存（cache）</h3>\n<ol>\n<li>添加一级或多级缓存以减少存储器访问频率并提高数据传输速率</li>\n<li>增大总线的数据宽度，来增加每次所能取出的位数</li>\n</ol>\n<h3 id=\"问题3cpu等待io传输数据\"><a class=\"anchor\" href=\"#问题3cpu等待io传输数据\">#</a> 问题 3：CPU 等待 I/O 传输数据</h3>\n<p>CPU 在等待 I/O 设备时保持空闲</p>\n<h3 id=\"解决3中断\"><a class=\"anchor\" href=\"#解决3中断\">#</a> 解决 3：中断</h3>\n<p>其他模块（例如 IO）可以中断正常处理顺序的机制</p>\n<p>中断周期加入指令周期中</p>\n<p>多重中断：顺序中断处理、嵌套中断处理</p>\n<h3 id=\"问题4兼顾存储容量-速度和成本\"><a class=\"anchor\" href=\"#问题4兼顾存储容量-速度和成本\">#</a> 问题 4：兼顾存储容量、速度和成本</h3>\n<p>约束</p>\n<ul>\n<li>容量：越大越好</li>\n<li>速度：跟上处理器</li>\n<li>成本：相较于其他组件合理</li>\n</ul>\n<p>约束之间的关系</p>\n<p>​\t更短的访问时间，更高的每比特成本</p>\n<h3 id=\"解决4层次式存储结构\"><a class=\"anchor\" href=\"#解决4层次式存储结构\">#</a> 解决 4：层次式存储结构</h3>\n<p>需求</p>\n<ul>\n<li>大容量数据存储</li>\n<li>高速性能</li>\n</ul>\n<p>解决方案</p>\n<ul>\n<li>使用存储器层次结构而不是依赖单个存储器组件</li>\n</ul>\n<p><strong>寄存器 ——cache—— 主存 —— 磁盘 —— 磁带</strong></p>\n<p>存储量越来越大，速度越来越慢，离 CPU 越来越远</p>\n<h3 id=\"问题5io设备传输速率差异大\"><a class=\"anchor\" href=\"#问题5io设备传输速率差异大\">#</a> 问题 5：I/O 设备传输速率差异大</h3>\n<p>I/O 性能跟不上 CPU 速度的提升</p>\n<h3 id=\"解决5采用缓冲区和改进io操作技术\"><a class=\"anchor\" href=\"#解决5采用缓冲区和改进io操作技术\">#</a> 解决 5：采用缓冲区和改进 I/O 操作技术</h3>\n<p>设立缓存区</p>\n<h3 id=\"问题6计算机部件互连复杂\"><a class=\"anchor\" href=\"#问题6计算机部件互连复杂\">#</a> 问题 6：计算机部件互连复杂</h3>\n<h3 id=\"解决6采用总线\"><a class=\"anchor\" href=\"#解决6采用总线\">#</a> 解决 6：采用总线</h3>\n<h4 id=\"总线\"><a class=\"anchor\" href=\"#总线\">#</a> 总线</h4>\n<p>目前，对通用计算机而言，各种点对点互连结构逐渐取代总线互连的方式。但是总线结构依然普遍用于嵌入式系统。</p>\n<h5 id=\"共享\"><a class=\"anchor\" href=\"#共享\">#</a> 共享</h5>\n<p>所有部件都通过总线传递数据</p>\n<h5 id=\"分时\"><a class=\"anchor\" href=\"#分时\">#</a> 分时</h5>\n<p>只有一个部件能够传输数据</p>\n<h5 id=\"功能组\"><a class=\"anchor\" href=\"#功能组\">#</a> 功能组</h5>\n<p><strong>控制线</strong> —— 控制对数据线路与地址线路的访问和使用，控制信号传递<strong>命令和定时信息</strong>。</p>\n<p><strong>地址线</strong> —— 指定数据总线上数据的源或目的，地址总线的宽度决定了系统可能的<strong>最大内存容量</strong></p>\n<p><strong>数据线</strong> —— 为系统模块之间的数据传输提供路径，一般而言，线路的条数决定了<strong>一次能传输的位数</strong>，数据总线的宽度是决定系统整体性能的一个关键因素</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "Lecture01-计算机系统概述",
            "date_published": "2022-09-08T12:30:32.000Z",
            "content_html": "<p>第一讲，以及对于书籍的第一章重点知识点整理</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"课程随笔\"><a class=\"anchor\" href=\"#课程随笔\">#</a> 课程随笔</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<p><strong>通用 电子 数字 计算机</strong></p>\n<p>通用</p>\n<p>电子</p>\n<p>数字</p>\n<h3 id=\"组织与结构\"><a class=\"anchor\" href=\"#组织与结构\">#</a> 组织与结构</h3>\n<ol>\n<li>结构 (对于程序员是可见的)\n<ul>\n<li>一个提供乘法算法的计算机和另一个不提供乘法算法的计算机之间的区别</li>\n<li>包括：指令集、各类数据类型的大小</li>\n</ul>\n</li>\n<li>组织 (对于程序员是不可见的)\n<ul>\n<li>一个用乘法器完成乘法的计算机和一个用加法器通过算法完成乘法的计算机之间的不同。</li>\n<li>包括：控制信号、存储技术</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"计算机发展历史\"><a class=\"anchor\" href=\"#计算机发展历史\">#</a> 计算机发展历史</h2>\n<p>真空管</p>\n<p>晶体管</p>\n<p>集成电路（scale 越来越大，SSI-&gt;MSI-&gt;LSI-&gt;VLSI-&gt;ULSI）</p>\n<p>摩尔定律（集成电路芯片上集成的晶体管数将番一番，速度将提高一倍，而价格将降低一半）</p>\n<h2 id=\"冯诺依曼结构的实现与演变\"><a class=\"anchor\" href=\"#冯诺依曼结构的实现与演变\">#</a> 冯诺依曼结构的实现与演变</h2>\n<h3 id=\"cpu-北桥-南桥\"><a class=\"anchor\" href=\"#cpu-北桥-南桥\">#</a> CPU + 北桥 + 南桥</h3>\n<p>芯片近北桥，远离南桥。</p>\n<h4 id=\"南桥\"><a class=\"anchor\" href=\"#南桥\">#</a> 南桥</h4>\n<p>南桥（英语：Southbridge）是基于个人计算机主板芯片组架构中的其中一枚芯片。南桥设计用来处理<strong>低速信号</strong>，通过北桥与中央处理器联系。<br />\n南桥芯片负责 I/O 总线之间的通信，如 PCI 总线、USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等。<br />\nPCI、SATA、IDE、USB。</p>\n<h4 id=\"北桥\"><a class=\"anchor\" href=\"#北桥\">#</a> 北桥</h4>\n<p>北桥设计用来处理<strong>高速信号</strong>，通常处理中央处理器、存储器、PCI Express 显卡（早年是 AGP 显卡）、高速 PCI Express X16/X8 的端口，还有与南桥之间的通信。<br />\n芯片组（chipset）的名称就是以北桥芯片的名称来命名的。<br />\n北桥被用来处理高速信号，通常处理 CPU（处理器），RAM（内存），AGP 端口或 PCI Express, 和南桥芯片之间的通信。<br />\nPCIE/AGP、Memory、CPU。</p>\n<h3 id=\"cpu-pch集成显卡-显示部件\"><a class=\"anchor\" href=\"#cpu-pch集成显卡-显示部件\">#</a> CPU + PCH（集成显卡 - 显示部件）</h3>\n<p>PCH 全称为 Platform Controller Hub，是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9pbnRlbCVFNSU4NSVBQyVFNSU4RiVCOA==\"> intel 公司</span>的集成南桥。</p>\n<p>北桥中的内存控制器和 PCIe 控制器都集成到了 CPU 内部，相当于整个北桥芯片都集成到了 CPU 内部，主板上只剩下南桥。所以 PCH 可以理解成南桥。目前 Intel 的有些 SOC 就是连 PCH 也集成到了 CPU 内部，比如：Intel Xeon D 系列.</p>\n<h2 id=\"计算机性能\"><a class=\"anchor\" href=\"#计算机性能\">#</a> 计算机性能</h2>\n<h3 id=\"cpu性能\"><a class=\"anchor\" href=\"#cpu性能\">#</a> CPU 性能</h3>\n<p>时钟频率 / 时钟周期</p>\n<p>CPI</p>\n<p>MIPS（每秒百万条指令）</p>\n<p>MRLOPS（每秒百万条浮点操作）</p>\n<p>基准程序</p>\n<h3 id=\"性能设计的基本原则\"><a class=\"anchor\" href=\"#性能设计的基本原则\">#</a> 性能设计的基本原则</h3>\n<ul>\n<li>\n<p>大概率事件优先原则</p>\n</li>\n<li>\n<p>阿姆代尔定律 Amdahl 定律</p>\n<p>技术或设计的某一部分的加速不会导致性能产生相应的改进。性能的提高是有限度的。</p>\n</li>\n<li>\n<p>Little 定律</p>\n</li>\n</ul>\n<h1 id=\"对应书籍整理-计算机系统概述\"><a class=\"anchor\" href=\"#对应书籍整理-计算机系统概述\">#</a> 对应书籍整理 - 计算机系统概述</h1>\n<h2 id=\"计算机结构\"><a class=\"anchor\" href=\"#计算机结构\">#</a> 计算机结构</h2>\n<h3 id=\"硬件\"><a class=\"anchor\" href=\"#硬件\">#</a> 硬件</h3>\n<ol>\n<li>\n<p>CPU</p>\n<ul>\n<li>运算器 —— 各种算数逻辑运算</li>\n<li>控制器 —— 对指令译码并送出操作控制信号</li>\n</ul>\n</li>\n<li>\n<p>存储器 —— 存放指令和数据</p>\n<p>包括 ROM 芯片和 RAM 芯片。</p>\n<ul>\n<li>\n<p>内存储器</p>\n<ul>\n<li>主存</li>\n<li>高速缓存（cache）</li>\n</ul>\n</li>\n<li>\n<p>外存储器</p>\n<p>磁盘、磁带存储器、光盘存储器等</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I/O 设备 —— 计算机和用户之间的信息交换</p>\n</li>\n</ol>\n<h3 id=\"软件\"><a class=\"anchor\" href=\"#软件\">#</a> 软件</h3>\n<ol>\n<li>系统软件 —— 介于计算机硬件和应用软件之间的各种软件\n<ul>\n<li>操作系统软件</li>\n<li>语言处理系统</li>\n<li>数据库管理系统</li>\n<li>各类实用程序</li>\n</ul>\n</li>\n<li>应用软件\n<ul>\n<li>办公自动化软件</li>\n<li>互联网应用软件</li>\n<li>多媒体处理软件</li>\n<li>股票分析软件</li>\n<li>游戏软件</li>\n<li>管理信息系统</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"程序开发和执行过程\"><a class=\"anchor\" href=\"#程序开发和执行过程\">#</a> 程序开发和执行过程</h3>\n<ol>\n<li>高级语言、低级语言（汇编语言）-&gt; 机器语言</li>\n</ol>\n<p>​\t\t其中，汇编语言和机器语言程序员必须对机器的结构和指令系统等细节非常清楚。</p>\n<ol start=\"2\">\n<li>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>对应计算机用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用程序</td>\n<td>最终用户</td>\n</tr>\n<tr>\n<td>高级语言虚拟机</td>\n<td>高级语言程序员或者应用程序员</td>\n</tr>\n<tr>\n<td>汇编语言虚拟机</td>\n<td>汇编语言程序员</td>\n</tr>\n<tr>\n<td>操作系统虚拟机</td>\n<td>系统管理员</td>\n</tr>\n<tr>\n<td>机器语言虚拟机</td>\n<td>机器语言程序员</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>源程序</strong>通过<strong>编译程序和汇编程序</strong>得到<strong>目标程序</strong></p>\n</li>\n<li>\n<p>编译程序 vs 解释程序（编译程序生成机器码，解释程序生成后立即执行）</p>\n</li>\n</ol>\n<h3 id=\"cpu性能-2\"><a class=\"anchor\" href=\"#cpu性能-2\">#</a> CPU 性能</h3>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        }
    ]
}