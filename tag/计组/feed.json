{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io",
    "items": [
        {
            "id": "https://quas-modo.github.io/2023/02/10/COA/Lecture17-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/",
            "url": "https://quas-modo.github.io/2023/02/10/COA/Lecture17-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/",
            "title": "Lecture17-输入输出",
            "date_published": "2023-02-10T02:30:00.000Z",
            "content_html": "<h1 id=\"lecture17-输入输出\"><a class=\"anchor\" href=\"#lecture17-输入输出\">#</a> Lecture17 - 输入输出</h1>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215162138827.png\" alt=\"image-20221215162138827\" /></p>\n<h2 id=\"外围设备外设-peripheral-device\"><a class=\"anchor\" href=\"#外围设备外设-peripheral-device\">#</a> 外围设备（外设） peripheral device</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215162246908.png\" alt=\"image-20221215162246908\" /></p>\n<h3 id=\"为什么不能把外设连接到系统总线上\"><a class=\"anchor\" href=\"#为什么不能把外设连接到系统总线上\">#</a> 为什么不能把外设连接到系统总线上</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215162410451.png\" alt=\"image-20221215162410451\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215162421591.png\" alt=\"image-20221215162421591\" /></p>\n<p>外设的传送速度过快和过慢都会造成问题</p>\n<h2 id=\"io模块\"><a class=\"anchor\" href=\"#io模块\">#</a> IO 模块</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215162600197.png\" alt=\"image-20221215162600197\" /></p>\n<p>中间商 IO 模块连接外设和系统总线</p>\n<p>IO 模块属于计算机内部系统</p>\n<p>外设不属于计算机内部系统</p>\n<h2 id=\"外围设备的接口\"><a class=\"anchor\" href=\"#外围设备的接口\">#</a> 外围设备的接口</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215162822444.png\" alt=\"image-20221215162822444\" /></p>\n<p>控制逻辑 —— 是外围设备的大脑，控制外围设备的操作</p>\n<p>缓冲器 —— 用于缓存</p>\n<p>转换器 —— 将 01 数据转换成如音频等数据</p>\n<h2 id=\"io模块的功能\"><a class=\"anchor\" href=\"#io模块的功能\">#</a> IO 模块的功能</h2>\n<h3 id=\"处理器-设备通信\"><a class=\"anchor\" href=\"#处理器-设备通信\">#</a> 处理器、设备通信</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215163514224.png\" alt=\"image-20221215163514224\" /></p>\n<p>中间商 IO 模块需要和处理器进行通信</p>\n<p>也需要和设备进行通信</p>\n<h3 id=\"数据缓冲\"><a class=\"anchor\" href=\"#数据缓冲\">#</a> 数据缓冲</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215163722989.png\" alt=\"image-20221215163722989\" /></p>\n<p>处理器的速度和外设的速度不是完全匹配的</p>\n<p>所以需要在两者之间做一个缓冲</p>\n<h3 id=\"控制和定时\"><a class=\"anchor\" href=\"#控制和定时\">#</a> 控制和定时</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215163924983.png\" alt=\"image-20221215163924983\" /></p>\n<h3 id=\"检错\"><a class=\"anchor\" href=\"#检错\">#</a> 检错</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215164007590.png\" alt=\"image-20221215164007590\" /></p>\n<h2 id=\"io模块的结构\"><a class=\"anchor\" href=\"#io模块的结构\">#</a> IO 模块的结构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215164039061.png\" alt=\"image-20221215164039061\" /></p>\n<p>下面的图做了 90 度的旋转</p>\n<p>CPU 对外部设备的命令：数据线 —— 状态 / 控制寄存器</p>\n<p>外设获得的状态和数据也通过数据线的状态控制寄存器返回</p>\n<p>CPU 对 IO 模块的控制：控制线</p>\n<h2 id=\"外部接口\"><a class=\"anchor\" href=\"#外部接口\">#</a> 外部接口</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215164455676.png\" alt=\"image-20221215164455676\" /></p>\n<p>哪种用的更多？现在主要用的是串行接口</p>\n<p>当使用并行的时候，需要保持信息同步，比较困难。如何防止？一、不要走太远，线的长度不太长；二、两个操作之间的时间间隔长一点，频率不要太高</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215164900238.png\" alt=\"image-20221215164900238\" /></p>\n<h2 id=\"io操作技术\"><a class=\"anchor\" href=\"#io操作技术\">#</a> IO 操作技术</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215165000866.png\" alt=\"image-20221215165000866\" /></p>\n<ul>\n<li>编程式 IO：通过程序处理</li>\n<li>中断驱动式 IO：根据 IO 发起的中断</li>\n<li>直接存储器读取：不需要处理器</li>\n</ul>\n<p>编程式 IO 不需要中断，其他需要</p>\n<p>DMA 不需要处理器干涉，其他需要</p>\n<h3 id=\"编程式io\"><a class=\"anchor\" href=\"#编程式io\">#</a> 编程式 IO</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215165329903.png\" alt=\"image-20221215165329903\" /></p>\n<p>CPU 始终参与 IO，不能分身干别的事情。参与率为 100%。不断读取状态信息，不断读进字，并且写入存储器。</p>\n<h4 id=\"io命令\"><a class=\"anchor\" href=\"#io命令\">#</a> IO 命令</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215165626309.png\" alt=\"image-20221215165626309\" /></p>\n<p>命令：IO 控制外设</p>\n<h4 id=\"io指令\"><a class=\"anchor\" href=\"#io指令\">#</a> IO 指令</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215165838054.png\" alt=\"image-20221215165838054\" /></p>\n<p>指令：IO 自己的指令？</p>\n<p>编址方式：</p>\n<ol>\n<li>存储器映射式：缺点是会占用一些存储单元</li>\n<li>分离式</li>\n</ol>\n<h3 id=\"中断驱动式io\"><a class=\"anchor\" href=\"#中断驱动式io\">#</a> 中断驱动式 IO</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215170021274.png\" alt=\"image-20221215170021274\" /></p>\n<p>和编程式 IO 的区别在于：可以去处理其他工作</p>\n<p>IO 模块等到消息之后，再告诉 CPU 去处理</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215170215789.png\" alt=\"image-20221215170215789\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215170316581.png\" alt=\"image-20221215170316581\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215170351320.png\" alt=\"image-20221215170351320\" /></p>\n<p>为什么会有中断允许和中断禁止？能够一下子保存完现场吗？不能，搬家的时候不能被打断，此时禁止中断，搬回来恢复现场的时候，也需要禁止中断。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215171211567.png\" alt=\"image-20221215171211567\" /></p>\n<p>响应优先级 —— 更快地抢到位置，小伙子</p>\n<p>处理优先级 —— 最后能够获得这个位置，老太太</p>\n<p>响应和处理优先级都很高，说明是个腿脚麻利的老太太</p>\n<p>中断只会识别比自己<strong>处理优先级</strong>更高的中断，小伙子要给老太太让座</p>\n<p>有好多中断，先筛选出处理优先级比自己高的，优先响应响应优先级最高的，最后拿到的是处理优先级最高的</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215171758513.png\" alt=\"image-20221215171758513\" /></p>\n<p>掩码字表示谁可以屏蔽谁，表格中，行能否屏蔽列的（根据处理优先级）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215172349168.png\" alt=\"image-20221215172349168\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215172430080.png\" alt=\"image-20221215172430080\" /></p>\n<h3 id=\"直接存储器存取dma\"><a class=\"anchor\" href=\"#直接存储器存取dma\">#</a> 直接存储器存取 DMA</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215172458552.png\" alt=\"image-20221215172458552\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215172714445.png\" alt=\"image-20221215172714445\" /></p>\n<p>CPU 和 DMA 都需要访问内存，DMA 比 CPU 优先，DMA 一般连接的是高速外设，如果不写入存储，会被冲突掉。</p>\n<h4 id=\"cpu停止法\"><a class=\"anchor\" href=\"#cpu停止法\">#</a> CPU 停止法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173043201.png\" alt=\"image-20221215173043201\" /></p>\n<p>高速 IO 设备一般不会持续传入数据，DMA 占用期间，内存没有被有效利用</p>\n<h4 id=\"周期窃取\"><a class=\"anchor\" href=\"#周期窃取\">#</a> 周期窃取</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173247844.png\" alt=\"image-20221215173247844\" /></p>\n<h4 id=\"交替分时访问\"><a class=\"anchor\" href=\"#交替分时访问\">#</a> 交替分时访问</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173407670.png\" alt=\"image-20221215173407670\" /></p>\n<p>周期的固定时间给 CPU，周期的后半段给 DMA</p>\n<h4 id=\"dma配置机制单总线分离dma\"><a class=\"anchor\" href=\"#dma配置机制单总线分离dma\">#</a> DMA 配置机制：单总线分离 DMA</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173502792.png\" alt=\"image-20221215173502792\" /></p>\n<h4 id=\"dma配置机制单总线集合的dma-io\"><a class=\"anchor\" href=\"#dma配置机制单总线集合的dma-io\">#</a> DMA 配置机制：单总线集合的 DMA-IO</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173553642.png\" alt=\"image-20221215173553642\" /></p>\n<h4 id=\"dma配置机制io总线\"><a class=\"anchor\" href=\"#dma配置机制io总线\">#</a> DMA 配置机制：IO 总线</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173648304.png\" alt=\"image-20221215173648304\" /></p>\n<h4 id=\"dma示例硬盘存取\"><a class=\"anchor\" href=\"#dma示例硬盘存取\">#</a> DMA 示例：硬盘存取</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215173739716.png\" alt=\"image-20221215173739716\" /></p>\n<p>CPU 仍然有比较高的参与度</p>\n<h2 id=\"io模块的演变\"><a class=\"anchor\" href=\"#io模块的演变\">#</a> IO 模块的演变</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221215174200623.png\" alt=\"image-20221215174200623\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2023/02/10/COA/Lecture16-%E6%8E%A7%E5%88%B6%E5%99%A8/",
            "url": "https://quas-modo.github.io/2023/02/10/COA/Lecture16-%E6%8E%A7%E5%88%B6%E5%99%A8/",
            "title": "Lecture16-控制器",
            "date_published": "2023-02-10T02:29:47.000Z",
            "content_html": "<h1 id=\"lecture16-控制器\"><a class=\"anchor\" href=\"#lecture16-控制器\">#</a> Lecture16 - 控制器</h1>\n<h2 id=\"处理器结构\"><a class=\"anchor\" href=\"#处理器结构\">#</a> 处理器结构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214082920259.png\" alt=\"image-20221214082920259\" /></p>\n<h2 id=\"寄存器\"><a class=\"anchor\" href=\"#寄存器\">#</a> 寄存器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214082928649.png\" alt=\"image-20221214082928649\" /></p>\n<p>用户可见寄存器允许编程人员访问，用户是指编程人员</p>\n<p>控制和状态寄存器大多数是用户不可见的</p>\n<p>两者的界限并不分明</p>\n<h3 id=\"用户可见寄存器\"><a class=\"anchor\" href=\"#用户可见寄存器\">#</a> 用户可见寄存器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214082938186.png\" alt=\"image-20221214082938186\" /></p>\n<p>条件码寄存器是至少部分用户可见，但同时构成了控制器。</p>\n<p>条件码寄存器不是必须的，优点是有些指令会变得简单，缺点是硬件复杂度会变高。</p>\n<h4 id=\"设计出发点\"><a class=\"anchor\" href=\"#设计出发点\">#</a> 设计出发点</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214082953212.png\" alt=\"image-20221214082953212\" /></p>\n<ol>\n<li>特定还是通用：影响指令集的设计，比如，算数指令指定将结果存放在特定寄存器中，可以减少操作数；三操作数会更加的灵活</li>\n<li>太少，寄存器不够用；太多，效率未必提高，成本上升</li>\n<li>越长，成本越高</li>\n</ol>\n<h4 id=\"保存和恢复\"><a class=\"anchor\" href=\"#保存和恢复\">#</a> 保存和恢复</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083002741.png\" alt=\"image-20221214083002741\" /></p>\n<h3 id=\"控制和状态寄存器\"><a class=\"anchor\" href=\"#控制和状态寄存器\">#</a> 控制和状态寄存器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083013320.png\" alt=\"image-20221214083013320\" /></p>\n<ul>\n<li>PC + 1 或者重新加载</li>\n<li>IR</li>\n<li>MAR</li>\n<li>MBR</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083019626.png\" alt=\"image-20221214083019626\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083026843.png\" alt=\"image-20221214083026843\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083033886.png\" alt=\"image-20221214083033886\" /></p>\n<p>更多的寄存器，更少的访问主存 or 更多的信息放在主存中，更少地访问寄存器</p>\n<h2 id=\"微操作\"><a class=\"anchor\" href=\"#微操作\">#</a> 微操作</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083042489.png\" alt=\"image-20221214083042489\" /></p>\n<h3 id=\"取指周期\"><a class=\"anchor\" href=\"#取指周期\">#</a> 取指周期</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083049177.png\" alt=\"image-20221214083049177\" /></p>\n<p>左边是微操作，右边是示意图。</p>\n<ol>\n<li>a - b : PC 的地址 copy 到 MAR，MAR 和 PC 中的内容一样</li>\n<li>b - c : PC 加 1，将存储器中的数据中放入 MBR</li>\n<li>c - d  : 将 MBR 的内容让如 IR（指令寄存器）</li>\n</ol>\n<p>PC + 1 可以放到第三个指令周期吗？ 可以，微操作是不唯一的</p>\n<h3 id=\"微操作分组原则\"><a class=\"anchor\" href=\"#微操作分组原则\">#</a> 微操作分组原则</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083058428.png\" alt=\"image-20221214083058428\" /></p>\n<p>避免冲突 —— 不能在一个周期里对同一个寄存器进行读和写的操作</p>\n<p>可以把 PC+1 另外开一个周期吗？不可以，这样太耗时了</p>\n<h3 id=\"间址周期\"><a class=\"anchor\" href=\"#间址周期\">#</a> 间址周期</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083108027.png\" alt=\"image-20221214083108027\" /></p>\n<h3 id=\"执行周期\"><a class=\"anchor\" href=\"#执行周期\">#</a> 执行周期</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083119118.png\" alt=\"image-20221214083119118\" /></p>\n<h3 id=\"中断周期\"><a class=\"anchor\" href=\"#中断周期\">#</a> 中断周期</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083127732.png\" alt=\"image-20221214083127732\" /></p>\n<h3 id=\"指令周期代码icc\"><a class=\"anchor\" href=\"#指令周期代码icc\">#</a> 指令周期代码 ICC</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214083136481.png\" alt=\"image-20221214083136481\" /></p>\n<h4 id=\"取指周期-2\"><a class=\"anchor\" href=\"#取指周期-2\">#</a> 取指周期</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085356591.png\" alt=\"image-20221214085356591\" /></p>\n<p>最后一根线都是朝右的</p>\n<h4 id=\"间址周期-2\"><a class=\"anchor\" href=\"#间址周期-2\">#</a> 间址周期</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085405497.png\" alt=\"image-20221214085405497\" /></p>\n<h4 id=\"执行周期-2\"><a class=\"anchor\" href=\"#执行周期-2\">#</a> 执行周期</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085424926.png\" alt=\"image-20221214085424926\" /></p>\n<p>判断操作码，决定执行的指令</p>\n<p>允许中断，进入中断；不允许则继续</p>\n<h4 id=\"中断周期-2\"><a class=\"anchor\" href=\"#中断周期-2\">#</a> 中断周期</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085436183.png\" alt=\"image-20221214085436183\" /></p>\n<h2 id=\"控制器\"><a class=\"anchor\" href=\"#控制器\">#</a> 控制器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085448340.png\" alt=\"image-20221214085448340\" /></p>\n<p>箭头所指即为总线和寄存器之间的门</p>\n<p>MBR 和 AC 中的东西并不能同时放到总线上，因此需要将 MBR 的内容放到 Y 当中，此时可以同时获得两个数据。</p>\n<h3 id=\"控制cpu的功能需求\"><a class=\"anchor\" href=\"#控制cpu的功能需求\">#</a> 控制 CPU 的功能需求</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085459702.png\" alt=\"image-20221214085459702\" /></p>\n<h3 id=\"控制器输入\"><a class=\"anchor\" href=\"#控制器输入\">#</a> 控制器输入</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085522166.png\" alt=\"image-20221214085522166\" /></p>\n<p>指令寄存器：寻址方式（是否有间址周期），不同的操作码决定了不同的微操作顺序</p>\n<p>标志：</p>\n<p>时钟：</p>\n<p>来自控制总线的控制信号：特例 —— 中断请求</p>\n<h3 id=\"控制器的输出\"><a class=\"anchor\" href=\"#控制器的输出\">#</a> 控制器的输出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085535205.png\" alt=\"image-20221214085535205\" /></p>\n<p>二进制输入量 —— 所有的控制信号都是 0 或者 1</p>\n<h3 id=\"取指周期-3\"><a class=\"anchor\" href=\"#取指周期-3\">#</a> 取指周期</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214085545069.png\" alt=\"image-20221214085545069\" /></p>\n<ol>\n<li>红色的线</li>\n<li>绿色的线</li>\n<li>黄色的线</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214103826817.png\" alt=\"image-20221214103826817\" /></p>\n<h3 id=\"控制器的最小特性\"><a class=\"anchor\" href=\"#控制器的最小特性\">#</a> 控制器的最小特性</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214103837622.png\" alt=\"image-20221214103837622\" /></p>\n<p>“少量的”</p>\n<h2 id=\"控制器实现\"><a class=\"anchor\" href=\"#控制器实现\">#</a> 控制器实现</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214103846854.png\" alt=\"image-20221214103846854\" /></p>\n<h3 id=\"硬布线\"><a class=\"anchor\" href=\"#硬布线\">#</a> 硬布线</h3>\n<h4 id=\"硬布线控制器输入\"><a class=\"anchor\" href=\"#硬布线控制器输入\">#</a> 硬布线：控制器输入</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214103947835.png\" alt=\"image-20221214103947835\" /></p>\n<p>左边 I1-I4 输入</p>\n<p>右边 O1-O16 输出</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104031247.png\" alt=\"image-20221214104031247\" /></p>\n<h4 id=\"硬布线控制器逻辑\"><a class=\"anchor\" href=\"#硬布线控制器逻辑\">#</a> 硬布线：控制器逻辑</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104049524.png\" alt=\"image-20221214104049524\" /></p>\n<p>PQ 的非表示 00，表取指周期</p>\n<p>非 P Q 表示 01，表间址周期</p>\n<p>P 非 Q 表示 10，表执行周期，某些操作需要用到 C5</p>\n<p>缺点：指令表示会越来越复杂，硬件结构变复杂，集成度降低</p>\n<h3 id=\"微程序实现\"><a class=\"anchor\" href=\"#微程序实现\">#</a> 微程序实现</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104058952.png\" alt=\"image-20221214104058952\" /></p>\n<p>固件</p>\n<p>每个周期产生一组控制信号（二进制数字），然后将这些二进制子串串在一起，得到微操作序列</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104108689.png\" alt=\"image-20221214104108689\" /></p>\n<p>每个时钟周期，将 CPU 内部控制信号和系统总线控制信号取出，放到控制线上，发出控制信号，各门判断是否执行。</p>\n<p>分支条件判断是否跳转。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104120970.png\" alt=\"image-20221214104120970\" /></p>\n<p>对于相同的操作码，有相同的微程序序列</p>\n<h4 id=\"微程序控制器任务\"><a class=\"anchor\" href=\"#微程序控制器任务\">#</a> 微程序控制器：任务</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104131939.png\" alt=\"image-20221214104131939\" /></p>\n<p>主要任务为定序和执行</p>\n<h4 id=\"微程序控制器定序\"><a class=\"anchor\" href=\"#微程序控制器定序\">#</a> 微程序控制器：定序</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104140191.png\" alt=\"image-20221214104140191\" /></p>\n<h4 id=\"微程序控制器构成\"><a class=\"anchor\" href=\"#微程序控制器构成\">#</a> 微程序控制器：构成</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104148310.png\" alt=\"image-20221214104148310\" /></p>\n<h4 id=\"微程序控制器工作流程\"><a class=\"anchor\" href=\"#微程序控制器工作流程\">#</a> 微程序控制器：工作流程</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104157493.png\" alt=\"image-20221214104157493\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104207337.png\" alt=\"image-20221214104207337\" /></p>\n<p>上一张 ppt，最后一步生成地址有三种选择</p>\n<p>在微指令进行编码，缩短微指令，在译码器中进行译码</p>\n<h4 id=\"微程序实现优点与缺点\"><a class=\"anchor\" href=\"#微程序实现优点与缺点\">#</a> 微程序实现：优点与缺点</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104216464.png\" alt=\"image-20221214104216464\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221214104225289.png\" alt=\"image-20221214104225289\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2023/02/10/COA/Lecture15-%E5%91%A8%E6%9C%9F/",
            "url": "https://quas-modo.github.io/2023/02/10/COA/Lecture15-%E5%91%A8%E6%9C%9F/",
            "title": "Lecture15-周期",
            "date_published": "2023-02-10T02:28:23.000Z",
            "content_html": "<h1 id=\"lecture15-指令周期\"><a class=\"anchor\" href=\"#lecture15-指令周期\">#</a> Lecture15 - 指令周期</h1>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202123948768.png\" alt=\"image-20221202123948768\" /></p>\n<h2 id=\"指令周期状态图\"><a class=\"anchor\" href=\"#指令周期状态图\">#</a> 指令周期：状态图</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202124110716.png\" alt=\"image-20221202124110716\" /></p>\n<p>取址周期：取指令</p>\n<p>执行周期：其他都是执行指令</p>\n<p>“返回字符串或向量数据” —— 不断地取出字符串的东西进行操作 ？</p>\n<h2 id=\"带中断的指令周期\"><a class=\"anchor\" href=\"#带中断的指令周期\">#</a> 带中断的指令周期</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202124730176.png\" alt=\"image-20221202124730176\" /></p>\n<p>在每次周期内检查一次中断</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202124830201.png\" alt=\"image-20221202124830201\" /></p>\n<h2 id=\"间址周期\"><a class=\"anchor\" href=\"#间址周期\">#</a> 间址周期</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202124918105.png\" alt=\"image-20221202124918105\" /></p>\n<p>” 间接地址的读取 “看做一个子周期</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202125050866.png\" alt=\"image-20221202125050866\" /></p>\n<h2 id=\"cpu的任务\"><a class=\"anchor\" href=\"#cpu的任务\">#</a> CPU 的任务</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202125225380.png\" alt=\"image-20221202125225380\" /></p>\n<h2 id=\"cpu需求寄存器\"><a class=\"anchor\" href=\"#cpu需求寄存器\">#</a> CPU 需求：寄存器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202125354584.png\" alt=\"image-20221202125354584\" /></p>\n<p>MAR 地址寄存器 Memory Address Register</p>\n<p>MBR 缓冲寄存器 Memory Buffer Register</p>\n<p>MDR 数据寄存器 Memory Data Register</p>\n<p>PC 程序计数器 Program Counter</p>\n<p>IR 指令寄存器 Instruction Register</p>\n<h2 id=\"数据流取指周期\"><a class=\"anchor\" href=\"#数据流取指周期\">#</a> 数据流：取指周期</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202125623143.png\" alt=\"image-20221202125623143\" /></p>\n<p>红线：PC 通过 MAR 将地址放到地址总线上</p>\n<p>绿线：控制器告诉存储器地址已经准备好了</p>\n<p>黄线：存储器从地址总线读取地址</p>\n<p>数据准备好之后：</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202125900089.png\" alt=\"image-20221202125900089\" /></p>\n<p>存储器将数据放在数据总线上，进而放在 MBR，然后放到 IR 中</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202125945117.png\" alt=\"image-20221202125945117\" /></p>\n<p>控制器取下一条指令</p>\n<p>控制器取完下一条指令之后，告诉 PC 加 1</p>\n<h2 id=\"数据流间址周期\"><a class=\"anchor\" href=\"#数据流间址周期\">#</a> 数据流：间址周期</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202130122928.png\" alt=\"image-20221202130122928\" /></p>\n<p>MBR 中存取的是间接地址，与之前类似，地址类源于 MBR 而不是 PC</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202130246666.png\" alt=\"image-20221202130246666\" /></p>\n<p>取出来的不是操作数，而是<strong>有效地址</strong></p>\n<h2 id=\"数据流中断周期\"><a class=\"anchor\" href=\"#数据流中断周期\">#</a> 数据流：中断周期</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202130353561.png\" alt=\"image-20221202130353561\" /></p>\n<p>在进行写操作</p>\n<p>保存 PC 中的内容，需要知道返回到哪里</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202130713833.png\" alt=\"image-20221202130713833\" /></p>\n<p>控制器告诉 MAR 返回地址存在哪里（可能是一个栈的指针）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202130757927.png\" alt=\"image-20221202130757927\" /></p>\n<p>控制器通知存储器写入返回地址</p>\n<h2 id=\"指令流水线\"><a class=\"anchor\" href=\"#指令流水线\">#</a> 指令流水线</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164145096.png\" alt=\"image-20221208164145096\" /></p>\n<h3 id=\"两阶段方法\"><a class=\"anchor\" href=\"#两阶段方法\">#</a> 两阶段方法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164300599.png\" alt=\"image-20221208164300599\" /></p>\n<p>时间分配不均匀，取指令太闲，执行执行太忙。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164316928.png\" alt=\"image-20221208164316928\" /></p>\n<p>取指令和执行指令都需要访问内存、取地址，所以会造成访问冲突。</p>\n<p>等待：条件分支指令导致地址可能取的不对，前面取的地址作废。</p>\n<h3 id=\"六阶段方法\"><a class=\"anchor\" href=\"#六阶段方法\">#</a> 六阶段方法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164340282.png\" alt=\"image-20221208164340282\" /></p>\n<p>后面五个是把执行指令拆成了五个去完成。</p>\n<p>解决了两个阶段处理时间分配严重不平衡。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164408405.png\" alt=\"image-20221208164408405\" /></p>\n<p>好处：大大缩减了时间单位。</p>\n<h4 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164414492.png\" alt=\"image-20221208164414492\" /></p>\n<ol>\n<li>LOAD 不需要 WO 写操作数。</li>\n</ol>\n<p>​\t\t不需要给特殊的指令设计特殊的流水线，从硬件设计的角度来说，不划算。没有这个阶段就不执行。</p>\n<ol start=\"2\">\n<li>不是所有阶段都可以并行完成</li>\n<li>虽然不像两个阶段的差异那么大，但是六个阶段的时间还是有差异的，以每个流水阶段的最长的为基础</li>\n</ol>\n<h4 id=\"限制条件转移指令\"><a class=\"anchor\" href=\"#限制条件转移指令\">#</a> 限制：条件转移指令</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164421148.png\" alt=\"image-20221208164421148\" /></p>\n<p>红框框出的指令执行无效。</p>\n<h4 id=\"限制中断\"><a class=\"anchor\" href=\"#限制中断\">#</a> 限制：中断</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164429518.png\" alt=\"image-20221208164429518\" /></p>\n<p>操作：排空流水线</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164441209.png\" alt=\"image-20221208164441209\" /></p>\n<p>只能在时钟上升沿进行操作，可以有效避免噪声</p>\n<h3 id=\"流水线性能\"><a class=\"anchor\" href=\"#流水线性能\">#</a> 流水线性能</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208164501181.png\" alt=\"image-20221208164501181\" /></p>\n<p>锁存延时：锁数据，先放入寄存器，再从寄存器中取出来</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208165818734.png\" alt=\"image-20221208165818734\" /></p>\n<p>对应理想情况下的阶梯。</p>\n<p>第一条指令需要 k 个 t，后面（n-1）条每条时间长度多一个 t。</p>\n<p>加速比：评价流水线性能好坏的标准。用没有使用流水线的时间除以使用了流水线的时间。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208170539117.png\" alt=\"image-20221208170539117\" /></p>\n<p>（误解）指令越多，k 越大，加速因子越大。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208170745357.png\" alt=\"image-20221208170745357\" /></p>\n<ol>\n<li>\n<p>d 锁存延时会累计。</p>\n</li>\n<li>\n<p>冲突会累计</p>\n</li>\n</ol>\n<h2 id=\"冒险hazard\"><a class=\"anchor\" href=\"#冒险hazard\">#</a> 冒险 Hazard</h2>\n<p>阻塞或停顿</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208170755086.png\" alt=\"image-20221208170755086\" /></p>\n<h3 id=\"结构冒险\"><a class=\"anchor\" href=\"#结构冒险\">#</a> 结构冒险</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208170821493.png\" alt=\"image-20221208170821493\" /></p>\n<p>红色：使用不同的硬件资源（数据和地址使用不同的寄存器、使用了 cache）</p>\n<p>蓝色：分时复用，一个在上升沿使用，一个在下降沿使用。本身阶段所需时间就比较短，可以一起操作。</p>\n<h3 id=\"数据冒险\"><a class=\"anchor\" href=\"#数据冒险\">#</a> 数据冒险.</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208170931423.png\" alt=\"image-20221208170931423\" /></p>\n<p>r1 在第一条是结果，但是在下面的指令中是操作数</p>\n<h4 id=\"插入nop指令\"><a class=\"anchor\" href=\"#插入nop指令\">#</a> 插入 nop 指令</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171343426.png\" alt=\"image-20221208171343426\" /></p>\n<p>等待</p>\n<h4 id=\"插入bubble\"><a class=\"anchor\" href=\"#插入bubble\">#</a> 插入 bubble</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171353814.png\" alt=\"image-20221208171353814\" /></p>\n<p>有时间开销</p>\n<h4 id=\"转发-旁路\"><a class=\"anchor\" href=\"#转发-旁路\">#</a> 转发 旁路</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171404416.png\" alt=\"image-20221208171404416\" /></p>\n<p>重点</p>\n<p>其实 ALU 已经算出来结果了，不需要等待 WB 写回。</p>\n<p>用到 R1 的时候，可以从别的地方拿过来，不需要等待。</p>\n<h4 id=\"交换指令顺序\"><a class=\"anchor\" href=\"#交换指令顺序\">#</a> 交换指令顺序</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171410311.png\" alt=\"image-20221208171410311\" /></p>\n<p>旁路什么时候有效？后面的数据是算出来的。</p>\n<p>但是 load 拿出来的数据，是要等到 WB 的，此时旁路失效。</p>\n<p>把一个跟前面没有关系的指令提前执行。</p>\n<h3 id=\"控制冒险\"><a class=\"anchor\" href=\"#控制冒险\">#</a> 控制冒险</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171422760.png\" alt=\"image-20221208171422760\" /></p>\n<p>取错指令了</p>\n<h4 id=\"取多条指令枚举\"><a class=\"anchor\" href=\"#取多条指令枚举\">#</a> 取多条指令（枚举？）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171750679.png\" alt=\"image-20221208171750679\" /></p>\n<p>有限的，分支太多就数量爆炸了</p>\n<p>循环缓冲器：缓存一个数量</p>\n<h4 id=\"分支预测猜得更对一点\"><a class=\"anchor\" href=\"#分支预测猜得更对一点\">#</a> 分支预测（猜得更对一点）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171757176.png\" alt=\"image-20221208171757176\" /></p>\n<ol>\n<li>静态预测：与历史指令无关，简单但是效果不好</li>\n<li>动态预测：</li>\n</ol>\n<h5 id=\"动态预测\"><a class=\"anchor\" href=\"#动态预测\">#</a> 动态预测</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171802869.png\" alt=\"image-20221208171802869\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171809307.png\" alt=\"image-20221208171809307\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221208171817588.png\" alt=\"image-20221208171817588\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/12/02/COA/Lecture14-%E6%8C%87%E4%BB%A4/",
            "url": "https://quas-modo.github.io/2022/12/02/COA/Lecture14-%E6%8C%87%E4%BB%A4/",
            "title": "Lecture14-指令系统",
            "date_published": "2022-12-02T06:35:51.000Z",
            "content_html": "<p>操作码、操作数、寻址方式</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture14-指令系统\"><a class=\"anchor\" href=\"#lecture14-指令系统\">#</a> Lecture14 - 指令系统</h1>\n<p>对应教材</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202131829598.png\" alt=\"image-20221202131829598\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201161740120.png\" alt=\"image-20221201161740120\" /></p>\n<h2 id=\"指令\"><a class=\"anchor\" href=\"#指令\">#</a> 指令</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201161814535.png\" alt=\"image-20221201161814535\" /></p>\n<h3 id=\"指令要素\"><a class=\"anchor\" href=\"#指令要素\">#</a> 指令要素</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201162521172.png\" alt=\"image-20221201162521172\" /></p>\n<h3 id=\"指令表示\"><a class=\"anchor\" href=\"#指令表示\">#</a> 指令表示</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201162651133.png\" alt=\"image-20221201162651133\" /></p>\n<p>如何避免指令的二义性？</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201162709724.png\" alt=\"image-20221201162709724\" /></p>\n<h3 id=\"例子y-a-b-c-d-e-三两单零地址指令分别是怎么操作的\"><a class=\"anchor\" href=\"#例子y-a-b-c-d-e-三两单零地址指令分别是怎么操作的\">#</a> 例子：Y = (A - B) / (C + D * E ) 三 / 两 / 单 / 零地址指令分别是怎么操作的？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201164205387.png\" alt=\"image-20221201164205387\" /></p>\n<p>三地址：占用更多的指令操作数，但是不需要覆盖</p>\n<p>双地址：有一个地址必须承担双重任务，需要先做一次 “move” 操作</p>\n<p>单地址：第二个地址是隐含的，其隐含地址被称为 “累加器”(Accumulator, AC)</p>\n<p>零地址：空指令、停机指令、中断指令</p>\n<h3 id=\"指令格式扩展操作码\"><a class=\"anchor\" href=\"#指令格式扩展操作码\">#</a> 指令格式：扩展操作码</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202132746822.png\" alt=\"image-20221202132746822\" /></p>\n<h3 id=\"例题如何计算零地址-一地址-二地址指令条数\"><a class=\"anchor\" href=\"#例题如何计算零地址-一地址-二地址指令条数\">#</a> 例题：如何计算零地址、一地址、二地址指令条数？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201163012730.png\" alt=\"image-20221201163012730\" /></p>\n<p>第一问</p>\n<p>​\t16 - 6 - 6 = 4</p>\n<p>​\t2 <sup>4</sup> = 16</p>\n<p>​\t16 - M - N</p>\n<p>第二问（关键是，需要留出至少 1 位标志是零地址或一地址）</p>\n<p>​\t0000-1110</p>\n<p>第三问</p>\n<p>​\t设一地址指令最多由 R 种</p>\n<p>​\tQ = [(2 <sup>4</sup> - P) * 2 <sup>6</sup> - R]* 2 <sup>6</sup></p>\n<p>详细解答：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tLXzIwMTgvYXJ0aWNsZS9kZXRhaWxzLzExMDkxODYwOQ==\">https://blog.csdn.net/KK_2018/article/details/110918609</span></p>\n<h3 id=\"指令格式\"><a class=\"anchor\" href=\"#指令格式\">#</a> 指令格式</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201163040707.png\" alt=\"image-20221201163040707\" /></p>\n<h2 id=\"操作码\"><a class=\"anchor\" href=\"#操作码\">#</a> 操作码</h2>\n<h3 id=\"差异与共性\"><a class=\"anchor\" href=\"#差异与共性\">#</a> 差异与共性</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202132908798.png\" alt=\"image-20221202132908798\" /></p>\n<h3 id=\"操作码数据传送\"><a class=\"anchor\" href=\"#操作码数据传送\">#</a> 操作码：数据传送</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202132933086.png\" alt=\"image-20221202132933086\" /></p>\n<h3 id=\"操作码算数运算\"><a class=\"anchor\" href=\"#操作码算数运算\">#</a> 操作码：算数运算</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202132953492.png\" alt=\"image-20221202132953492\" /></p>\n<h3 id=\"操作码逻辑运算\"><a class=\"anchor\" href=\"#操作码逻辑运算\">#</a> 操作码：逻辑运算</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202133031883.png\" alt=\"image-20221202133031883\" /></p>\n<p>区分逻辑移位和算术移位</p>\n<p><strong>特别关注一下算数左移</strong></p>\n<h3 id=\"操作码输入输出\"><a class=\"anchor\" href=\"#操作码输入输出\">#</a> 操作码：输入输出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202133204651.png\" alt=\"image-20221202133204651\" /></p>\n<h3 id=\"操作码控制转移\"><a class=\"anchor\" href=\"#操作码控制转移\">#</a> 操作码：控制转移</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202133249793.png\" alt=\"image-20221202133249793\" /></p>\n<h4 id=\"分支指令-branch-jump\"><a class=\"anchor\" href=\"#分支指令-branch-jump\">#</a> 分支指令 Branch Jump</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202133454994.png\" alt=\"image-20221202133454994\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201165209301.png\" alt=\"image-20221201165209301\" /></p>\n<p>BR 无条件跳转</p>\n<p>BRE R1 R2 X 判断是否相等</p>\n<p>BRZ 211 如果是 0，那么跳转到 211 的位置</p>\n<p>BRE R1 R2 235 如果 R1 = R2，那么跳转到 235 的位置</p>\n<h4 id=\"跳步指令step\"><a class=\"anchor\" href=\"#跳步指令step\">#</a> 跳步指令 Step</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202133522328.png\" alt=\"image-20221202133522328\" /></p>\n<p>ISZ increment-and-skip-if-zero 加 1 并且若为 0 则跳步</p>\n<p>ISZ R1 如果 R1 是 0，就跳到 311，否则 R1 = R1 + 1</p>\n<p>BR 301 无条件跳转回 301</p>\n<h4 id=\"过程调用指令\"><a class=\"anchor\" href=\"#过程调用指令\">#</a> 过程调用指令</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201170849399.png\" alt=\"image-20221201170849399\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201164024643.png\" alt=\"image-20221201164024643\" /> 什么时候必须使用栈？<strong>递归调用</strong></p>\n<p>PC + deta 为什么是下一条指令的地址？</p>\n<p>三种常用的保存返回地址的位置：<strong>寄存器、被调过程开始处、栈顶部</strong></p>\n<ol>\n<li>\n<p>寄存器：</p>\n<p>缺点是只能单线程调用，支持没有嵌入的调用</p>\n</li>\n<li>\n<p>返回地址存于过程开始处：</p>\n<p>4101 放在 4500，4601 放在 4800，返回 4800 的值到 4601，4651 放到 4800，再返回 4651，返回 4101。</p>\n<p>函数的开头地址不会被修改（只要没有被调用），但是自己调用自己，会造成地址的覆盖</p>\n</li>\n<li>\n<p>使用栈：解决递归的问题</p>\n</li>\n</ol>\n<h2 id=\"操作数\"><a class=\"anchor\" href=\"#操作数\">#</a> 操作数</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202135837472.png\" alt=\"image-20221202135837472\" /></p>\n<h3 id=\"操作数地址\"><a class=\"anchor\" href=\"#操作数地址\">#</a> 操作数：地址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202140015572.png\" alt=\"image-20221202140015572\" /></p>\n<p>零地址、一地址、二地址、三地址的操作数</p>\n<p>指令越短、cpu 越简单</p>\n<p>指令越长、cpu 越复杂、成本上升</p>\n<h3 id=\"操作数数值\"><a class=\"anchor\" href=\"#操作数数值\">#</a> 操作数：数值</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202140222294.png\" alt=\"image-20221202140222294\" /></p>\n<h3 id=\"操作数字符\"><a class=\"anchor\" href=\"#操作数字符\">#</a> 操作数：字符</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202140259609.png\" alt=\"image-20221202140259609\" /></p>\n<h3 id=\"操作数逻辑数据\"><a class=\"anchor\" href=\"#操作数逻辑数据\">#</a> 操作数：逻辑数据</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202140526641.png\" alt=\"image-20221202140526641\" /></p>\n<h3 id=\"操作数大端序和小端序\"><a class=\"anchor\" href=\"#操作数大端序和小端序\">#</a> 操作数：大端序和小端序</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201164946182.png\" alt=\"image-20221201164946182\" /></p>\n<p>大端序 —— 高位放小地址</p>\n<p>小端序 —— 低位放小地址</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202140549149.png\" alt=\"image-20221202140549149\" /></p>\n<p>以字节为单位</p>\n<h3 id=\"操作数引用\"><a class=\"anchor\" href=\"#操作数引用\">#</a> 操作数引用</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141028247.png\" alt=\"image-20221202141028247\" /></p>\n<h2 id=\"寻址方式\"><a class=\"anchor\" href=\"#寻址方式\">#</a> 寻址方式</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201171841509.png\" alt=\"image-20221201171841509\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201171918273.png\" alt=\"image-20221201171918273\" /></p>\n<h3 id=\"记号\"><a class=\"anchor\" href=\"#记号\">#</a> 记号</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141050795.png\" alt=\"image-20221202141050795\" /></p>\n<h3 id=\"立即寻址\"><a class=\"anchor\" href=\"#立即寻址\">#</a> 立即寻址</h3>\n<p>立即寻址（不需要寻址，直接获得数据）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141130201.png\" alt=\"image-20221202141130201\" /></p>\n<p>“直接放在指令里面” 是立即寻址</p>\n<h3 id=\"直接寻址\"><a class=\"anchor\" href=\"#直接寻址\">#</a> 直接寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141210970.png\" alt=\"image-20221202141210970\" /></p>\n<p>直接获得地址</p>\n<p>在当代计算机体系中已不多见</p>\n<h3 id=\"间接寻址\"><a class=\"anchor\" href=\"#间接寻址\">#</a> 间接寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141228399.png\" alt=\"image-20221202141228399\" /></p>\n<p>先到主存，主存中存取了另一个地址</p>\n<h3 id=\"寄存器寻址\"><a class=\"anchor\" href=\"#寄存器寻址\">#</a> 寄存器寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141247348.png\" alt=\"image-20221202141247348\" /></p>\n<p>到寄存器，寄存器中操作数</p>\n<h3 id=\"寄存器间接寻址\"><a class=\"anchor\" href=\"#寄存器间接寻址\">#</a> 寄存器间接寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141326253.png\" alt=\"image-20221202141326253\" /></p>\n<p>参数 - 寄存器 - 主存 - 数据</p>\n<h3 id=\"偏移寻址\"><a class=\"anchor\" href=\"#偏移寻址\">#</a> 偏移寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141350941.png\" alt=\"image-20221202141350941\" /></p>\n<h3 id=\"偏移寻址相对寻址\"><a class=\"anchor\" href=\"#偏移寻址相对寻址\">#</a> 偏移寻址：相对寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141443552.png\" alt=\"image-20221202141443552\" /></p>\n<h3 id=\"偏移寻址基址寄存器寻址\"><a class=\"anchor\" href=\"#偏移寻址基址寄存器寻址\">#</a> 偏移寻址：基址寄存器寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141504937.png\" alt=\"image-20221202141504937\" /></p>\n<h3 id=\"偏移寻址变址寻址\"><a class=\"anchor\" href=\"#偏移寻址变址寻址\">#</a> 偏移寻址：变址寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141537139.png\" alt=\"image-20221202141537139\" /></p>\n<p>IX 变址寄存器</p>\n<p>重复操作</p>\n<p>以上三种相对的对象不同</p>\n<h3 id=\"栈寻址\"><a class=\"anchor\" href=\"#栈寻址\">#</a> 栈寻址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141551627.png\" alt=\"image-20221202141551627\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141630182.png\" alt=\"image-20221202141630182\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141636236.png\" alt=\"image-20221202141636236\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141641806.png\" alt=\"image-20221202141641806\" /></p>\n<h2 id=\"指令格式的设计原则\"><a class=\"anchor\" href=\"#指令格式的设计原则\">#</a> 指令格式的设计原则</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141657479.png\" alt=\"image-20221202141657479\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141719616.png\" alt=\"image-20221202141719616\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141727547.png\" alt=\"image-20221202141727547\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141738268.png\" alt=\"image-20221202141738268\" /></p>\n<h2 id=\"指令集设计\"><a class=\"anchor\" href=\"#指令集设计\">#</a> 指令集设计</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141757763.png\" alt=\"image-20221202141757763\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141802927.png\" alt=\"image-20221202141802927\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141817797.png\" alt=\"image-20221202141817797\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/12/02/COA/Lecture13-%E6%80%BB%E7%BA%BF/",
            "url": "https://quas-modo.github.io/2022/12/02/COA/Lecture13-%E6%80%BB%E7%BA%BF/",
            "title": "Lecture13-总线",
            "date_published": "2022-12-02T06:35:26.000Z",
            "content_html": "<p>总线类型、仲裁、带宽、传输速率、层次结构<br />\n<span id=\"more\"></span></p>\n<h1 id=\"lecture13-总线\"><a class=\"anchor\" href=\"#lecture13-总线\">#</a> Lecture13 - 总线</h1>\n<h2 id=\"类型\"><a class=\"anchor\" href=\"#类型\">#</a> 类型</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164542001.png\" alt=\"image-20221129164542001\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164549696.png\" alt=\"image-20221129164549696\" /></p>\n<p>系统总线 - io 控制器</p>\n<p>通信总线 - io 设备</p>\n<p>地址线和数据线可以复用</p>\n<h2 id=\"总线结构\"><a class=\"anchor\" href=\"#总线结构\">#</a> 总线结构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164619373.png\" alt=\"image-20221129164619373\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164628381.png\" alt=\"image-20221129164628381\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164646312.png\" alt=\"image-20221129164646312\" /></p>\n<h2 id=\"设计要素\"><a class=\"anchor\" href=\"#设计要素\">#</a> 设计要素</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163100682.png\" alt=\"image-20221129163100682\" /></p>\n<h3 id=\"用途\"><a class=\"anchor\" href=\"#用途\">#</a> 用途</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163132214.png\" alt=\"image-20221129163132214\" /></p>\n<p>专用总线： “或”</p>\n<h3 id=\"仲裁\"><a class=\"anchor\" href=\"#仲裁\">#</a> 仲裁</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163146357.png\" alt=\"image-20221129163146357\" /></p>\n<h4 id=\"集中式\"><a class=\"anchor\" href=\"#集中式\">#</a> 集中式</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163331416.png\" alt=\"image-20221129163331416\" /></p>\n<h5 id=\"链式查询\"><a class=\"anchor\" href=\"#链式查询\">#</a> 链式查询</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163345822.png\" alt=\"image-20221129163345822\" /></p>\n<p>橙色 “繁忙” 的是双向箭头</p>\n<p>在总线不忙的时候，才能发起请求，但是一个时钟周期内可能有多个设备发起请求。</p>\n<p>总线仲裁器在总线不忙的时候，才能发起允许信号。</p>\n<p>设备 1 优先级最高，设备 N 优先级最低。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163403728.png\" alt=\"image-20221129163403728\" /></p>\n<p>不能保证公平性 —— 设备 N 很难拿到允许信号</p>\n<p>对电路故障敏感 —— 后面的设备无法判断是前面的设备想使用，还是前面的设备坏了。之前的设备坏了，后面的电路都无法使用。</p>\n<p>限制总线的速度 —— 平均要等待 n <sup>2</sup> / 2 的时间</p>\n<h5 id=\"计数器查询\"><a class=\"anchor\" href=\"#计数器查询\">#</a> 计数器查询</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163732251.png\" alt=\"image-20221129163732251\" /></p>\n<p>与 “链式查询” 相比，绿色（串联的线）变成一条总线。</p>\n<p>报到自己的 ID 则可以占用。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163749814.png\" alt=\"image-20221129163749814\" /></p>\n<h5 id=\"独立请求\"><a class=\"anchor\" href=\"#独立请求\">#</a> 独立请求</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163827636.png\" alt=\"image-20221129163827636\" /></p>\n<p>每个设备都有允许线和请求线。</p>\n<p>只要总线不繁忙，想要请求就可以请求，每个设备没有无谓的等待的时间。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163837822.png\" alt=\"image-20221129163837822\" /></p>\n<h4 id=\"分布式\"><a class=\"anchor\" href=\"#分布式\">#</a> 分布式</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163337594.png\" alt=\"image-20221129163337594\" /></p>\n<h5 id=\"自举式\"><a class=\"anchor\" href=\"#自举式\">#</a> 自举式</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129162852324.png\" alt=\"image-20221129162852324\" /></p>\n<p>自举式（自主选举式）</p>\n<p>向上的箭头 —— 表达自己想要用的请求</p>\n<p>向下的箭头 —— 接受优先级更高的设备是否有想用的请求</p>\n<p>设备 3 的优先级最高</p>\n<p>设备 0 的优先级最低，没有请求线，没有优先级更低的设备去监听请求</p>\n<h5 id=\"冲突检测\"><a class=\"anchor\" href=\"#冲突检测\">#</a> 冲突检测</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129163853249.png\" alt=\"image-20221129163853249\" /></p>\n<p>只要总线空闲，就立刻请求</p>\n<p>&quot;随机时间间隔&quot;</p>\n<h3 id=\"时序\"><a class=\"anchor\" href=\"#时序\">#</a> 时序</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164021701.png\" alt=\"image-20221129164021701\" /></p>\n<p>离散事件、系统动力</p>\n<p>同步时序、异步时序、半同步是一类，分离事务是另外一个</p>\n<p>同步时序：时钟周期</p>\n<p>异步时序：事务的相对顺序</p>\n<h4 id=\"同步时序\"><a class=\"anchor\" href=\"#同步时序\">#</a> 同步时序</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129164211629.png\" alt=\"image-20221129164211629\" /></p>\n<p>约定好，第一个时刻取地址，第二个时刻取数据，etc……</p>\n<p>快的迁就慢的</p>\n<h5 id=\"异步时序\"><a class=\"anchor\" href=\"#异步时序\">#</a> 异步时序</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221130000246383.png\" alt=\"image-20221130000246383\" /></p>\n<p>Ready: 你可以来拿了</p>\n<p>Ack: 我已经拿好了</p>\n<p>都有上升沿和下降沿（在总线上放好了，撤好了）</p>\n<p>非互锁 —— 仅表示前后顺序</p>\n<p>半互锁 ——Ack 上升，Ready 才可以撤，可以防止 Ready 提前撤，Ready 持续等</p>\n<p>全互锁 —— 防止 Ack 先撤，Ready 没接收到持续等</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129165308456.png\" alt=\"image-20221129165308456\" /></p>\n<p>有两根 ready 线，ReadReq 和 DataRdy</p>\n<p>1 CPU 告诉存储器，地址已经准备好</p>\n<p>2 存储器告诉 CPU，已经读取完毕</p>\n<p>3 CPU 收到读取完毕信号，释放 Ready</p>\n<p>4 存储器收到释放完毕的信号，释放 Ack</p>\n<p>5 存储器告诉 CPU，数据已经准备好</p>\n<p>6 CPU 告诉存储器，数据已经读取完毕</p>\n<p>7 存储器释放 Ready 信号</p>\n<p>8 CPU 释放 Ack 信号</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129165321583.png\" alt=\"image-20221129165321583\" /></p>\n<h5 id=\"半同步时序\"><a class=\"anchor\" href=\"#半同步时序\">#</a> 半同步时序</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129171706250.png\" alt=\"image-20221129171706250\" /></p>\n<p>发生在时钟上升沿才认为是有效的</p>\n<h5 id=\"分离事务\"><a class=\"anchor\" href=\"#分离事务\">#</a> 分离事务</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129171714657.png\" alt=\"image-20221129171714657\" /></p>\n<p>中间过程释放给其他设备使用，数据需要准备时间，数据准备好再请求。</p>\n<h3 id=\"总线带宽和数据传输速率\"><a class=\"anchor\" href=\"#总线带宽和数据传输速率\">#</a> 总线带宽和数据传输速率</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129171725186.png\" alt=\"image-20221129171725186\" /></p>\n<p>区分总线带宽和数据传输速率</p>\n<p>总线带宽更偏向于理想状态</p>\n<p>数据传输速率偏向于实际状态（一般求的是数据传输速率）</p>\n<h4 id=\"例题\"><a class=\"anchor\" href=\"#例题\">#</a> 例题</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129171825254.png\" alt=\"image-20221129171825254\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172040507.png\" alt=\"image-20221129172040507\" /></p>\n<p>5 的时候，如果数据准备不好，那么就不能如期进行数据传输</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172437848.png\" alt=\"image-20221129172437848\" /></p>\n<p>同步总线需要使用整数倍的时钟周期</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172451555.png\" alt=\"image-20221129172451555\" /></p>\n<p>每次传输，一个地址。</p>\n<p>64 位宽 —— 每次可以传输两个字</p>\n<p>4 同步读取 并且 cache 降低</p>\n<p>200MHz 时钟频率 ——5ns 时钟周期</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172817342.png\" alt=\"image-20221129172817342\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172827388.png\" alt=\"image-20221129172827388\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172907110.png\" alt=\"image-20221129172907110\" /></p>\n<p>要么提高数据量，要么减少所耗费的时间</p>\n<p>块传输 —— 减少地址时间，减少后面的数据的访问时间</p>\n<p>分离总线事务 —— 一个事务分成两个过程，中间的过程让别的事务来，节省数据准备的时间</p>\n<p>分离地址线和数据线 —— 原先是地址和数据分别传输，现在地址和数据可以同时传输</p>\n<h3 id=\"总线层次结构\"><a class=\"anchor\" href=\"#总线层次结构\">#</a> 总线层次结构</h3>\n<h4 id=\"单总线结构\"><a class=\"anchor\" href=\"#单总线结构\">#</a> 单总线结构</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172920605.png\" alt=\"image-20221129172920605\" /></p>\n<p>车越多，路越堵</p>\n<h4 id=\"双总线结构i\"><a class=\"anchor\" href=\"#双总线结构i\">#</a> 双总线结构 I</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172929509.png\" alt=\"image-20221129172929509\" /></p>\n<p>增加存储器总线</p>\n<p>CPU 和存储器的传输占很大的一部分负担</p>\n<h4 id=\"双总线结构ii\"><a class=\"anchor\" href=\"#双总线结构ii\">#</a> 双总线结构 II</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172936750.png\" alt=\"image-20221129172936750\" /></p>\n<p>增加 IO 总线和 IOP</p>\n<h4 id=\"多总线结构i\"><a class=\"anchor\" href=\"#多总线结构i\">#</a> 多总线结构 I</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172945516.png\" alt=\"image-20221129172945516\" /></p>\n<h4 id=\"多总线结构ii\"><a class=\"anchor\" href=\"#多总线结构ii\">#</a> 多总线结构 II</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129172953025.png\" alt=\"image-20221129172953025\" /></p>\n<p>DMA 总线 (IO 部分会讲)</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129173001369.png\" alt=\"image-20221129173001369\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221129173013477.png\" alt=\"image-20221129173013477\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/12/02/COA/Lecture12-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/",
            "url": "https://quas-modo.github.io/2022/12/02/COA/Lecture12-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/",
            "title": "Lecture12-虚拟存储器",
            "date_published": "2022-12-02T06:34:56.000Z",
            "content_html": "<p>资源调度<br />\n分区方式、分页方式<br />\n虚拟存储器（分页式、分段式、段页式）</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture12-虚拟存储器\"><a class=\"anchor\" href=\"#lecture12-虚拟存储器\">#</a> Lecture12 - 虚拟存储器</h1>\n<p><strong>调度和存储器管理</strong></p>\n<h2 id=\"操作系统的出现\"><a class=\"anchor\" href=\"#操作系统的出现\">#</a> 操作系统的出现</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112310506.png\" alt=\"image-20221128112310506\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112328386.png\" alt=\"image-20221128112328386\" /></p>\n<h2 id=\"存储器管理\"><a class=\"anchor\" href=\"#存储器管理\">#</a> 存储器管理</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112349315.png\" alt=\"image-20221128112349315\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112431728.png\" alt=\"image-20221128112431728\" /></p>\n<h2 id=\"分区\"><a class=\"anchor\" href=\"#分区\">#</a> 分区</h2>\n<h3 id=\"简单固定分区\"><a class=\"anchor\" href=\"#简单固定分区\">#</a> 简单固定分区</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112918126.png\" alt=\"image-20221128112918126\" /></p>\n<h3 id=\"可变长分区\"><a class=\"anchor\" href=\"#可变长分区\">#</a> 可变长分区</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112949961.png\" alt=\"image-20221128112949961\" /></p>\n<p>分区方式会产生碎片的问题</p>\n<h2 id=\"分页\"><a class=\"anchor\" href=\"#分页\">#</a> 分页</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113021152.png\" alt=\"image-20221128113021152\" /></p>\n<p>帧 / 页帧 / 页框 —— 存储器分成相当小的、相等的固定长度的存储块，每个存储块被成为页帧、帧</p>\n<p>页 —— 每个进程划分为小的固定长的程序块，程序的每个程序块成为页</p>\n<p>页表 —— 记录了进程每页的帧地址</p>\n<p>逻辑地址 —— 页号和页中相对地址</p>\n<p>物理地址 —— 帧号和相对地址</p>\n<p>进程和主存划分的块的大小相同</p>\n<h2 id=\"虚拟存储器\"><a class=\"anchor\" href=\"#虚拟存储器\">#</a> 虚拟存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113046823.png\" alt=\"image-20221128113046823\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113150993.png\" alt=\"image-20221128113150993\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113202150.png\" alt=\"image-20221128113202150\" /></p>\n<h3 id=\"分页式虚拟存储器\"><a class=\"anchor\" href=\"#分页式虚拟存储器\">#</a> 分页式虚拟存储器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113349365.png\" alt=\"image-20221128113349365\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113458053.png\" alt=\"image-20221128113458053\" /></p>\n<p>页表存在主存中</p>\n<p>页表存储了所有的序列</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113514924.png\" alt=\"image-20221128113514924\" /></p>\n<p>页表项包括哪些？xxx 位，存放位置按着最长的算，虚页号不算，有可能要进行字节的整数倍的调整</p>\n<p>null—— 空的指针</p>\n<p>PP0\\PP1\\PP2—— 实际上已经存在了主存中</p>\n<p>空的 —— 存在硬盘上，用指针表示位置</p>\n<p>虚拟页号需要放吗？—— 不要，页表存储了所有的序列，获取某一行的信息，只需要去相应的页号检查就可以，虚页的位置是不需要存储的。</p>\n<p>将虚拟页号转换为物理页号，偏移量不变</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113526154.png\" alt=\"image-20221128113526154\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113550866.png\" alt=\"image-20221128113550866\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113539856.png\" alt=\"image-20221128113539856\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113603448.png\" alt=\"image-20221128113603448\" /></p>\n<p>情况 23</p>\n<p>不同的进程，同样的数据块</p>\n<h3 id=\"分段式虚拟存储器\"><a class=\"anchor\" href=\"#分段式虚拟存储器\">#</a> 分段式虚拟存储器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113622258.png\" alt=\"image-20221128113622258\" /></p>\n<h3 id=\"段页式虚拟存储器\"><a class=\"anchor\" href=\"#段页式虚拟存储器\">#</a> 段页式虚拟存储器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113646202.png\" alt=\"image-20221128113646202\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221128113710641.png\" alt=\"image-20221128113710641\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/21/COA/Lecture11-RAID/",
            "url": "https://quas-modo.github.io/2022/11/21/COA/Lecture11-RAID/",
            "title": "Lecture11-RAID",
            "date_published": "2022-11-21T06:06:58.000Z",
            "content_html": "<p>RAID0-6<br />\n 条带、镜像、并行存取（海明码、位交错奇偶校验）、独立存取（块交错奇偶检验、块级分布式奇偶检验、双冗余度）</p>\n<p>并行存取的大数据传输率高，独立存取的 IO 请求快。</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture11-raid\"><a class=\"anchor\" href=\"#lecture11-raid\">#</a> Lecture11-RAID</h1>\n<p>区分高数据传输率和高速 IO 请求</p>\n<h2 id=\"raid冗余磁盘阵列简介redundant-arrays-of-independent-disks\"><a class=\"anchor\" href=\"#raid冗余磁盘阵列简介redundant-arrays-of-independent-disks\">#</a> RAID 冗余磁盘阵列简介 ——Redundant Arrays of Independent Disks</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161456782.png\" alt=\"image-20221117161456782\" /></p>\n<p>Redundant 冗余 —— 进行错误恢复以提高系统可靠性</p>\n<h2 id=\"raid分类\"><a class=\"anchor\" href=\"#raid分类\">#</a> RAID 分类</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161543752.png\" alt=\"image-20221117161543752\" /></p>\n<p>0-6 都是条带式的</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163203515.png\" alt=\"image-20221117163203515\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163224833.png\" alt=\"image-20221117163224833\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163240540.png\" alt=\"image-20221117163240540\" /></p>\n<h3 id=\"raid0-不是raid成员\"><a class=\"anchor\" href=\"#raid0-不是raid成员\">#</a> RAID0 - 不是 RAID 成员</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161726563.png\" alt=\"image-20221117161726563\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221121125725716.png\" alt=\"image-20221121125725716\" /></p>\n<p>如果单个 IO 请求有多个逻辑相邻的条带组成，则多达对 n 个条带的请求可以并行处理，这样大大地减少了 IO 传输时间。</p>\n<h3 id=\"raid1-镜像\"><a class=\"anchor\" href=\"#raid1-镜像\">#</a> RAID1 - 镜像</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161806501.png\" alt=\"image-20221117161806501\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161823895.png\" alt=\"image-20221117161823895\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161835837.png\" alt=\"image-20221117161835837\" /></p>\n<p>大批读请求，速度较快；写请求，与 RAID0 类似。</p>\n<h3 id=\"raid01-vs-raid10\"><a class=\"anchor\" href=\"#raid01-vs-raid10\">#</a> RAID01 VS RAID10</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117161936601.png\" alt=\"image-20221117161936601\" /></p>\n<h4 id=\"如果disk-0和disk-3坏了会怎么样\"><a class=\"anchor\" href=\"#如果disk-0和disk-3坏了会怎么样\">#</a> 如果 Disk 0 和 Disk 3 坏了会怎么样？</h4>\n<ul>\n<li>\n<p>对于 RAID01 来说</p>\n<p>Disk1 损坏，左边的 RAID 0 报废；Disk3 损坏，右边的 RAID 0 报废，整体的 RAID 1 报废</p>\n</li>\n<li>\n<p>对于 RAID10 来说</p>\n<p>Disk1 损坏，左边的 RAID 1 仍能够使用；Disk3 损坏，右边的 RAID 1 仍能够使用，整体的 RAID1 仍能够使用</p>\n</li>\n</ul>\n<p>​\t对于同样的出错，RAID10 仍能够正常运行，但是 RAID1 无法使用，所以 RAID10<strong> 容错率更高</strong></p>\n<h3 id=\"raid2-并行存取\"><a class=\"anchor\" href=\"#raid2-并行存取\">#</a> RAID2 - 并行存取</h3>\n<p>并行存取 —— 所有磁盘成员都参与每个 IO 请求的执行，各个驱动器的轴是<strong>同步旋转</strong>的。</p>\n<p>RAID2 和 RAID3 的<strong>条带非常小</strong>，经常小到一个字节或一个字。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117162002788.png\" alt=\"image-20221117162002788\" /></p>\n<p>读写时，都需要进行校验，读操作要访问所有磁盘，写操作要访问所有数据盘和校验盘。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117162035002.png\" alt=\"image-20221117162035002\" /></p>\n<p>需要时间开销处理海明码</p>\n<h3 id=\"raid3-并行存取\"><a class=\"anchor\" href=\"#raid3-并行存取\">#</a> RAID3 - 并行存取</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117162051620.png\" alt=\"image-20221117162051620\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163754445.png\" alt=\"image-20221117163754445\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163718019.png\" alt=\"image-20221117163718019\" /></p>\n<p>并行存取</p>\n<p>四个盘同时读写</p>\n<p>数据传输率 —— 任何 IO 请求将包含所有数据盘的并行数据传送，对于大量传送，性能改善特别明显。</p>\n<p>面对多个事务 —— 但是一次只能执行一个 IO 请求，在面向事务的环境中，性能将受损。</p>\n<h3 id=\"raid4-独立存取\"><a class=\"anchor\" href=\"#raid4-独立存取\">#</a> RAID4 - 独立存取</h3>\n<p>独立存取阵列更适合与需要高速 IO 请求的应用，而相对较少用于需要高数据传输率的场合。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163553896.png\" alt=\"image-20221117163553896\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163604760.png\" alt=\"image-20221117163604760\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117164749605.png\" alt=\"image-20221117164749605\" /></p>\n<p>独立存取，每个磁盘的操作都是独立的。</p>\n<p>写损失 —— 既要修改数据盘，也要修改校验盘。</p>\n<p>一次写入 包括<strong>两读两写</strong> —— 两次读操作（数据盘、校验盘）、两次写操作（数据盘、校验盘）</p>\n<h3 id=\"raid5-独立存取\"><a class=\"anchor\" href=\"#raid5-独立存取\">#</a> RAID5 - 独立存取</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117163643553.png\" alt=\"image-20221117163643553\" /></p>\n<p>避免潜在的 IO 瓶颈问题 —— 校验条带分开了可以同时读取 (</p>\n<p>读没有影响，写受到限制（还是两读两写</p>\n<h3 id=\"raid50\"><a class=\"anchor\" href=\"#raid50\">#</a> RAID50</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165428182.png\" alt=\"image-20221117165428182\" /></p>\n<h3 id=\"raid6-独立存取-两种不同的奇偶校验码\"><a class=\"anchor\" href=\"#raid6-独立存取-两种不同的奇偶校验码\">#</a> RAID6 - 独立存取 - 两种不同的奇偶校验码</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165615475.png\" alt=\"image-20221117165615475\" /></p>\n<h2 id=\"raid比较\"><a class=\"anchor\" href=\"#raid比较\">#</a> RAID 比较</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165842161.png\" alt=\"image-20221117165842161\" /></p>\n<p>基本需求 —— 快、可用性</p>\n<p>0 和 1 没有达到兼顾</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117165949394.png\" alt=\"image-20221117165949394\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117170009169.png\" alt=\"image-20221117170009169\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221117170031768.png\" alt=\"image-20221117170031768\" /></p>\n<p>一些 callback</p>\n<p>3 和 4 的区别在于，是不是一起转的</p>\n<p>5 和 6 各有优劣</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/15/COA/Lecture10-%E6%A3%80%E9%94%99%E4%B8%8E%E7%BA%A0%E9%94%99/",
            "url": "https://quas-modo.github.io/2022/11/15/COA/Lecture10-%E6%A3%80%E9%94%99%E4%B8%8E%E7%BA%A0%E9%94%99/",
            "title": "Lecture10-检错与纠错",
            "date_published": "2022-11-15T14:18:59.000Z",
            "content_html": "<p>奇偶检验、海明码检验、循环冗余检验 CRC</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture10-校验码\"><a class=\"anchor\" href=\"#lecture10-校验码\">#</a> Lecture10 - 校验码</h1>\n<h2 id=\"差错\"><a class=\"anchor\" href=\"#差错\">#</a> 差错</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110172321805.png\" alt=\"image-20221110172321805\" /></p>\n<h2 id=\"纠错\"><a class=\"anchor\" href=\"#纠错\">#</a> 纠错</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110173954538.png\" alt=\"image-20221110173954538\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110174007085.png\" alt=\"image-20221110174007085\" /></p>\n<h3 id=\"奇偶校验码\"><a class=\"anchor\" href=\"#奇偶校验码\">#</a> 奇偶校验码</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110174244153.png\" alt=\"image-20221110174244153\" /></p>\n<p>奇校验和偶校验的代价和应用场景不同</p>\n<p>偶校验位的产生直接对待发送的数据依次做异或运算就可以得到，而产生奇校验位还要在偶校验电路的输出取非，相对而言，产生<strong>奇校验位的代价高</strong>，速度也相对慢（慢一个逻辑门的时延）</p>\n<p>如果被传输的数据为全 0，此时采用奇校验时，接收端至少会收到 1 个 1，很容易<strong>判断确实有传送发生</strong>；如果采用偶校验，此时收发双方都是 0，不容易判断是否有信号传来。而对于异步传输，因为有停止位的缘故，采用偶校验，接收方也至少能收到 1 个 1，当然，此时采用奇校验也是可以的；</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110175031448.png\" alt=\"image-20221110175031448\" /></p>\n<h3 id=\"汉明码海明码hamming-code\"><a class=\"anchor\" href=\"#汉明码海明码hamming-code\">#</a> 汉明码 / 海明码 Hamming code</h3>\n<h4 id=\"基本思想和处理过程\"><a class=\"anchor\" href=\"#基本思想和处理过程\">#</a> 基本思想和处理过程</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110175242990.png\" alt=\"image-20221110175242990\" /></p>\n<p>C D 通过传输得到 C‘ D’</p>\n<p>在接收端，用 D‘得到 C''，和 C’异或，生成故障字。</p>\n<h4 id=\"校验码长度\"><a class=\"anchor\" href=\"#校验码长度\">#</a> 校验码长度</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110175746481.png\" alt=\"image-20221110175746481\" /></p>\n<p>校验码要能够 cover 数据位一位出错、校验位一位出错和没有差错的情况</p>\n<h4 id=\"故障字的作用\"><a class=\"anchor\" href=\"#故障字的作用\">#</a> 故障字的作用</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163421156.png\" alt=\"image-20221115163421156\" /></p>\n<h4 id=\"数据位的划分\"><a class=\"anchor\" href=\"#数据位的划分\">#</a> 数据位的划分</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163637665.png\" alt=\"image-20221115163637665\" /></p>\n<p>规定 C1-C4 所对应的情况。再排好 D1-D8 的位置。</p>\n<p>例如，1100 对应 C4 和 C3，则就在 C3 和 C4 中取异或。</p>\n<h4 id=\"位安排\"><a class=\"anchor\" href=\"#位安排\">#</a> 位安排</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163906975.png\" alt=\"image-20221115163906975\" /></p>\n<h4 id=\"实例\"><a class=\"anchor\" href=\"#实例\">#</a> 实例</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164310763.png\" alt=\"image-20221115164310763\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164322978.png\" alt=\"image-20221115164322978\" /></p>\n<p>0110  <strong>0</strong>101  <strong>0</strong>0<strong>11</strong></p>\n<p>0111  <strong>0</strong>101  <strong>0</strong>0<strong>11</strong></p>\n<p>0110  <strong>1</strong>101  <strong>0</strong>0<strong>11</strong></p>\n<h3 id=\"码距和纠错理论\"><a class=\"anchor\" href=\"#码距和纠错理论\">#</a> 码距和纠错理论</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163224140.png\" alt=\"image-20221115163224140\" /></p>\n<p><strong>合法编码</strong>是正确的。</p>\n<p><strong>纠错理论</strong>： <code>L - 1 = D + C, D &gt;= C</code></p>\n<p>奇偶校验：</p>\n<ul>\n<li>如果 D 一位发生变化，C 就发生了变化。如果两位发生了变化，则码距已经超过了 2。奇偶校验不具备检测两位错误的能力。</li>\n<li>D 是 1 位，C 是 0 位。</li>\n</ul>\n<p>汉明码校验：</p>\n<ul>\n<li>D 是 1 位，C 也是 1 位</li>\n<li>可以 2 位检测、0 位纠错吗？不可以，用海明码检测基于 “只有一位出现错误” 的假设。比如，如果 1、2 位出现了差错，那么可以对应与 D3 的情况。</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115220739021.png\" alt=\"image-20221115220739021\" /></p>\n<h3 id=\"补充阅读sec-d-ec\"><a class=\"anchor\" href=\"#补充阅读sec-d-ec\">#</a> 补充阅读：SEC-D-EC</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164644225.png\" alt=\"image-20221115164644225\" /></p>\n<p>在海明码中，除了 D4 和 D7 之外，都会影响两位的校验码。</p>\n<p>L - 1 = D + C</p>\n<p>L - 1=  2 + 1</p>\n<p>为了实现两位的检错，需要将码距增加到 4【即添加一个额外的校验位，让数据对应的校验码位数增加到 3 位】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115165141136.png\" alt=\"image-20221115165141136\" /></p>\n<p>D1 和 D2 有问题，C3 和 D5 有问题是同一种显示。</p>\n<p>如何计算单纠错 / 单检错需要的校验位？ 2<sup>k</sup> &gt;= M + K + 1</p>\n<p>如何计算单纠错 / 双检错需要的校验位？2<sup>k-1</sup> &gt;= M + K + 1</p>\n<p>如何计算双纠错 / 双检错需要的校验位？2 <sup>k</sup> &gt;= C<sub>(M+K)</sub><sup>2</sup> + M + K + 1</p>\n<h3 id=\"循环冗余校验crc\"><a class=\"anchor\" href=\"#循环冗余校验crc\">#</a> 循环冗余校验 CRC</h3>\n<h4 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171249746.png\" alt=\"image-20221115171249746\" /></p>\n<p>无论是奇偶校验还是海明码，需要的代价都很高。海明码也是以奇偶检测为手段的。</p>\n<h4 id=\"基本思想和实现\"><a class=\"anchor\" href=\"#基本思想和实现\">#</a> 基本思想和实现</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171316315.png\" alt=\"image-20221115171316315\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115221430300.png\" alt=\"image-20221115221430300\" /></p>\n<h4 id=\"实例-2\"><a class=\"anchor\" href=\"#实例-2\">#</a> 实例</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171421174.png\" alt=\"image-20221115171421174\" /></p>\n<p>接收方也对 1001 做模 2 运算，余数为 0 则无误。【余数为 111，相等于原来的数加上 111 就能够整除 1001】</p>\n<p>1001（x<sup>3</sup> + 1)</p>\n<p>无借位减，等价于<strong>异或运算</strong>。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115172153954.png\" alt=\"image-20221115172153954\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221115214420096.png\" alt=\"image-20221115214420096\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/15/COA/Lecture09-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/",
            "url": "https://quas-modo.github.io/2022/11/15/COA/Lecture09-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/",
            "title": "Lecture09-外部存储器",
            "date_published": "2022-11-15T12:56:09.000Z",
            "content_html": "<p>外部存储器，主要介绍磁盘存储器（结构、读写、数据组织），略带介绍光盘、磁带、快闪存储器。</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"lecture09-外部存储器\"><a class=\"anchor\" href=\"#lecture09-外部存储器\">#</a> Lecture09 - 外部存储器</h1>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109140148221.png\" alt=\"image-20221109140148221\" /></p>\n<h2 id=\"外部存储器简介\"><a class=\"anchor\" href=\"#外部存储器简介\">#</a> 外部存储器简介</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109140744633.png\" alt=\"image-20221109140744633\" /></p>\n<h2 id=\"磁盘存储器\"><a class=\"anchor\" href=\"#磁盘存储器\">#</a> 磁盘存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109140910784.png\" alt=\"image-20221109140910784\" /></p>\n<p>磁盘是一种由<strong>非磁性材料</strong>制成称为衬底（基材）的圆盘，其上涂有一层<strong>磁性材料</strong>。</p>\n<p>磁可以保持稳定。</p>\n<p>玻璃基材有很多优点。</p>\n<p>飞行高度 —— 磁头并不直接接触磁道。飞行高度更低，面对的数据（面积）更小，电磁感应更强，更利于读写数据。磁盘读取很快，如果直接接触，会导致较大的摩擦力，会毁坏磁盘。</p>\n<p>坏道，在无尘环境中修复。（唱片）的针扫到 “灰尘”，会有吱呀吱呀的声音。</p>\n<h3 id=\"磁盘存储器类型\"><a class=\"anchor\" href=\"#磁盘存储器类型\">#</a> 磁盘存储器类型</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109142404842.png\" alt=\"image-20221109142404842\" /></p>\n<p>软盘（读写头在读或写操作时实际地物理接触磁表面，其容量小、使用灵活和价格便宜）</p>\n<h3 id=\"硬磁盘存储器\"><a class=\"anchor\" href=\"#硬磁盘存储器\">#</a> 硬磁盘存储器</h3>\n<h4 id=\"结构轴盘头臂\"><a class=\"anchor\" href=\"#结构轴盘头臂\">#</a> 结构 —— 轴盘头臂</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109142416824.png\" alt=\"image-20221109142416824\" /></p>\n<p>多个盘片，盘间相隔约 1 英寸。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109142429153.png\" alt=\"image-20221109142429153\" /></p>\n<p>大多数磁盘是两面都有可磁化的涂层，称为双面磁盘。</p>\n<p>在上图中，共有 10 个面，有 6 个磁头，中间 4 个是双面的。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143416494.png\" alt=\"image-20221109143416494\" /></p>\n<p>温彻斯特磁盘（温氏磁盘）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143604481.png\" alt=\"image-20221109143604481\" /></p>\n<h4 id=\"读写机制\"><a class=\"anchor\" href=\"#读写机制\">#</a> 读写机制</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143651520.png\" alt=\"image-20221109143651520\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143935791.png\" alt=\"image-20221109143935791\" /></p>\n<p>读写速度由电磁感应的物理速度限制。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109143951017.png\" alt=\"image-20221109143951017\" /></p>\n<p>MR magnetoresistive 磁阻</p>\n<p>红框应该框中 MR 敏感器，MR 敏感器是为了满足更高的读速度的要求而出现。MR 敏感器对磁场较为敏感，需要做<strong>屏蔽机制</strong>，防止周围的磁场造成影响。</p>\n<h4 id=\"数据组织磁道-扇区\"><a class=\"anchor\" href=\"#数据组织磁道-扇区\">#</a> 数据组织 —— 磁道、扇区</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109144841491.png\" alt=\"image-20221109144841491\" /></p>\n<p>每个盘面上有上千个磁道。</p>\n<p>相邻磁道间隙 —— 防止或至少可以减少由于磁头为对准或磁域干扰所引起的错误。</p>\n<p>相邻扇区间隙 —— 避免对系统提出不合理的定位精度要求。</p>\n<p>扇区默认大小为<strong> 512B</strong>。（如果题目中没有说明，则采用默认值 512B）</p>\n<p>编号<strong>从外向里</strong>递增。</p>\n<h5 id=\"cav-constant-angular-velocity-恒定角速度\"><a class=\"anchor\" href=\"#cav-constant-angular-velocity-恒定角速度\">#</a> CAV constant angular velocity 恒定角速度</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109145031875.png\" alt=\"image-20221109145031875\" /></p>\n<p>优点：直接寻址</p>\n<p>缺点：容量限制</p>\n<h5 id=\"multiple-zone-recording-多重区域记录\"><a class=\"anchor\" href=\"#multiple-zone-recording-多重区域记录\">#</a> Multiple zone recording 多重区域记录</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109145505507.png\" alt=\"image-20221109145505507\" /></p>\n<p>同一个区域以相同的角速度转，不同的区域以不同的角速度转。区域可以包含多个磁道（相邻磁道之间的周长相差不大，所以需要隔一些磁道进行分组）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109150942979.png\" alt=\"image-20221109150942979\" /></p>\n<h4 id=\"格式化\"><a class=\"anchor\" href=\"#格式化\">#</a> 格式化</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109151053633.png\" alt=\"image-20221109151053633\" /></p>\n<p>图中，每个扇区有 600 字节，包含 512 字节的数据和磁盘控制器使用的控制信息。</p>\n<p>同步字节 ——ID 域开始特定的 01 序列</p>\n<p>扇区间隙 —— 没有被磁化，既不表示 0，也不表示 1。有延时。</p>\n<p>数据域 ——4096 是主流标准，512 是之前的标准，因为之前需要存储的程序和数据较小，存储大小大会造成碎片化问题。混用的时候，把 4096 分为 8 个区域，共享同一个 ID。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109151105554.png\" alt=\"image-20221109151105554\" /></p>\n<p>快速格式化并没有清除数据，而是标注可写。</p>\n<h4 id=\"io访问时间\"><a class=\"anchor\" href=\"#io访问时间\">#</a> IO 访问时间</h4>\n<h5 id=\"寻道时间-旋转延迟-传送时间\"><a class=\"anchor\" href=\"#寻道时间-旋转延迟-传送时间\">#</a> 寻道时间、旋转延迟、传送时间</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109152850127.png\" alt=\"image-20221109152850127\" /></p>\n<p>旋转延迟 —— 可能刚好到，也可能刚好错过，取平均为<strong>半周</strong></p>\n<p>访问时间 = 寻道时间（如果有） + 旋转延迟 【是到达读写位置所需的时间】</p>\n<p>rpm 转速常用单位 resolution per minute</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153121081.png\" alt=\"image-20221109153121081\" /></p>\n<p>寻道时间只考虑第一个磁道 —— 访问相邻的磁道，磁道很窄、移动时间可以忽略不计</p>\n<h5 id=\"案例\"><a class=\"anchor\" href=\"#案例\">#</a> 案例</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153318387.png\" alt=\"image-20221109153318387\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153631766.png\" alt=\"image-20221109153631766\" /></p>\n<p>1 / (2 * 15000 / 60) = 0.002 s = 2ms【注意单位的统一】</p>\n<p>500 / (500 * 15000 / 60) = 4ms</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153643053.png\" alt=\"image-20221109153643053\" /></p>\n<h4 id=\"磁头寻道-磁盘调度\"><a class=\"anchor\" href=\"#磁头寻道-磁盘调度\">#</a> 磁头寻道、磁盘调度</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153937260.png\" alt=\"image-20221109153937260\" /></p>\n<h5 id=\"先来先服务\"><a class=\"anchor\" href=\"#先来先服务\">#</a> 先来先服务</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154019777.png\" alt=\"image-20221109154019777\" /></p>\n<h5 id=\"最短寻道时间优先\"><a class=\"anchor\" href=\"#最短寻道时间优先\">#</a> 最短寻道时间优先</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154112018.png\" alt=\"image-20221109154112018\" /></p>\n<p>最短寻道时间优先 (SSTF) 算法会导致 “饥饿” 现象发生，因为<strong>只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近</strong>，这种新进程的 I/O 请求必然优先满足（也就是距离磁头当前所在磁道的距离较远的磁道总是得不到访问）。</p>\n<h5 id=\"扫描电梯scan\"><a class=\"anchor\" href=\"#扫描电梯scan\">#</a> 扫描 / 电梯 SCAN</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154319022.png\" alt=\"image-20221109154319022\" /></p>\n<h5 id=\"循环扫描c-scan\"><a class=\"anchor\" href=\"#循环扫描c-scan\">#</a> 循环扫描 C-SCAN</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154329283.png\" alt=\"image-20221109154329283\" /></p>\n<h5 id=\"lookscan算法的升级\"><a class=\"anchor\" href=\"#lookscan算法的升级\">#</a> LOOK (SCAN 算法的升级)</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154745626.png\" alt=\"image-20221109154745626\" /></p>\n<h5 id=\"c-lookc-scan算法的改进\"><a class=\"anchor\" href=\"#c-lookc-scan算法的改进\">#</a> C-LOOK（C-SCAN 算法的改进）</h5>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221109154917267.png\" alt=\"image-20221109154917267\" /></p>\n<h2 id=\"光存储器\"><a class=\"anchor\" href=\"#光存储器\">#</a> 光存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110163221804.png\" alt=\"image-20221110163221804\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110162427440.png\" alt=\"image-20221110162427440\" /></p>\n<h3 id=\"cd和cd-rom\"><a class=\"anchor\" href=\"#cd和cd-rom\">#</a> CD 和 CD-ROM</h3>\n<h4 id=\"制造方法\"><a class=\"anchor\" href=\"#制造方法\">#</a> 制造方法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110162711863.png\" alt=\"image-20221110162711863\" /></p>\n<p>在<strong>凹坑</strong>表面镀上一层高反射材料（一般采用铝，HQCD 采用银合金）</p>\n<h4 id=\"读取\"><a class=\"anchor\" href=\"#读取\">#</a> 读取</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110163548903.png\" alt=\"image-20221110163548903\" /></p>\n<ol>\n<li>\n<p>光传感器检测凹坑与台之间的反射光强弱变化，并将其转换成数字信号。传感器以规整的间隔检测表面。 一个凹坑的开始或结束表示一个 1；间隔之间无标高变动出现时，记录为一个 0。</p>\n</li>\n<li>\n<p>单螺旋式轨道 —— 凹坑被激光以恒定线速度（<strong>CLV</strong>，constant linear velocity）读出</p>\n</li>\n<li>\n<p>CD-ROM 块格式</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164457816.png\" alt=\"image-20221110164457816\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164510136.png\" alt=\"image-20221110164510136\" /></p>\n</li>\n</ol>\n<h4 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164245961.png\" alt=\"image-20221110164245961\" /></p>\n<h3 id=\"cd-r和cd-rw\"><a class=\"anchor\" href=\"#cd-r和cd-rw\">#</a> CD-R 和 CD-RW</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110164727597.png\" alt=\"image-20221110164727597\" /></p>\n<h4 id=\"cd-r\"><a class=\"anchor\" href=\"#cd-r\">#</a> CD-R</h4>\n<p>可刻录 CD—— 一写多读</p>\n<h4 id=\"cd-rw\"><a class=\"anchor\" href=\"#cd-rw\">#</a> CD-RW</h4>\n<p>可重写盘 —— 多写</p>\n<p>使用了<strong>光致相变材料</strong></p>\n<h3 id=\"dvd数字多功能光盘\"><a class=\"anchor\" href=\"#dvd数字多功能光盘\">#</a> DVD 数字多功能光盘</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110165211317.png\" alt=\"image-20221110165211317\" /></p>\n<h3 id=\"高清晰光盘\"><a class=\"anchor\" href=\"#高清晰光盘\">#</a> 高清晰光盘</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110165245610.png\" alt=\"image-20221110165245610\" /></p>\n<p>衍射极限公式：</p>\n<p>波长 lambda 和分辨两点的最小距离 D 正相关</p>\n<h2 id=\"磁带\"><a class=\"anchor\" href=\"#磁带\">#</a> 磁带</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110165638182.png\" alt=\"image-20221110165638182\" /></p>\n<p>磁性材料，有许多磁针，根据磁场方向发生变化。</p>\n<p>磁带顺序读取 —— 依次读取，想要读取前面的必须倒带</p>\n<p>直接存取 —— 不需要顺序读取磁盘上的所有扇区</p>\n<p>并行记录（parallel recording）读写蛇形</p>\n<p>串行记录（serial recording）（蛇形记录 serpentine recording 时串行记录的典型记录技术）</p>\n<p>6-14(a)</p>\n<p>6-14 (b) 为了提高速度，读 - 写头能同时对几个相邻磁道进行读写操作</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171608725.png\" alt=\"image-20221110171608725\" /></p>\n<h2 id=\"快闪存储器\"><a class=\"anchor\" href=\"#快闪存储器\">#</a> 快闪存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171635494.png\" alt=\"image-20221110171635494\" /></p>\n<h2 id=\"u盘和固态硬盘\"><a class=\"anchor\" href=\"#u盘和固态硬盘\">#</a> U 盘和固态硬盘</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171653977.png\" alt=\"image-20221110171653977\" /></p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221110171711344.png\" alt=\"image-20221110171711344\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/11/03/COA/Lecture08-cache/",
            "url": "https://quas-modo.github.io/2022/11/03/COA/Lecture08-cache/",
            "title": "Lecture08-cache",
            "date_published": "2022-11-03T13:03:21.000Z",
            "content_html": "<p>cache 缓存器，解决内存墙问题，是主存部分的副本，设计要素有地址、容量、映射功能、替换算法、写策略、行大小、cache 数目。</p>\n<h1 id=\"lecture08-cache\"><a class=\"anchor\" href=\"#lecture08-cache\">#</a> Lecture08-cache</h1>\n<h2 id=\"cache简介\"><a class=\"anchor\" href=\"#cache简介\">#</a> cache 简介</h2>\n<h3 id=\"存储器层次结构\"><a class=\"anchor\" href=\"#存储器层次结构\">#</a> 存储器层次结构</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164918401.png\" alt=\"image-20221101164918401\" /></p>\n<p>随着层次的下降，每位价格下降，容量增大，存取时间变长，处理器访问存储器的频率降低。</p>\n<p>cache（高速缓存）存储器的目的是使存储器的速度逼近可用的最快存储器的速度。</p>\n<p>多级 cache 一般标注为 L1、L2，通常由动态随机存取存储器（DRAM）构成。</p>\n<h3 id=\"cache存在的意义解决内存墙的问题\"><a class=\"anchor\" href=\"#cache存在的意义解决内存墙的问题\">#</a> cache 存在的意义：解决内存墙的问题</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165310897.png\" alt=\"image-20221101165310897\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165325716.png\" alt=\"image-20221101165325716\" /></p>\n<h3 id=\"cache的基本思路\"><a class=\"anchor\" href=\"#cache的基本思路\">#</a> cache 的基本思路</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164904882.png\" alt=\"image-20221101164904882\" /></p>\n<p>只是主存<strong>部分</strong>信息的<strong>副本</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101170441990.png\" alt=\"image-20221101170441990\" /></p>\n<h3 id=\"cache主存系统的结构\"><a class=\"anchor\" href=\"#cache主存系统的结构\">#</a> cache / 主存系统的结构</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101205028927.png\" alt=\"image-20221101205028927\" /></p>\n<p>主存系统中 ——M 个块，每块有 K 个字</p>\n<p>cache 中 ——m 个块，称作行【控制为 + 标记 + K 个字】</p>\n<p><strong>行的数量远远小于主存储器块的数目 m &lt;&lt; M</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101170954954.png\" alt=\"image-20221101170954954\" /></p>\n<p>传入地址 RA， 最后红线框处的两步为并行操作。</p>\n<h2 id=\"cache的工作流程\"><a class=\"anchor\" href=\"#cache的工作流程\">#</a> cache 的工作流程</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165017905.png\" alt=\"image-20221101165017905\" /></p>\n<ul>\n<li>Hit—— 传送的是<strong>字</strong></li>\n<li>Miss—— 读入 cache 的是<strong>块</strong>，传入 CPU 的是<strong>字</strong></li>\n</ul>\n<h2 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165200894.png\" alt=\"image-20221101165200894\" /></p>\n<h3 id=\"命中还是未命中\"><a class=\"anchor\" href=\"#命中还是未命中\">#</a> 命中还是未命中？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165513269.png\" alt=\"image-20221101165513269\" /></p>\n<p>CPU、cache、主存如何建立地址的一一对应关系？</p>\n<p><strong>标记</strong>是什么？</p>\n<h3 id=\"为什么从内存中读入一个块\"><a class=\"anchor\" href=\"#为什么从内存中读入一个块\">#</a> 为什么从内存中读入一个块？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101165809967.png\" alt=\"image-20221101165809967\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171223532.png\" alt=\"image-20221101171223532\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171836956.png\" alt=\"image-20221101171836956\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101172138850.png\" alt=\"image-20221101172138850\" /></p>\n<p>利用空间局限性，所以把块传入 cache 当中。</p>\n<p>块在 cache 中，则字在 cache 中。</p>\n<p>标记和内存地址之间的关系？</p>\n<h3 id=\"使用cache需要更多的操作为什么还可以节省时间\"><a class=\"anchor\" href=\"#使用cache需要更多的操作为什么还可以节省时间\">#</a> 使用 cache 需要更多的操作，为什么还可以节省时间？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101173524901.png\" alt=\"image-20221101173524901\" /></p>\n<p>Tm 是未命中惩罚</p>\n<p>两个式子都需要理解，下面的式子更方便做题。</p>\n<p>降低 cache 的访问时间与提高命中率矛盾 —— 存的东西多，提高命中率，但是降低了 cache 的访问时间。</p>\n<h4 id=\"避免cache未命中提高命中率\"><a class=\"anchor\" href=\"#避免cache未命中提高命中率\">#</a> 避免 cache 未命中，提高命中率</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101173558232.png\" alt=\"image-20221101173558232\" /></p>\n<p>容量失效 —— 涉及映射规则和替代原则的问题</p>\n<p>冲突失效 —— 例如直接映射中的冲突</p>\n<h2 id=\"cache的设计要素\"><a class=\"anchor\" href=\"#cache的设计要素\">#</a> cache 的设计要素</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101173743177.png\" alt=\"image-20221101173743177\" /></p>\n<h3 id=\"cache地址\"><a class=\"anchor\" href=\"#cache地址\">#</a> cache 地址</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174037678.png\" alt=\"image-20221101174037678\" /></p>\n<p>物理 cache 和逻辑 cache 的比较</p>\n<p>逻辑 cache 访问速度快，但是需要 cache 的每一行增加额外的几位来标记与该地址相关的虚拟地址。</p>\n<h3 id=\"cache容量\"><a class=\"anchor\" href=\"#cache容量\">#</a> cache 容量</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174233373.png\" alt=\"image-20221101174233373\" /></p>\n<p>1k 涨到 16k，命中率有明显的上升，可以解决一些容量失效的额问题，但是再往后，命中率的上升近乎达到峰值。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174537594.png\" alt=\"image-20221101174537594\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174552006.png\" alt=\"image-20221101174552006\" /></p>\n<h3 id=\"映射功能\"><a class=\"anchor\" href=\"#映射功能\">#</a> 映射功能</h3>\n<h4 id=\"直接映射\"><a class=\"anchor\" href=\"#直接映射\">#</a> 直接映射</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101174930231.png\" alt=\"image-20221101174930231\" /></p>\n<p>左边的映射方式可能会造成容量失效的问题。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101175153621.png\" alt=\"image-20221101175153621\" /></p>\n<p>000H 和 080H 对应一个 cache 的行，每隔 8 个就会共用一个 cache 的行。</p>\n<p>稍微真实一点的示例，一个块里面有 16 个字，每个地址差 10H（即为 16）。</p>\n<p>H 是 16 进制的意思。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101175330724.png\" alt=\"image-20221101175330724\" /></p>\n<p>M = 主存的块数</p>\n<p>i = cache 行号（在 cache 中对应的行数）</p>\n<p>j = 主存储器的块号</p>\n<p>C = cache 的行数（cache 总共的行数）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101210831620.png\" alt=\"image-20221101210831620\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101175648891.png\" alt=\"image-20221101175648891\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101213351613.png\" alt=\"image-20221101213351613\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101213323009.png\" alt=\"image-20221101213323009\" /></p>\n<h4 id=\"全相联映射关联映射\"><a class=\"anchor\" href=\"#全相联映射关联映射\">#</a> 全相联映射（关联映射）</h4>\n<p>标记域 + 字域（s+w）位，cache 中的行号不由地址格式决定</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103162237911.png\" alt=\"image-20221103162237911\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101213419743.png\" alt=\"image-20221101213419743\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163021051.png\" alt=\"image-20221103163021051\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163033660.png\" alt=\"image-20221103163033660\" /></p>\n<h4 id=\"组关联映射\"><a class=\"anchor\" href=\"#组关联映射\">#</a> 组关联映射</h4>\n<p>折中方法，体现了直接映射和全相联映射的优点，又避免了两者的缺点。</p>\n<p>标记 + 组（v = 2 <sup>d</sup>）+ 字（块大小 ）。</p>\n<p>一组中有 K 行。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163817034.png\" alt=\"image-20221103163817034\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103163951991.png\" alt=\"image-20221103163951991\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164015137.png\" alt=\"image-20221103164015137\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164147269.png\" alt=\"image-20221103164147269\" /></p>\n<p>小容量适合全关联映射</p>\n<p>大容量适合直接映射</p>\n<p>K 路组关联映射处于两者之间</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172751908.png\" alt=\"image-20221103172751908\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172808723.png\" alt=\"image-20221103172808723\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172844027.png\" alt=\"image-20221103172844027\" /></p>\n<p>两个映射到同一 cache 组的块不可能具有相同的标记数。</p>\n<p>每组两行 (v = m/2, k = 2) 是最常用的组相联结构，与直接映射相比，它明显地提高了命中率。</p>\n<h4 id=\"三种映射方式比较\"><a class=\"anchor\" href=\"#三种映射方式比较\">#</a> 三种映射方式比较</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164308172.png\" alt=\"image-20221103164308172\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164318953.png\" alt=\"image-20221103164318953\" /></p>\n<p>关联度越低，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小。【关联度小，其他三个都小】</p>\n<h3 id=\"替换算法\"><a class=\"anchor\" href=\"#替换算法\">#</a> 替换算法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103164810384.png\" alt=\"image-20221103164810384\" /></p>\n<h4 id=\"常用的替换算法\"><a class=\"anchor\" href=\"#常用的替换算法\">#</a> 常用的替换算法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165206857.png\" alt=\"image-20221103165206857\" /></p>\n<h4 id=\"最近最少使用算法lru\"><a class=\"anchor\" href=\"#最近最少使用算法lru\">#</a> 最近最少使用算法 LRU</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165310688.png\" alt=\"image-20221103165310688\" /></p>\n<p>USE 位为 0，不代表没有数据</p>\n<p>由前文，可以看到，两路组关联映射是最常用的方法，这个实现是很有现实意义的举例。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165326712.png\" alt=\"image-20221103165326712\" /></p>\n<p>最后一个 1110 的替换，LRU 最大为 3 的位置被替换，其他得未被访问的行的 LRU 自增 1。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpYW9waWFvbGFuZ2h1YS9hcnRpY2xlL2RldGFpbHMvOTM4NDA0Mw==\">https://blog.csdn.net/piaopiaolanghua/article/details/9384043</span></p>\n<p>为什么是 log (K!)—— 排列组合的问题</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165404094.png\" alt=\"image-20221103165404094\" /></p>\n<p>LRU 的命中率可能没有想象中那么高</p>\n<h4 id=\"先进先出算法fifo\"><a class=\"anchor\" href=\"#先进先出算法fifo\">#</a> 先进先出算法 FIFO</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165417670.png\" alt=\"image-20221103165417670\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165432556.png\" alt=\"image-20221103165432556\" /></p>\n<h4 id=\"最不经常使用算法lfu\"><a class=\"anchor\" href=\"#最不经常使用算法lfu\">#</a> 最不经常使用算法 LFU</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165447852.png\" alt=\"image-20221103165447852\" /></p>\n<p>所需要的额外的硬件实现太多，不能够支持。</p>\n<h4 id=\"随机替换算法\"><a class=\"anchor\" href=\"#随机替换算法\">#</a> 随机替换算法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103165504705.png\" alt=\"image-20221103165504705\" /></p>\n<p>随机替换算法是一种基线【或者说底线】，随机替换算法在性能上只稍逊于使用其他替换算法，也就说明其他随机替换算法没有那么好。</p>\n<h3 id=\"写策略\"><a class=\"anchor\" href=\"#写策略\">#</a> 写策略</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103172948799.png\" alt=\"image-20221103172948799\" /></p>\n<h4 id=\"缓存命中时的写策略写直达write-through\"><a class=\"anchor\" href=\"#缓存命中时的写策略写直达write-through\">#</a> 缓存命中时的写策略：写直达 Write Through</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103173037433.png\" alt=\"image-20221103173037433\" /></p>\n<h4 id=\"缓存命中时的写策略写回法write-back\"><a class=\"anchor\" href=\"#缓存命中时的写策略写回法write-back\">#</a> 缓存命中时的写策略：写回法 Write Back</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103173052648.png\" alt=\"image-20221103173052648\" /></p>\n<p>缺点的解决方法：每次 I/O 模块存取的时候先和 cache 做一个同步</p>\n<h4 id=\"缓存未命中的写策略写不分配写分配\"><a class=\"anchor\" href=\"#缓存未命中的写策略写不分配写分配\">#</a> 缓存未命中的写策略：写不分配 / 写分配</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103173811474.png\" alt=\"image-20221103173811474\" /></p>\n<h3 id=\"行大小\"><a class=\"anchor\" href=\"#行大小\">#</a> 行大小</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103174054409.png\" alt=\"image-20221103174054409\" /></p>\n<p>不是违反时间和空间关系，而是影响局部性（？</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103180046644.png\" alt=\"image-20221103180046644\" /></p>\n<h3 id=\"cache数目\"><a class=\"anchor\" href=\"#cache数目\">#</a> cache 数目</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103174453746.png\" alt=\"image-20221103174453746\" /></p>\n<p>通常，会有片内和片外的 cache。片内 cache 为第一级（L1），外部 cache 为第二级（L2）。L2cache 大小至少为 L1cache 大小的两倍时，才对提高总命中率有明显的作用。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221103174504972.png\" alt=\"image-20221103174504972\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/",
            "url": "https://quas-modo.github.io/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/",
            "title": "Lecture07-存储器",
            "date_published": "2022-10-24T05:30:15.000Z",
            "content_html": "<p>存储器相关，聚焦于半导体存储器，主要分为读写存储器、只读存储器以及读为主的存储器。接着叙述芯片逻辑，以及芯片优化。<br />\n<span id=\"more\"></span></p>\n<h2 id=\"回顾存储器\"><a class=\"anchor\" href=\"#回顾存储器\">#</a> 回顾：存储器</h2>\n<h2 id=\"回顾存储器-2\"><a class=\"anchor\" href=\"#回顾存储器-2\">#</a> 回顾：存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221020163158122.png\" alt=\"image-20221020163158122\" /></p>\n<p>1Byte（字节） = 8 bit（比特）</p>\n<p>1 字 可能是 4 字节，也可能是 8 字节。根据计算机是 32 位还是 64 位有所不同，不同计算机有不同的字长。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101171557660.png\" alt=\"image-20221101171557660\" /></p>\n<h2 id=\"存储器层次结构\"><a class=\"anchor\" href=\"#存储器层次结构\">#</a> 存储器层次结构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221021202852887.png\" alt=\"image-20221021202852887\" /></p>\n<h2 id=\"半导体存储器\"><a class=\"anchor\" href=\"#半导体存储器\">#</a> 半导体存储器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124316886.png\" alt=\"image-20221024124316886\" /></p>\n<p><strong>半导体</strong></p>\n<p>位元 存储 1 位数据</p>\n<h3 id=\"半导体存储器类型\"><a class=\"anchor\" href=\"#半导体存储器类型\">#</a> 半导体存储器类型</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124432370.png\" alt=\"image-20221024124432370\" /></p>\n<p>表中列出的而<strong>所有类型的存储器都是随机存取</strong>的。</p>\n<p>快闪 flash——U 盘是其中的一种。</p>\n<h3 id=\"读-写存储器随机存取存储器ram\"><a class=\"anchor\" href=\"#读-写存储器随机存取存储器ram\">#</a> 读 - 写存储器 —— 随机存取存储器 RAM</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124536588.png\" alt=\"image-20221024124536588\" /></p>\n<p>RAM 的明显特征是，可以<strong>方便快捷</strong>地从存储器读取数据和向存储器写入新数据，且读写操作都是通过使用<strong>电信号</strong>来实现的。</p>\n<p><strong>易失</strong> —— 必须持续供电，一旦断电，数据就会丢失。</p>\n<h4 id=\"sram-静态ram\"><a class=\"anchor\" href=\"#sram-静态ram\">#</a> SRAM 静态 RAM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124554411.png\" alt=\"image-20221024124554411\" /></p>\n<p>CS 片送</p>\n<p>RW 控制读写</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124714978.png\" alt=\"image-20221024124714978\" /></p>\n<p>推导过程</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130157726.png\" alt=\"image-20221024130157726\" /></p>\n<h4 id=\"dram-动态ram\"><a class=\"anchor\" href=\"#dram-动态ram\">#</a> DRAM 动态 RAM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024124958784.png\" alt=\"image-20221024124958784\" /></p>\n<p>通过电容充电来存储数据。</p>\n<p>电容器有漏电趋势，动态 RAM 需要周期地充电刷新来维持数据的存储。</p>\n<p>动态一词就是在描述存储电荷丢失的趋势，即使电源一直在供电。</p>\n<h4 id=\"sram与dram的对比\"><a class=\"anchor\" href=\"#sram与dram的对比\">#</a> SRAM 与 DRAM 的对比</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024125105338.png\" alt=\"image-20221024125105338\" /></p>\n<p>DRAM 密度高，价格便宜，趋向于满足大容量存储器的要求。但是 SRAM 更快。</p>\n<p>SRAM 一般用于 cache 存储器（片上或者片外的）【CPU 中】，而 DRAM 则用于主存储器中。</p>\n<h3 id=\"只读存储器\"><a class=\"anchor\" href=\"#只读存储器\">#</a> 只读存储器</h3>\n<h4 id=\"rom-只读存储器\"><a class=\"anchor\" href=\"#rom-只读存储器\">#</a> ROM 只读存储器</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130516422.png\" alt=\"image-20221024130516422\" /></p>\n<p>问题补充：固化数据需要较大的固定成本，无论是制造一片或者复制上千片特殊的 ROM。但是可以通过批量生产降低单片芯片的成本。</p>\n<h4 id=\"可编程romprom\"><a class=\"anchor\" href=\"#可编程romprom\">#</a> 可编程 ROM（PROM）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024130821252.png\" alt=\"image-20221024130821252\" /></p>\n<p>需要少量的存储特定内容的 ROM 芯片，可以选择较为廉价的可编程 PROM</p>\n<p>可由供应商或者用户在芯片出厂后写入一次、</p>\n<h3 id=\"主要进行读操作的存储器\"><a class=\"anchor\" href=\"#主要进行读操作的存储器\">#</a> 主要进行读操作的存储器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131021140.png\" alt=\"image-20221024131021140\" /></p>\n<h4 id=\"eprom\"><a class=\"anchor\" href=\"#eprom\">#</a> EPROM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131047438.png\" alt=\"image-20221024131047438\" /></p>\n<p>使芯片暴露在紫外线辐射下使所有的存储位元都被擦除，没有办法做到很精确，因此是芯片级的可擦除性。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131226634.png\" alt=\"image-20221024131226634\" /></p>\n<h4 id=\"eeprom\"><a class=\"anchor\" href=\"#eeprom\">#</a> EEPROM</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131245626.png\" alt=\"image-20221024131245626\" /></p>\n<p>任何时候都可以写入，无需擦除原先内容，只更新寻址到的一个或多个字节。</p>\n<p>将非易失性和数据修改灵活的优点结合起来。修改数据只需要使用常规的控制、地址和地址总线。</p>\n<p><strong>电写入，从 1 变成 0； 电擦除，从 0 变成 1。</strong></p>\n<h4 id=\"快闪存储器\"><a class=\"anchor\" href=\"#快闪存储器\">#</a> 快闪存储器</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131457113.png\" alt=\"image-20221024131457113\" /></p>\n<p>NAND Flash 共用一条线 —— 外部存储器</p>\n<h3 id=\"各类rom对比\"><a class=\"anchor\" href=\"#各类rom对比\">#</a> 各类 ROM 对比</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131557564.png\" alt=\"image-20221024131557564\" /></p>\n<h2 id=\"芯片逻辑\"><a class=\"anchor\" href=\"#芯片逻辑\">#</a> 芯片逻辑</h2>\n<h3 id=\"从位元到主存\"><a class=\"anchor\" href=\"#从位元到主存\">#</a> 从位元到主存</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131723140.png\" alt=\"image-20221024131723140\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131744592.png\" alt=\"image-20221024131744592\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131758270.png\" alt=\"image-20221024131758270\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131957375.png\" alt=\"image-20221024131957375\" /></p>\n<p>位扩展，从 1bit 增加到 8bit，需要增加 7 根线。</p>\n<p>字扩展，从 16K 变成 64K，16K 需要 7 根线，64K 需要 8 根线【因为行列复用】，只需要增加一根线，就可以实现 16K 到 64K。</p>\n<p>1K = 2 <sup>10</sup></p>\n<p>有多少位数据，就需要有多少根数据线。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101172926489.png\" alt=\"image-20221101172926489\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132007925.png\" alt=\"image-20221024132007925\" /></p>\n<h3 id=\"如何寻址地址译码器\"><a class=\"anchor\" href=\"#如何寻址地址译码器\">#</a> 如何寻址：地址译码器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131851948.png\" alt=\"image-20221024131851948\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131815432.png\" alt=\"image-20221024131815432\" /></p>\n<p>DRAM 不用刷新，采用行列复用 —— 用 11 位分别计算出行地址和列地址进行访问， 因为 DRAM 的存储空间较大，且行列复用耗时较高，所以只在 DRAM 中使用。</p>\n<p>SRAM 且没有 RAS（行地址选通）和 CAS（列地址选通），也没有数据输入输出缓冲器，SRAM 常作为缓存，需要更快的速度。</p>\n<p>WE 写允许</p>\n<p>OE 输出允许</p>\n<h3 id=\"如何刷新\"><a class=\"anchor\" href=\"#如何刷新\">#</a> 如何刷新</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024131911336.png\" alt=\"image-20221024131911336\" /></p>\n<p>集中式刷新会造成死区，影响使用，因此开发分散式刷新和异步刷新进行优化。</p>\n<p>译码阶段不需要进行缓存，每行的刷新相对独立，不需要按照顺序。</p>\n<h2 id=\"高级的dram架构\"><a class=\"anchor\" href=\"#高级的dram架构\">#</a> 高级的 DRAM 架构</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132123622.png\" alt=\"image-20221024132123622\" /></p>\n<h3 id=\"同步dramsynchorounous-dram-sdram\"><a class=\"anchor\" href=\"#同步dramsynchorounous-dram-sdram\">#</a> 同步 DRAM (Synchorounous DRAM, SDRAM)</h3>\n<h3 id=\"双频率sdramdouble-data-rate-sdram\"><a class=\"anchor\" href=\"#双频率sdramdouble-data-rate-sdram\">#</a> 双频率 SDRAM (Double-Data-Rate SDRAM)</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132312999.png\" alt=\"image-20221024132312999\" /></p>\n<p>SDRAM</p>\n<p>在每一次行选之前，都需要做预充电</p>\n<p>如果下一次仍然是同一行的数据，不需要行选。</p>\n<p>在时钟上升沿才能发数据</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132326001.png\" alt=\"image-20221024132326001\" /></p>\n<p>DDR SDRAM</p>\n<p>在时钟下升沿也可以发数据</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132335364.png\" alt=\"image-20221024132335364\" /></p>\n<p>核心频率无法改变 —— 电容很难提升</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101162647755.png\" alt=\"image-20221101162647755\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101162656519.png\" alt=\"image-20221101162656519\" /></p>\n<h2 id=\"寄存器基本原理\"><a class=\"anchor\" href=\"#寄存器基本原理\">#</a> 寄存器基本原理</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101164208668.png\" alt=\"image-20221101164208668\" /></p>\n<p>边沿 D 触发器，RS 锁存器以及增加了 input 和 clock（？</p>\n<p>寄存器和 CPU 的时钟同步</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221024132047639.png\" alt=\"image-20221024132047639\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/18/COA/Lecture06-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%8D%81%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/10/18/COA/Lecture06-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%8D%81%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture06-加减法十进制表示",
            "date_published": "2022-10-18T11:50:47.000Z",
            "content_html": "<p>十进制表示的加减法<br />\n &lt;!--more&gt;</p>\n<h1 id=\"lecture06-加减法十进制数表示\"><a class=\"anchor\" href=\"#lecture06-加减法十进制数表示\">#</a> Lecture06 加减法十进制数表示</h1>\n<h2 id=\"回顾二进制编码的十进制表示\"><a class=\"anchor\" href=\"#回顾二进制编码的十进制表示\">#</a> 回顾：二进制编码的十进制表示</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161625312.png\" alt=\"image-20221018161625312\" /></p>\n<h2 id=\"回顾补码表示整数的加减法\"><a class=\"anchor\" href=\"#回顾补码表示整数的加减法\">#</a> 回顾：补码表示整数的加减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161749133.png\" alt=\"image-20221018161749133\" /></p>\n<h3 id=\"加法溢出判定\"><a class=\"anchor\" href=\"#加法溢出判定\">#</a> 加法溢出判定</h3>\n<p>正负 进位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162304448.png\" alt=\"image-20221018162304448\" /></p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162440184.png\" alt=\"image-20221018162440184\" /></p>\n<h3 id=\"25-31-56\"><a class=\"anchor\" href=\"#25-31-56\">#</a> 25 + 31 = 56</h3>\n<p>用 0010 表示 2，用 0101 表示 5</p>\n<p>用 0011 表示 3，用 0001 表示 1</p>\n<p>个位数和十位数的和均小于 9</p>\n<h3 id=\"28-39-67\"><a class=\"anchor\" href=\"#28-39-67\">#</a> 28 + 39 = 67</h3>\n<p>0001 要再加上一个 0110 等于 0111</p>\n<p><strong>为什么加上 6？</strong></p>\n<p>二进制 10000 的第 5 位表示 16，但在十进制中实际上表示的是 10，少进了 6，所以在个位还需要再加上 6。</p>\n<h3 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163500884.png\" alt=\"image-20221018163500884\" /></p>\n<p>左边表格分别表示 10-19 的数，右边为实际的硬件实现。</p>\n<p>C4 表达式的意思是，如果（S1 和 S3 为 1）或者（S2 和 S3 为 1）则肯定大于 10，若 C4 * 为 1，则肯定大于 16。【公式中的 S1、2、3 应该有星号）</p>\n<p>C4 作为输出的同时，也对 S2 和 S1 的真正输出产生了影响。</p>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164311877.png\" alt=\"image-20221018164311877\" /></p>\n<p>9-x 不会出现借位的情况。</p>\n<h3 id=\"反转数字\"><a class=\"anchor\" href=\"#反转数字\">#</a> “反转” 数字：</h3>\n<ul>\n<li>按位反转，并添加 <code>1010</code> （10）</li>\n<li>添加 <code>0110</code> （6），并按位反转</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190527126.png\" alt=\"image-20221018190527126\" /></p>\n<h3 id=\"结果调整\"><a class=\"anchor\" href=\"#结果调整\">#</a> 结果调整</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164745084.png\" alt=\"image-20221018164745084\" /></p>\n<h4 id=\"309-125184有进位舍弃进位\"><a class=\"anchor\" href=\"#309-125184有进位舍弃进位\">#</a> 309-125=184 (有进位，舍弃进位)</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018194656730.png\" alt=\"image-20221018194656730\" /></p>\n<p>当得到的结果在 <code>10~19</code>  时，都需要进行修正。 <code>10~15</code>  时，加上 6 进行修正。</p>\n<p>例如，1110 + 0110 进 1 得到 0100. 即 13+6-16 (-10) 得到 3。</p>\n<p>有进位相当于，a-b 的时候 a&gt;b，所以 a-b = a + (999 - b) + 1 - 1000。</p>\n<h4 id=\"125-309-184无进位取反加1符号位设为负\"><a class=\"anchor\" href=\"#125-309-184无进位取反加1符号位设为负\">#</a> 125-309 = -184（无进位，取反加 1，符号位设为负）</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018194641391.png\" alt=\"image-20221018194641391\" /></p>\n<p>相当于此时 a &lt; b</p>\n<p>a - b =  -[1000 - [a + (999 - b) + 1]]</p>\n<p>【以上部分可参考 Lecture05 中，尾数的原码加法示例，是一样的道理】</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164912432.png\" alt=\"image-20221018164912432\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/14/COA/Lecture05-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/14/COA/Lecture05-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97/",
            "title": "Lecture05-浮点数计算",
            "date_published": "2022-10-14T02:57:07.000Z",
            "content_html": "<p>浮点数的加减乘除。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"lecture05-浮点数运算\"><a class=\"anchor\" href=\"#lecture05-浮点数运算\">#</a> Lecture05 - 浮点数运算</h1>\n<h2 id=\"回顾\"><a class=\"anchor\" href=\"#回顾\">#</a> 回顾</h2>\n<p>记忆 1+8+23 的（符号位移码原码）</p>\n<p>记忆各种情况对应的表示</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013162002689.png\" alt=\"image-20221013162002689\" /></p>\n<h2 id=\"加法和减法\"><a class=\"anchor\" href=\"#加法和减法\">#</a> 加法和减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013162704448.png\" alt=\"image-20221013162704448\" /></p>\n<ol>\n<li>\n<p>检查 0：如果有 0 存在可以不用计算</p>\n</li>\n<li>\n<p>对齐有效位：阶码向<strong>大值</strong>对齐，因为右移较小的数而丢失的数字所造成的的影响较小。右移较小的数有效值的幅值部分 1 位，并将阶值加 1。<strong>如果两个数的阶值差别非常大，则较小的数丢失</strong></p>\n</li>\n<li>\n<p>加或减有效值：<strong>原码加减法</strong></p>\n</li>\n<li>\n<p>规格化结果：把结果调整为左移有效值直到<strong>最高有效数字为非 0</strong>。</p>\n<p>（右规最多是两位，最多是 1.1111...+1.xxxx，对应有效值的上溢）</p>\n</li>\n</ol>\n<h3 id=\"溢出\"><a class=\"anchor\" href=\"#溢出\">#</a> 溢出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013164459041.png\" alt=\"image-20221013164459041\" /></p>\n<ol>\n<li>阶值上溢</li>\n</ol>\n<p>​\t\t最大允许阶值 127（11111110）</p>\n<p>​\t\t右移可能会导致阶值的上溢</p>\n<ol start=\"2\">\n<li>\n<p>阶值下溢</p>\n<p>最小阶值为 - 126（00000001）</p>\n<p>左移可能会引起阶值的下溢</p>\n</li>\n<li>\n<p>有效值的上下溢只存在于右规</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013171505053.png\" alt=\"image-20221013171503186\" /></p>\n</li>\n</ol>\n<h3 id=\"异常\"><a class=\"anchor\" href=\"#异常\">#</a> 异常</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014093204887.png\" alt=\"image-20221014093204887\" /></p>\n<p>关于<strong>数太小</strong>阶下溢的问题，在 cpp 中，如果是单精度浮点数，会用非规格化数表示，如果是双精度浮点数，会直接用 0 表示。</p>\n<h3 id=\"原码的加法\"><a class=\"anchor\" href=\"#原码的加法\">#</a> 原码的加法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013165531300.png\" alt=\"image-20221013165531300\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013165721396.png\" alt=\"image-20221013165721396\" /></p>\n<p>求补的时候加了 2 的 n 次方</p>\n<p>有进位说明 a&gt;b</p>\n<p>无进位说明 a&lt;b</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014103516514.png\" alt=\"image-20221014103516514\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013172902710.png\" alt=\"image-20221013172902710\" /></p>\n<p>01111110 ——127    23 表示有 23 个零</p>\n<p>01111101 ——126    21 表示有 21 个零</p>\n<p>差了一位，左移一位</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173317582.png\" alt=\"image-20221013173317582\" /></p>\n<p>1111110 127</p>\n<p>1111101 126</p>\n<p>然后给 0.4375 取个反</p>\n<h2 id=\"乘法和除法\"><a class=\"anchor\" href=\"#乘法和除法\">#</a> 乘法和除法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013163420919.png\" alt=\"image-20221013163420919\" /></p>\n<p>注意乘法和除法的阶值计算 ——</p>\n<ul>\n<li>乘法加 bias</li>\n<li>除法减 bias</li>\n<li>bias 的值为 127【通常，移码的偏移量为 2<sup>k-1</sup> -1，移码的偏移量主要是看想表示多少个负数和多少个正数，阶码的范围是 - 126~127，-127 和 128 分别表示特殊的数】</li>\n</ul>\n<h3 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173727304.png\" alt=\"image-20221013173727304\" /></p>\n<p>对于乘法来说，只有右规。【1.x * 1.x 只可能超出】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013173847536.png\" alt=\"image-20221013173847536\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174221322.png\" alt=\"image-20221013174221322\" /></p>\n<p>最高两位为 01，不用处理。</p>\n<h3 id=\"除法\"><a class=\"anchor\" href=\"#除法\">#</a> 除法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174335704.png\" alt=\"image-20221013174335704\" /></p>\n<p>x 和 y 可能都是 0，可能会报错或者是正负无穷</p>\n<p>对于除法来说，只有左规。【1.x/ 1.x 】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174656673.png\" alt=\"image-20221013174656673\" /></p>\n<h3 id=\"精度保护\"><a class=\"anchor\" href=\"#精度保护\">#</a> 精度保护</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013174820265.png\" alt=\"image-20221013174820265\" /></p>\n<p>y 需要左移一位对齐，所以最后一位 1 在不使用附加位的情况下会丢失。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013175053246.png\" alt=\"image-20221013175053246\" /></p>\n<p>一般而言，多余位的值超过了最低可表示位值的一半，则进位。</p>\n<p>重点关注 “10” 强制结果为偶数的分类讨论。如果结果的最低可表示位是 1，结果向上入；当最低可表示位是 0，结果向下入。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013175347832.png\" alt=\"image-20221013175347832\" /></p>\n<p>朝 0 摄入，被截断值的幅值总是小于或等于更精确原值的幅值，在计算中产生一致的向下偏差。</p>\n<h3 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221014105545840.png\" alt=\"image-20221014105545840\" /></p>\n<p>x == (int)(float) x</p>\n<p>int 型有 32 位，但是 float 精度只能保存 24 位，会有精度的损失。</p>\n<p>x * x &gt;=  0 否</p>\n<p><strong>(D + F)  - D == F 什么时候不成立？</strong></p>\n<p>右边计算出来为 double 型，左边是 float</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">+</span> f <span class=\"token operator\">-</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>对于此例情况，当<strong> i 大于 53 或等于 - 53</strong> 时，会输出。</p>\n<p>因为此时 f 相对于 d 较小，相当于 0。</p>\n<p>补充：双精度 64（1+11+52）小数部分有 <code>52</code>  位。别的情况，i 会有不同的值对应。</p>\n<ol>\n<li>\n<p>i 大于 53 的情况</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190250710.png\" alt=\"image-20221018190250710\" /></p>\n<p>舍入位虽然是 10，但前置位已经是 0（偶数），因此不进位，所以有精度的丢失。</p>\n</li>\n<li>\n<p>i 等于 - 53 的情况</p>\n</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221018190243583.png\" alt=\"image-20221018190243583\" /></p>\n<p>​\t\t舍入位是 10，前置位是 1，因此要进位，从而造成了误差。</p>\n<p>只要有精度的丢失，就是 “否”</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/10/04/COA/Lecture04-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "url": "https://quas-modo.github.io/2022/10/04/COA/Lecture04-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/",
            "title": "Lecture04-整数运算",
            "date_published": "2022-10-04T13:32:43.000Z",
            "content_html": "<p>整数的加减乘除计算的实现。<br />\n<span id=\"more\"></span></p>\n<h1 id=\"整数运算\"><a class=\"anchor\" href=\"#整数运算\">#</a> 整数运算</h1>\n<h2 id=\"算术逻辑单元alu\"><a class=\"anchor\" href=\"#算术逻辑单元alu\">#</a> 算术逻辑单元 ALU</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110026189.png\" alt=\"image-20221012110026189\" /></p>\n<p>寄存器存储数据、结果、flags</p>\n<p>控制器控制 ALU 操作和数据传入的信号</p>\n<h2 id=\"全加器\"><a class=\"anchor\" href=\"#全加器\">#</a> 全加器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110035166.png\" alt=\"image-20221012110035166\" /></p>\n<p><strong>关注与或异或的符号</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110051989.png\" alt=\"image-20221012110051989\" /></p>\n<p><strong>计算结果和进位</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110059850.png\" alt=\"image-20221012110059850\" /></p>\n<p>F 可以理解为，是奇数个 1 的时候，结果为 1；是偶数个 1 的时候，结果为 0。</p>\n<p>进位则是，有两个 1 的时候即可进位。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110111693.png\" alt=\"image-20221012110111693\" /></p>\n<p>异或门只能有<strong>两个</strong>输入端，异或门的时延<strong>不一定为 3ty</strong>。</p>\n<p>在网上找了一些实现异或的方法，可以看出，时延可以是 2ty 也可以是 3ty，应该是由异或门实现的方式决定的。</p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log29.gif\" alt=\"logic equivalent\" /></p>\n<p><img data-src=\"https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/logic-log30.gif\" alt=\"implimentation using NAND\" /></p>\n<p>非门算不算时延？ <strong>非门算时延</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110147229.png\" alt=\"image-20221012110147229\" /></p>\n<p>减少了一个与门，但是时延仍然是 6ty</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110159471.png\" alt=\"image-20221012110159471\" /></p>\n<p>这里可以解释为，因为 X 和 Y 的或和异或仅在 X、Y 均为 1 时不同，但 X、Y 均为 1 时，前面的与为 1，并不影响结果，所以两个式子相等。</p>\n<h2 id=\"串行进位行波进位加法器\"><a class=\"anchor\" href=\"#串行进位行波进位加法器\">#</a> 串行进位（行波进位）加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110210316.png\" alt=\"image-20221012110210316\" /></p>\n<p>公式来源于前面的全加法器，理解一样。</p>\n<p>需要等待 “进位输出信号”，所以缺点是延迟慢。</p>\n<h2 id=\"全先行进位加法器\"><a class=\"anchor\" href=\"#全先行进位加法器\">#</a> 全先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110215735.png\" alt=\"image-20221012110215735\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110224827.png\" alt=\"image-20221012110224827\" /></p>\n<p>不需要等待 n-1 位算完，就可以开始计算第 n 位，把能计算的先提前计算好。</p>\n<p>1ty：Gi 和 Pi 的计算，Gi 和 Pi 的计算可以同时进行，只需要 1ty</p>\n<p>2ty：计算 C 的值，因为需要先进行与操作，再进行或操作，所以需要 2ty，因为 Ci 只和 P\\G\\C0 的值有关，所以不需要等前一位的进位算好。</p>\n<p>3ty：Xi 和 Yi 的异或可在前三个时延做好，只需要再和 Ci-1 做异或即可算出 F。</p>\n<h2 id=\"部分先行进位加法器\"><a class=\"anchor\" href=\"#部分先行进位加法器\">#</a> 部分先行进位加法器</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110230663.png\" alt=\"image-20221012110230663\" /></p>\n<p>加法器延迟过于严重，但是全先行进位又难以实现，所以采用了两者的混合杂交。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110240165.png\" alt=\"image-20221012110240165\" /></p>\n<p>3ty：第一个全先行加法器需要算出 G、P，耗时 1ty；然后需要算出所有的进位，耗时 2ty；与此同时，其他三个 CLA 也算好了自己的 G 和 P。</p>\n<p>2ty：第二个 CLA 收到 Cin 之后，需要 2ty 计算 Cout。</p>\n<p>2ty：同上，为第三个 CLA 的计算。</p>\n<p>5ty：2ty+3ty，第四个 CLA 计算 C 需要 2ty，然后再和 X、Y 进行异或操作，需要 3ty。在此之前，其余的 CLA 已经完成了异或计算。</p>\n<h2 id=\"加法\"><a class=\"anchor\" href=\"#加法\">#</a> 加法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110246821.png\" alt=\"image-20221012110246821\" /></p>\n<p>溢出的情况只能是两个正的变成负的，或者两个负的变成正的。</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>C</th>\n<th>Fn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<p>判断是否溢出的 flag 就是在 Cn-1 和 Cn 上加一个异或器</p>\n<table>\n<thead>\n<tr>\n<th>Xn</th>\n<th>Yn</th>\n<th>Cn-1</th>\n<th>Cn</th>\n<th>overflow</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>0</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>0</strong></td>\n<td><strong>1</strong></td>\n<td><strong>溢出</strong></td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>不溢出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"减法\"><a class=\"anchor\" href=\"#减法\">#</a> 减法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110254314.png\" alt=\"image-20221012110254314\" /></p>\n<p>减法就是在加法器上加一个选择器，sub 给一个信号</p>\n<h2 id=\"乘法\"><a class=\"anchor\" href=\"#乘法\">#</a> 乘法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110300471.png\" alt=\"image-20221012110300471\" /></p>\n<p>实际上，加法和移位可以合并，因为始终上升沿到来之前，各寄存器中的数据会被取出，因此不需要 2-3 个时钟周期，1 个时钟周期即可完成。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110306067.png\" alt=\"image-20221012110306067\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110312495.png\" alt=\"image-20221012110312495\" /></p>\n<p>由于乘法会出现溢出的问题，所以出现了原码一位乘法和布斯算法。</p>\n<h3 id=\"原位一位乘法\"><a class=\"anchor\" href=\"#原位一位乘法\">#</a> 原位一位乘法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110326698.png\" alt=\"image-20221012110326698\" /></p>\n<h3 id=\"补码一位乘法布斯算法\"><a class=\"anchor\" href=\"#补码一位乘法布斯算法\">#</a> 补码一位乘法：布斯算法</h3>\n<h4 id=\"基本思路和证明\"><a class=\"anchor\" href=\"#基本思路和证明\">#</a> 基本思路和证明</h4>\n<p>每次根据两位决定直接移位 / 加 / 减（共四种情况）</p>\n<ol>\n<li>00、11—— 直接移位</li>\n<li><strong>10</strong> —— 减</li>\n<li><strong>01</strong> —— 加</li>\n</ol>\n<h4 id=\"黑书证明\"><a class=\"anchor\" href=\"#黑书证明\">#</a> 黑书证明</h4>\n<p>用 **2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup>** 可以表示正乘数和负乘数</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221009234843548.png\" alt=\"image-20221009234843548\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221009235208579.png\" alt=\"image-20221009235208579\" /></p>\n<h4 id=\"ppt证明\"><a class=\"anchor\" href=\"#ppt证明\">#</a> PPT 证明</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110337646.png\" alt=\"image-20221012110337646\" /></p>\n<p>为什么可以这样用布斯算法计算？</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/6D18DEB3A3D802AB3B7AE9DB900A475C.png\" alt=\"img\" /><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110345029.png\" alt=\"image-20221012110345029\" /></p>\n<h4 id=\"易错点算数移位\"><a class=\"anchor\" href=\"#易错点算数移位\">#</a> 易错点：算数移位</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110426386.png\" alt=\"image-20221012110426386\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110429745.png\" alt=\"image-20221012110429745\" /></p>\n<p>错误原因：补位负数补 1，不论是何种情况，右移都使得 A 的最左位，即 A<sub>n-1</sub> 不仅移入 A<sub>n-2</sub> 中，而且还保留在 A<sub>n-1</sub> 中。这是为了保持 A 和 Q 中数的符号，因为它<strong>保留了符号位</strong>，所以被称为<strong>算数移位</strong>。</p>\n<p>实际上，根据黑书，应该还有一位 Q<sub>-1</sub> 寄存器，放在 Q 最低有效位的右边，负责保存丢失的那位。</p>\n<h3 id=\"乘法溢出\"><a class=\"anchor\" href=\"#乘法溢出\">#</a> 乘法溢出</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110434583.png\" alt=\"image-20221012110434583\" /></p>\n<p>带符号整数：因为乘法的补位是根据当前最高位计算的，如果有变化，则说明有溢出</p>\n<p>无符号整数：无符号整数应该没有 1 的出现</p>\n<h2 id=\"除法\"><a class=\"anchor\" href=\"#除法\">#</a> 除法</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221013100038320.png\" alt=\"image-20221013100038320\" /></p>\n<p>不同的高级算法对于 1/0 0/0 的计算结果处理是不同的</p>\n<p>如在 js 中，1/0 为正无穷；c 中会报错</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110438424.png\" alt=\"image-20221012110438424\" /></p>\n<p>在十进制除法中，需要用到乘法；在二进制中则不需要。</p>\n<p>除数和被除数符号不一样时，不同的编程语言也会得到不一样的答案。</p>\n<p>注意补齐被除数的符号位，从<strong>次高位</strong>开始计算。</p>\n<h3 id=\"除法器\"><a class=\"anchor\" href=\"#除法器\">#</a> 除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110445518.png\" alt=\"image-20221012110445518\" /></p>\n<p>对应于手工进行除法运算，</p>\n<p>因为需要补全被除数的位数，所以需要 2n 寄存器；</p>\n<p>因为除数相对于被除数的次高位开始移动，所以需要 2n 位支持右移的寄存器；</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110451162.png\" alt=\"image-20221012110451162\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110454561.png\" alt=\"image-20221012110454561\" /></p>\n<p>除法流程图 —— “是否为第<strong> N+1</strong> 次循环”</p>\n<p>和乘法不同 ——<strong>N</strong> 次循环</p>\n<p><strong>如何做优化？</strong></p>\n<p>常见的思路 —— 并行操作 / 硬件节省</p>\n<blockquote>\n<p>不能够做并行操作</p>\n<p>可以做一些硬件的优化</p>\n</blockquote>\n<h3 id=\"优化的除法器\"><a class=\"anchor\" href=\"#优化的除法器\">#</a> 优化的除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110458490.png\" alt=\"image-20221012110458490\" /></p>\n<h3 id=\"异号的除法如何处理\"><a class=\"anchor\" href=\"#异号的除法如何处理\">#</a> 异号的除法如何处理？</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110504455.png\" alt=\"image-20221012110504455\" /><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110514117.png\" alt=\"image-20221012110514117\" /></p>\n<p>结果都是<strong>和余数进行比较</strong>，操作之后，如果相对于余数的符号改变，则不够；如果相对于余数的符号不变，则够。</p>\n<p>例子：</p>\n<p>可以对照上下（36、37）两张图理解异号的除法，</p>\n<p>被除数为 11111001，它的值为 - 7</p>\n<ol>\n<li>1111 + 0011 为 10010 符号改变</li>\n<li>1110 + 0011 为 10001 符号改变</li>\n<li>1100 + 0011 为 1111 符号不变，且绝对值减小，因此可以加，且商上 1</li>\n<li>1111 + 0011 符号改变</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221010003001858.png\" alt=\"img\" /></p>\n<p>参考黑书的话，</p>\n<p>余数的符号 = 被除数</p>\n<p>商的符号 = 被除数 * 除数</p>\n<p>因此，此题中，商和余数都需要取负数，所以商要取补码</p>\n<h3 id=\"补码除法运算过程\"><a class=\"anchor\" href=\"#补码除法运算过程\">#</a> 补码除法运算过程</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110521683.png\" alt=\"image-20221012110521683\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110524618.png\" alt=\"image-20221012110524618\" /></p>\n<h3 id=\"不恢复余数除法\"><a class=\"anchor\" href=\"#不恢复余数除法\">#</a> 不恢复余数除法</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110534163.png\" alt=\"image-20221012110534163\" /></p>\n<p>可以参考之前的恢复余数的操作理解</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110539289.png\" alt=\"image-20221012110539289\" /></p>\n<p>如何理解大致思路：</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/4C93EBA825F2B3B083A9B5CC5D1E567D.png\" alt=\"img\" /></p>\n<p>由下面的通式表示：</p>\n<p><strong>ri+1=2ri+(1-2Qi)Y</strong></p>\n<blockquote>\n<p>式中 Qi 为第 i 次所得的商，若部分余数为正，则 Qi=1，部分余数左移一位，下一次继续减除数；若部分余数为负，则 Qi=0，部分余数左移一位，下一次加除数。由于加减运算交替地进行，故称为原码加减交替法。</p>\n</blockquote>\n<h3 id=\"补码不恢复余数除法流程图\"><a class=\"anchor\" href=\"#补码不恢复余数除法流程图\">#</a> 补码不恢复余数除法流程图</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221006172646381.png\" alt=\"img\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110545429.png\" alt=\"image-20221012110545429\" /></p>\n<p>同号说明 “够大”，异号说明 “不够大”</p>\n<p>注意不恢复余数补码除法分为两个流程，首先需要判断符号然后初始化。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110550193.png\" alt=\"image-20221012110550193\" /></p>\n<p><strong>计算流程</strong>理解：</p>\n<p>流程一：因为余数和除数异号，所以采用加的方式。加完后发现同号（实际上是由异号变为同号），补 1，实际上是取反的操作。</p>\n<p>流程二：根据 X 和 Y 是否同号，继续操作。</p>\n<p><strong>关于商的修正</strong>：</p>\n<p>Z 左移一位，根据是否够加，上 1 或 0。</p>\n<p>如果被除数和除数异号，说明商是负数。在求每一位的时候，已经取了反，因此再加 1 即可。这样的操作，比最后再计算商的总体的补码简单。</p>\n<p><strong>关于余数的修正</strong>：</p>\n<p>余数和被除数的符号相同。</p>\n<p>如果符号不同，则说明余数多加 / 多减了一个除数。如果被除数和除数的符号相同，说明余数和除数符号不相同，加上除数进行修正；如果被除数和除数符号不同，说明余数和除数符号相同，减去除数进行修正。</p>\n<p>在最后多加了一个 Y</p>\n<p>符号位，不恢复余数补码除法运算和除数比，恢复的和被除数相比</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110557310.png\" alt=\"image-20221012110557310\" /></p>\n<p>因为除法器效率不高，所以用右移运算实现简化</p>\n<p>能整除的时候，被移除的全为 0；</p>\n<p>不能整除的时候，移除的数存在非 0，</p>\n<p>-14/4 负数补位 1</p>\n<h3 id=\"阵列除法器\"><a class=\"anchor\" href=\"#阵列除法器\">#</a> 阵列除法器</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110601896.png\" alt=\"image-20221012110601896\" /></p>\n<p>实际生活中并不是斜着排列的</p>\n<h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221012110605353.png\" alt=\"image-20221012110605353\" /></p>\n<p>全加器是两个半加器组合起来的，半加器不考虑进位。</p>\n<p>全加器算了两次 X+Y：第一次 X+Y 得到 Z，第二次 Z+Cin 得到结果。</p>\n<p>注意各整数运算的优化过程</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "url": "https://quas-modo.github.io/2022/09/23/COA/Lecture03-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA/",
            "title": "Lecture03-数据的机器级表表示",
            "date_published": "2022-09-22T23:41:11.000Z",
            "content_html": "<p>仅记录有用部分，课件详细内容在 ppt 上已经很清楚了。</p>\n<p>需要加强的地方：二进制转十进制，十进制转二进制，补码的模不懂，静默式和通知式，非规格化数不懂、精度保护中的舍入看不懂，大端小端</p>\n<p>好难…… 呜呜看不懂</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"第一次作业讲解\"><a class=\"anchor\" href=\"#第一次作业讲解\">#</a> 第一次作业讲解</h2>\n<p>作业 1：. 为什么速率的总和没有意义？</p>\n<p>作业 2：指令集结构不同的计算机，只比较 MIPS 是没有意义的，例如此题当中，A 的 MIPS 大，但是运行时间较长。</p>\n<p>作业 3：采用不同指令集、<strong>流水线</strong>和并行</p>\n<p>作业 4：MIPS 求和有意义吗？</p>\n<p>组织不可见，结构可见</p>\n<h1 id=\"lecture0304-数据的机器级表示\"><a class=\"anchor\" href=\"#lecture0304-数据的机器级表示\">#</a> lecture03/04 - 数据的机器级表示</h1>\n<p>参考紫书第 2 章 / 黑书第 9 章 计算机算数</p>\n<h2 id=\"课堂ppt结合黑书版本\"><a class=\"anchor\" href=\"#课堂ppt结合黑书版本\">#</a> 课堂 /ppt—— 结合黑书版本</h2>\n<h3 id=\"信息的二进制编码\"><a class=\"anchor\" href=\"#信息的二进制编码\">#</a> 信息的二进制编码</h3>\n<h3 id=\"整数的二进制表示\"><a class=\"anchor\" href=\"#整数的二进制表示\">#</a> 整数的二进制表示</h3>\n<h4 id=\"无符号整数\"><a class=\"anchor\" href=\"#无符号整数\">#</a> 无符号整数</h4>\n<h4 id=\"有符号整数\"><a class=\"anchor\" href=\"#有符号整数\">#</a> 有符号整数</h4>\n<h5 id=\"原码-符号幅值表示法\"><a class=\"anchor\" href=\"#原码-符号幅值表示法\">#</a> 原码 符号幅值表示法</h5>\n<p>符号位不同，数值位相同</p>\n<p>不同位长间的转换：符号位左移，空余的填补 0</p>\n<p>浮点数的尾数用原码定点小数表示</p>\n<p>零的表示不唯一，不利于程序员编程</p>\n<h5 id=\"反码\"><a class=\"anchor\" href=\"#反码\">#</a> 反码</h5>\n<p>符号位和数值位均取反</p>\n<h5 id=\"移码\"><a class=\"anchor\" href=\"#移码\">#</a> 移码</h5>\n<p>是一种有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbmVkX251bWJlcl9yZXByZXNlbnRhdGlvbg==\">符号数表示</span>的方法，其中有符号数 n 是由对应于<strong>无符号数 n + K</strong> 的位模式表示，K 是<em>偏置值</em>或<em>偏移量</em>。</p>\n<p>bias 通常取 2 的 n-1 次方或者 2 的 n-1 次方减 1<br />\n 当 bias 为 2 的 n-1 次方时，移码和补码仅第一位不同，0 的表示唯一<br />\n<strong>浮点数的阶用移码表示</strong>：当两个数都是负数的时候，移码更容易比较</p>\n<h5 id=\"补码\"><a class=\"anchor\" href=\"#补码\">#</a> 补码</h5>\n<p>计算机处理中，<strong>通常使用补码</strong><br />\n负数的数值部分 <strong>各位取反，末尾加 1</strong></p>\n<p>不同位长间的转换：符号位移到最左位，其余空出位用符号位的值替代</p>\n<p>加和减的统一：<br />\n一个负数的补码等于模减该负数的绝对值<br />\n对于一个确定的模，某数减去小于模的另一数，总可以加上另一数负数的补码来代替。</p>\n<p><strong>求真值的补码</strong></p>\n<p>全 0：0</p>\n<p>全 1：-1</p>\n<p>10000...：- 2 <sup>n-1</sup></p>\n<p><strong>求补码的真值</strong></p>\n<p>**X = - x<sub>n-1</sub> * 2 <sup>n-1</sup> + ... + x <sub>2</sub> * 2 <sup>1</sup>+ x <sub>1</sub>*2<sup>0</sup> **</p>\n<p><strong>若对负数的补码再取负，得到原来那个数</strong>【其中的特例是，-2<sup>n-1</sup> 在取负之后仍然为本身，因为范围内并没有 2<sup>n-1</sup> 与之相对应】</p>\n<h3 id=\"浮点数\"><a class=\"anchor\" href=\"#浮点数\">#</a> 浮点数</h3>\n<p>单精度 32 位（1+8+23）<strong>仍然表示 2<sup>32</sup> 个数</strong></p>\n<p>双精度 64 位（1+11+52）</p>\n<p>基底为 2（也存在基底为 16 的情况）—— 基数越大，范围越大，精度越低</p>\n<h4 id=\"表示方法\"><a class=\"anchor\" href=\"#表示方法\">#</a> 表示方法</h4>\n<p>S E M</p>\n<ol>\n<li>\n<p>符号位</p>\n</li>\n<li>\n<p>8 位移码表示阶码（指数） —— 范围为 - 126~127，全 0 和全 1 为特殊值</p>\n</li>\n<li>\n<p>23 位原码表示 24 位尾数，最高位总为 1</p>\n</li>\n</ol>\n<h4 id=\"表示的数\"><a class=\"anchor\" href=\"#表示的数\">#</a> 表示的数</h4>\n<p><strong>规格化数</strong>，关注上溢出和下溢出，</p>\n<p>下溢出部分用<strong>非格式化数</strong>表示，它的间距是等距的</p>\n<p>越靠近原点，数越密集；越远离原点，数越稀疏</p>\n<p><strong>静默式和通知式非数</strong> —— 静默式表示未定义的算数结果，通知式非数表示未初始化的值。</p>\n<h2 id=\"计算机组成与体系结构性能设计\"><a class=\"anchor\" href=\"#计算机组成与体系结构性能设计\">#</a> 计算机组成与体系结构：性能设计</h2>\n<h3 id=\"整数的加法与减法补码\"><a class=\"anchor\" href=\"#整数的加法与减法补码\">#</a> 整数的加法与减法（补码）</h3>\n<p>上溢规则</p>\n<p>减法规则 —— 减法，即加上减数的 2 的补</p>\n<p>在实际的操作中，有 OF 溢出位记录是否溢出</p>\n<h3 id=\"整数的乘法\"><a class=\"anchor\" href=\"#整数的乘法\">#</a> 整数的乘法</h3>\n<h4 id=\"无符号整数的乘法\"><a class=\"anchor\" href=\"#无符号整数的乘法\">#</a> 无符号整数的乘法</h4>\n<p>两个 n 为二进制整数的乘法可产生最大长度为 2n 位的积</p>\n<p>乘</p>\n<p>移位</p>\n<p>计数 - 1</p>\n<h4 id=\"有符号整数的乘法\"><a class=\"anchor\" href=\"#有符号整数的乘法\">#</a> 有符号整数的乘法</h4>\n<p>只要有一个是负数，原来的方法就不奏效</p>\n<ol>\n<li>\n<p>把被乘数和乘数都转变成正数再相乘，当两者初始的符号不相同时，结果取 2 的补</p>\n</li>\n<li>\n<p>布斯（Booth）算法</p>\n<p>分为 10 01 【00 11】三种情况讨论</p>\n<p>运用公式，   <strong>2 <sup>n</sup> + 2 <sup>n-1</sup> + ... + 2 <sup>n-k</sup> = 2 <sup>n+1</sup> - 2 <sup>n-k</sup></strong></p>\n<p>很巧妙，优雅，实在是太优雅了！</p>\n</li>\n</ol>\n<h3 id=\"整数的除法\"><a class=\"anchor\" href=\"#整数的除法\">#</a> 整数的除法</h3>\n<p>搞来搞去，也很优雅</p>\n<h3 id=\"浮点数加法和减法\"><a class=\"anchor\" href=\"#浮点数加法和减法\">#</a> 浮点数加法和减法</h3>\n<ol>\n<li>检查 0</li>\n<li>对齐有效值</li>\n<li>加法</li>\n<li>规格化</li>\n</ol>\n<p>注意时时检查是否有效值为 0，以及是否溢出</p>\n<p>若两个数的阶值差别非常大，则较小的数丢失</p>\n<h3 id=\"浮点数乘法和除法\"><a class=\"anchor\" href=\"#浮点数乘法和除法\">#</a> 浮点数乘法和除法</h3>\n<p>由于阶值是移码的形式，相乘的时候，两个阶值的和要减去一个偏移量，相除的时候，两个阶值的差要加上一个偏移量</p>\n<h4 id=\"精度考虑\"><a class=\"anchor\" href=\"#精度考虑\">#</a> 精度考虑</h4>\n<ol>\n<li>\n<p>保护位</p>\n<p>对齐的时候会导致丢失，在末尾增加保护位，可以扩展有效值的右端</p>\n</li>\n<li>\n<p>舍入（不懂）</p>\n</li>\n</ol>\n<h2 id=\"计算机组成与系统结构习题解答和教学指导\"><a class=\"anchor\" href=\"#计算机组成与系统结构习题解答和教学指导\">#</a> 计算机组成与系统结构习题解答和教学指导</h2>\n<h3 id=\"数据的表示\"><a class=\"anchor\" href=\"#数据的表示\">#</a> 数据的表示</h3>\n<ul>\n<li>\n<p>数值数据 —— 二进制、十进制（BCD binary coded decimal）</p>\n</li>\n<li>\n<p>非数值数据</p>\n</li>\n</ul>\n<h3 id=\"数据的宽度\"><a class=\"anchor\" href=\"#数据的宽度\">#</a> 数据的宽度</h3>\n<p>数据容量和宽度</p>\n<p>比特</p>\n<p>字节</p>\n<p>字（2 个 / 4 个 / 8 个 / 16 个字节）</p>\n<h3 id=\"数据的排列\"><a class=\"anchor\" href=\"#数据的排列\">#</a> 数据的排列</h3>\n<ul>\n<li>大端排列 —— 最低有效字节 LSB 存放在大地址单元中，MSB 所在地址为数据的地址</li>\n<li>小端排列 —— 最低有效字节 LSB 存放在小地址单元中，LSB 所在地址为数据的地址</li>\n</ul>\n<h3 id=\"数据校验方式\"><a class=\"anchor\" href=\"#数据校验方式\">#</a> 数据校验方式</h3>\n<ul>\n<li>\n<p>奇偶校验</p>\n</li>\n<li>\n<p>海明校验</p>\n</li>\n<li>\n<p>循环冗余码校验</p>\n</li>\n</ul>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://quas-modo.github.io/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "Lecture02-计算机体系结构的问题及解决方案",
            "date_published": "2022-09-15T10:01:24.000Z",
            "content_html": "<p>讲述了六个计算机体系结构的问题以及解决方案<br />\n<span id=\"more\"></span></p>\n<h2 id=\"冯诺依曼最重要的思想存储程序\"><a class=\"anchor\" href=\"#冯诺依曼最重要的思想存储程序\">#</a> 冯诺依曼最重要的思想 —— 存储程序</h2>\n<p>任何要计算机完成的工作都要先被编写成程序，然后将<strong>程序和原始数据送入主存</strong>并启动执行。一旦程序被启动，计算机应能在不需要操作人员干预下，自动完成逐条取出指令和执行指令的任务。</p>\n<p>区分中央处理单元（CPU）和处理器。</p>\n<p>CPU 的制作工艺逐渐在提高，几乎不变的是 CPU 的大小，一直在增加的是晶体管的数量。</p>\n<p>目前，苹果 M2 以及可以集成 200 亿的晶体管。</p>\n<h2 id=\"问题与解决思路\"><a class=\"anchor\" href=\"#问题与解决思路\">#</a> 问题与解决思路</h2>\n<h3 id=\"可以通过无限增加cpu的大小来增加性能嘛\"><a class=\"anchor\" href=\"#可以通过无限增加cpu的大小来增加性能嘛\">#</a> 可以通过无限增加 CPU 的大小来增加性能嘛？</h3>\n<p>不可以，面积越大，意味着<strong>互联延迟</strong>越大。一个时钟周期需要大于最长互联延迟。存在物理极限。</p>\n<h3 id=\"问题1cpu的频率不能无限提高\"><a class=\"anchor\" href=\"#问题1cpu的频率不能无限提高\">#</a> 问题 1：CPU 的频率不能无限提高</h3>\n<p>MOS 管开关、脉冲通过门电路需要时间</p>\n<p>为了信号同步，每个脉冲信号需要持续一定的时间</p>\n<p>面积大，连线延迟大；</p>\n<p>频率越高，开关损耗高，CPU 耗电和散热提高；</p>\n<h3 id=\"解决1改变cpu芯片结构\"><a class=\"anchor\" href=\"#解决1改变cpu芯片结构\">#</a> 解决 1：改变 CPU 芯片结构</h3>\n<ol>\n<li>\n<p>采用各种技术，对芯片体系结构进行优化：指令流水线、每周期多条指令、cache、更长流水线和双速算术</p>\n</li>\n<li>\n<p>领域定制，如面向人工智能的芯片</p>\n</li>\n</ol>\n<h3 id=\"问题2内存墙的存在-memory-wall\"><a class=\"anchor\" href=\"#问题2内存墙的存在-memory-wall\">#</a> 问题 2：内存墙的存在 memory wall</h3>\n<p>主存和 CPU 之间传输数据的速度跟不上 CPU 的速度</p>\n<h3 id=\"解决2采用高速缓存cache\"><a class=\"anchor\" href=\"#解决2采用高速缓存cache\">#</a> 解决 2：采用高速缓存（cache）</h3>\n<ol>\n<li>添加一级或多级缓存以减少存储器访问频率并提高数据传输速率</li>\n<li>增大总线的数据宽度，来增加每次所能取出的位数</li>\n</ol>\n<h3 id=\"问题3cpu等待io传输数据\"><a class=\"anchor\" href=\"#问题3cpu等待io传输数据\">#</a> 问题 3：CPU 等待 I/O 传输数据</h3>\n<p>CPU 在等待 I/O 设备时保持空闲</p>\n<h3 id=\"解决3中断\"><a class=\"anchor\" href=\"#解决3中断\">#</a> 解决 3：中断</h3>\n<p>其他模块（例如 IO）可以中断正常处理顺序的机制</p>\n<p>中断周期加入指令周期中</p>\n<p>多重中断：顺序中断处理、嵌套中断处理</p>\n<h3 id=\"问题4兼顾存储容量-速度和成本\"><a class=\"anchor\" href=\"#问题4兼顾存储容量-速度和成本\">#</a> 问题 4：兼顾存储容量、速度和成本</h3>\n<p>约束</p>\n<ul>\n<li>容量：越大越好</li>\n<li>速度：跟上处理器</li>\n<li>成本：相较于其他组件合理</li>\n</ul>\n<p>约束之间的关系</p>\n<p>​\t更短的访问时间，更高的每比特成本</p>\n<h3 id=\"解决4层次式存储结构\"><a class=\"anchor\" href=\"#解决4层次式存储结构\">#</a> 解决 4：层次式存储结构</h3>\n<p>需求</p>\n<ul>\n<li>大容量数据存储</li>\n<li>高速性能</li>\n</ul>\n<p>解决方案</p>\n<ul>\n<li>使用存储器层次结构而不是依赖单个存储器组件</li>\n</ul>\n<p><strong>寄存器 ——cache—— 主存 —— 磁盘 —— 磁带</strong></p>\n<p>存储量越来越大，速度越来越慢，离 CPU 越来越远</p>\n<h3 id=\"问题5io设备传输速率差异大\"><a class=\"anchor\" href=\"#问题5io设备传输速率差异大\">#</a> 问题 5：I/O 设备传输速率差异大</h3>\n<p>I/O 性能跟不上 CPU 速度的提升</p>\n<h3 id=\"解决5采用缓冲区和改进io操作技术\"><a class=\"anchor\" href=\"#解决5采用缓冲区和改进io操作技术\">#</a> 解决 5：采用缓冲区和改进 I/O 操作技术</h3>\n<p>设立缓存区</p>\n<h3 id=\"问题6计算机部件互连复杂\"><a class=\"anchor\" href=\"#问题6计算机部件互连复杂\">#</a> 问题 6：计算机部件互连复杂</h3>\n<h3 id=\"解决6采用总线\"><a class=\"anchor\" href=\"#解决6采用总线\">#</a> 解决 6：采用总线</h3>\n<h4 id=\"总线\"><a class=\"anchor\" href=\"#总线\">#</a> 总线</h4>\n<p>目前，对通用计算机而言，各种点对点互连结构逐渐取代总线互连的方式。但是总线结构依然普遍用于嵌入式系统。</p>\n<h5 id=\"共享\"><a class=\"anchor\" href=\"#共享\">#</a> 共享</h5>\n<p>所有部件都通过总线传递数据</p>\n<h5 id=\"分时\"><a class=\"anchor\" href=\"#分时\">#</a> 分时</h5>\n<p>只有一个部件能够传输数据</p>\n<h5 id=\"功能组\"><a class=\"anchor\" href=\"#功能组\">#</a> 功能组</h5>\n<p><strong>控制线</strong> —— 控制对数据线路与地址线路的访问和使用，控制信号传递<strong>命令和定时信息</strong>。</p>\n<p><strong>地址线</strong> —— 指定数据总线上数据的源或目的，地址总线的宽度决定了系统可能的<strong>最大内存容量</strong></p>\n<p><strong>数据线</strong> —— 为系统模块之间的数据传输提供路径，一般而言，线路的条数决定了<strong>一次能传输的位数</strong>，数据总线的宽度是决定系统整体性能的一个关键因素</p>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        },
        {
            "id": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "https://quas-modo.github.io/2022/09/08/COA/Lecture01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "Lecture01-计算机系统概述",
            "date_published": "2022-09-08T12:30:32.000Z",
            "content_html": "<p>第一讲，以及对于书籍的第一章重点知识点整理</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"课程随笔\"><a class=\"anchor\" href=\"#课程随笔\">#</a> 课程随笔</h1>\n<h2 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h2>\n<p><strong>通用 电子 数字 计算机</strong></p>\n<p>通用</p>\n<p>电子</p>\n<p>数字</p>\n<h3 id=\"组织与结构\"><a class=\"anchor\" href=\"#组织与结构\">#</a> 组织与结构</h3>\n<ol>\n<li>结构 (对于程序员是可见的)\n<ul>\n<li>一个提供乘法算法的计算机和另一个不提供乘法算法的计算机之间的区别</li>\n<li>包括：指令集、各类数据类型的大小</li>\n</ul>\n</li>\n<li>组织 (对于程序员是不可见的)\n<ul>\n<li>一个用乘法器完成乘法的计算机和一个用加法器通过算法完成乘法的计算机之间的不同。</li>\n<li>包括：控制信号、存储技术</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"计算机发展历史\"><a class=\"anchor\" href=\"#计算机发展历史\">#</a> 计算机发展历史</h2>\n<p>真空管</p>\n<p>晶体管</p>\n<p>集成电路（scale 越来越大，SSI-&gt;MSI-&gt;LSI-&gt;VLSI-&gt;ULSI）</p>\n<p>摩尔定律（集成电路芯片上集成的晶体管数将番一番，速度将提高一倍，而价格将降低一半）</p>\n<h2 id=\"冯诺依曼结构的实现与演变\"><a class=\"anchor\" href=\"#冯诺依曼结构的实现与演变\">#</a> 冯诺依曼结构的实现与演变</h2>\n<h3 id=\"cpu-北桥-南桥\"><a class=\"anchor\" href=\"#cpu-北桥-南桥\">#</a> CPU + 北桥 + 南桥</h3>\n<p>芯片近北桥，远离南桥。</p>\n<h4 id=\"南桥\"><a class=\"anchor\" href=\"#南桥\">#</a> 南桥</h4>\n<p>南桥（英语：Southbridge）是基于个人计算机主板芯片组架构中的其中一枚芯片。南桥设计用来处理<strong>低速信号</strong>，通过北桥与中央处理器联系。<br />\n南桥芯片负责 I/O 总线之间的通信，如 PCI 总线、USB、LAN、ATA、SATA、音频控制器、键盘控制器、实时时钟控制器、高级电源管理等。<br />\nPCI、SATA、IDE、USB。</p>\n<h4 id=\"北桥\"><a class=\"anchor\" href=\"#北桥\">#</a> 北桥</h4>\n<p>北桥设计用来处理<strong>高速信号</strong>，通常处理中央处理器、存储器、PCI Express 显卡（早年是 AGP 显卡）、高速 PCI Express X16/X8 的端口，还有与南桥之间的通信。<br />\n芯片组（chipset）的名称就是以北桥芯片的名称来命名的。<br />\n北桥被用来处理高速信号，通常处理 CPU（处理器），RAM（内存），AGP 端口或 PCI Express, 和南桥芯片之间的通信。<br />\nPCIE/AGP、Memory、CPU。</p>\n<h3 id=\"cpu-pch集成显卡-显示部件\"><a class=\"anchor\" href=\"#cpu-pch集成显卡-显示部件\">#</a> CPU + PCH（集成显卡 - 显示部件）</h3>\n<p>PCH 全称为 Platform Controller Hub，是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9pbnRlbCVFNSU4NSVBQyVFNSU4RiVCOA==\"> intel 公司</span>的集成南桥。</p>\n<p>北桥中的内存控制器和 PCIe 控制器都集成到了 CPU 内部，相当于整个北桥芯片都集成到了 CPU 内部，主板上只剩下南桥。所以 PCH 可以理解成南桥。目前 Intel 的有些 SOC 就是连 PCH 也集成到了 CPU 内部，比如：Intel Xeon D 系列.</p>\n<h2 id=\"计算机性能\"><a class=\"anchor\" href=\"#计算机性能\">#</a> 计算机性能</h2>\n<h3 id=\"cpu性能\"><a class=\"anchor\" href=\"#cpu性能\">#</a> CPU 性能</h3>\n<p>时钟频率 / 时钟周期</p>\n<p>CPI</p>\n<p>MIPS（每秒百万条指令）</p>\n<p>MRLOPS（每秒百万条浮点操作）</p>\n<p>基准程序</p>\n<h3 id=\"性能设计的基本原则\"><a class=\"anchor\" href=\"#性能设计的基本原则\">#</a> 性能设计的基本原则</h3>\n<ul>\n<li>\n<p>大概率事件优先原则</p>\n</li>\n<li>\n<p>阿姆代尔定律 Amdahl 定律</p>\n<p>技术或设计的某一部分的加速不会导致性能产生相应的改进。性能的提高是有限度的。</p>\n</li>\n<li>\n<p>Little 定律</p>\n</li>\n</ul>\n<h1 id=\"对应书籍整理-计算机系统概述\"><a class=\"anchor\" href=\"#对应书籍整理-计算机系统概述\">#</a> 对应书籍整理 - 计算机系统概述</h1>\n<h2 id=\"计算机结构\"><a class=\"anchor\" href=\"#计算机结构\">#</a> 计算机结构</h2>\n<h3 id=\"硬件\"><a class=\"anchor\" href=\"#硬件\">#</a> 硬件</h3>\n<ol>\n<li>\n<p>CPU</p>\n<ul>\n<li>运算器 —— 各种算数逻辑运算</li>\n<li>控制器 —— 对指令译码并送出操作控制信号</li>\n</ul>\n</li>\n<li>\n<p>存储器 —— 存放指令和数据</p>\n<p>包括 ROM 芯片和 RAM 芯片。</p>\n<ul>\n<li>\n<p>内存储器</p>\n<ul>\n<li>主存</li>\n<li>高速缓存（cache）</li>\n</ul>\n</li>\n<li>\n<p>外存储器</p>\n<p>磁盘、磁带存储器、光盘存储器等</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I/O 设备 —— 计算机和用户之间的信息交换</p>\n</li>\n</ol>\n<h3 id=\"软件\"><a class=\"anchor\" href=\"#软件\">#</a> 软件</h3>\n<ol>\n<li>系统软件 —— 介于计算机硬件和应用软件之间的各种软件\n<ul>\n<li>操作系统软件</li>\n<li>语言处理系统</li>\n<li>数据库管理系统</li>\n<li>各类实用程序</li>\n</ul>\n</li>\n<li>应用软件\n<ul>\n<li>办公自动化软件</li>\n<li>互联网应用软件</li>\n<li>多媒体处理软件</li>\n<li>股票分析软件</li>\n<li>游戏软件</li>\n<li>管理信息系统</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"程序开发和执行过程\"><a class=\"anchor\" href=\"#程序开发和执行过程\">#</a> 程序开发和执行过程</h3>\n<ol>\n<li>高级语言、低级语言（汇编语言）-&gt; 机器语言</li>\n</ol>\n<p>​\t\t其中，汇编语言和机器语言程序员必须对机器的结构和指令系统等细节非常清楚。</p>\n<ol start=\"2\">\n<li>\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>对应计算机用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用程序</td>\n<td>最终用户</td>\n</tr>\n<tr>\n<td>高级语言虚拟机</td>\n<td>高级语言程序员或者应用程序员</td>\n</tr>\n<tr>\n<td>汇编语言虚拟机</td>\n<td>汇编语言程序员</td>\n</tr>\n<tr>\n<td>操作系统虚拟机</td>\n<td>系统管理员</td>\n</tr>\n<tr>\n<td>机器语言虚拟机</td>\n<td>机器语言程序员</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>源程序</strong>通过<strong>编译程序和汇编程序</strong>得到<strong>目标程序</strong></p>\n</li>\n<li>\n<p>编译程序 vs 解释程序（编译程序生成机器码，解释程序生成后立即执行）</p>\n</li>\n</ol>\n<h3 id=\"cpu性能-2\"><a class=\"anchor\" href=\"#cpu性能-2\">#</a> CPU 性能</h3>\n",
            "tags": [
                "NJUSE",
                "计算机组成与结构",
                "计组"
            ]
        }
    ]
}