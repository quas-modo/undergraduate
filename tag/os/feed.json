{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/undergraduate/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io/undergraduate",
    "items": [
        {
            "id": "https://quas-modo.github.io/undergraduate/2024/04/02/jyyos/02-%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "url": "https://quas-modo.github.io/undergraduate/2024/04/02/jyyos/02-%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "title": "02-应用视角下的操作系统",
            "date_published": "2024-04-01T16:35:41.000Z",
            "content_html": "<p>蒋岩炎老师 2024spring 操作系统第二课。</p>\n<p><span id=\"more\"></span></p>\n<ol>\n<li>如何用一行代码破坏不好的 oj：无限长的随机数</li>\n</ol>\n<pre><code class=\"language-C++\">#include &quot;/dev/urandom&quot;\n</code></pre>\n<ol>\n<li>指令集里没有一条关闭计算机的指令，如何关闭计算机？</li>\n</ol>\n<p>由电路操控</p>\n<p>syscall 指令，状态机完全交给计算机</p>\n<ol>\n<li><strong>任何程序 = minimal.s = 状态机</strong></li>\n<li><strong>应用程序 = 计算 + 操作系统 API</strong></li>\n</ol>\n<p>操作系统，从应用程序的视角来看，就是 syscall，提供各种系统的 api</p>\n<p>操作系统的职责：提供令应用程序舒适的抽象（对象 + api）</p>\n<ol>\n<li>C 语言是怎么变成二进制代码的？\n<ol>\n<li>预处理</li>\n<li>编译，代码 -&gt; 汇编语言</li>\n<li>汇编，汇编语言 -&gt; 机器代码</li>\n<li>链接，将目标文件和所需库文件合并 -&gt; 可执行文件</li>\n</ol>\n</li>\n</ol>\n<p>【汉诺塔：递归版本到非递归版本的实现】</p>\n<h2 id=\"编程\"><a class=\"anchor\" href=\"#编程\">#</a> 编程</h2>\n<h3 id=\"minimal\"><a class=\"anchor\" href=\"#minimal\">#</a> Minimal</h3>\n<p>早期 C 语言由于资源限制和编译器限制，允许程序员做调用 “未声明的函数”</p>\n<p>但在现代编译器中， <code>-Wimplicit-function-declaration</code>  是一个在 C 语言编译过程中使用的编译器选项，这个选项的作用是让编译器发出警告，如果源代码中有函数被调用却没有事先声明，就会触发这个警告。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003629676.png\" alt=\"image-20240402003629676\" /></p>\n<p><code>#include</code>  只是做了一个复制粘贴的动作。</p>\n<p>比如说，你可以使用 <code>#include '/dev/urandom'</code>  来轰炸 oj</p>\n<p><code>objdump -d a.out | less</code>  查看二进制文件，但太过复杂</p>\n<p><code>file a.out</code>  确定文件的类型</p>\n<p><strong>gcc 的一些用法：</strong></p>\n<p><code>gcc hello.c -static</code>  静态链接库</p>\n<p><code>gcc --verbose hello.c</code>  啰嗦一点</p>\n<p><code>gcc -c hello.c</code>   compile and assemble, but do not link 生成 <code>hello.o</code>  文件</p>\n<p><code>ld hello.o</code>  尝试链接中间产物（经过编译器编译，但是没有链接的中间产物，目标文件包含了源代码编译后的机器语言代码）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003653374.png\" alt=\"image-20240402003653374\" /></p>\n<pre><code>objdump -d hello.o\n</code></pre>\n<p><strong>gdb 的一些用法：</strong></p>\n<pre><code class=\"language-Shell\">gdb a.out\nstarti\nlayout asm\nlayout src\nsi\nq\ninfo re\n</code></pre>\n<p><strong>为什么以下程序编译的时候出现了 segmentation fault？</strong></p>\n<pre><code class=\"language-C\">int main() &#123;\n&#125;\n</code></pre>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003713140.png\" alt=\"image-20240402003713140\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmFuZ2VybGVlL2FyY2hpdmUvMjAxMi8wNS8yMi8yNTA4NzcyLmh0bWw=\">https://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html</span></p>\n<p>也许你会问：咦？以上 disassemble 的输出不是 main 函数的汇编指令吗，怎么输出中也有上面两条指令？难道 main 也是一个 “被调函数”？</p>\n<p>是的，皆因 main 并不是程序拉起后第一个被执行的函数，它被_start 函数调用，更详细的资料参看<span class=\"exturl\" data-url=\"aHR0cDovL2xlYXJuLmFrYWUuY24vbWVkaWEvY2gxOXMwMi5odG1s\">这里</span>。</p>\n<p>retq 相当于：popq % rip； retq 对应的是 callq，相当于：pushq % rip【% rip 存的是它永远指向下一条即将执行的地址。】</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003733663.png\" alt=\"image-20240402003733663\" /></p>\n<p>加了 <code>#include&lt;stdio.h&gt;</code>  之后，从 main 函数返回的地址不再是 0</p>\n<p><strong>最小汇编：</strong></p>\n<pre><code>make minimal\n</code></pre>\n<p><strong>strace 命令的使用：</strong></p>\n<pre><code>strace -f gcc -o hello hello.c\n</code></pre>\n<p>如何化简 strace 的命令输出，gcc 打开的文件比较重要，编译汇编命令在哪里：</p>\n<ol>\n<li><code>strace -f gcc -o hello hello.c 2&gt;&amp;1 | vim -</code> ：将输入输出给 vim 编辑</li>\n<li><code>%!grep -v -e '-1'</code>  在编辑器里面进行筛选， <code>!</code>  表示执行外部指令，  <code>-v</code>  表示反向选择</li>\n<li><code>%!grep -e read</code>  正向选择， <code>-e</code>  表示正则筛选</li>\n</ol>\n<h3 id=\"非递归汉诺塔\"><a class=\"anchor\" href=\"#非递归汉诺塔\">#</a> 非递归汉诺塔</h3>\n<p>（todo）</p>\n",
            "tags": [
                "NJUSE",
                "OS",
                "OS"
            ]
        },
        {
            "id": "https://quas-modo.github.io/undergraduate/2024/04/02/jyyos/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "https://quas-modo.github.io/undergraduate/2024/04/02/jyyos/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "01-操作系统概述",
            "date_published": "2024-04-01T16:32:26.000Z",
            "content_html": "<p>蒋岩炎老师 2024spring 操作系统第一课。</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"课后教材阅读\"><a class=\"anchor\" href=\"#课后教材阅读\">#</a> 课后教材阅读</h2>\n<h3 id=\"preface-前言\"><a class=\"anchor\" href=\"#preface-前言\">#</a> Preface 前言</h3>\n<p>Virtualization, concurrency and persistence</p>\n<p>虚拟化，并发和持久性</p>\n<p>Learning new things is fun, right? At least, it (usually) should be.【yepppp！】</p>\n<p>Crux of the problem, timelines</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003403641.png\" alt=\"image-20240402003403641\" /></p>\n<p><strong>Education is not the filling of a pail but the lighting of a fire.</strong></p>\n<p>很喜欢这段话，<strong>the real point of education is to get you interested in something, to learn something more about the subject matter on your own and not just what you have to digest to get a good grede in some class.</strong>  说实话，国内教授走上讲台之前都应该思考一下 “什么是教育”，毫不客气地说，有一半以上的大学老师并非合格的老师。</p>\n<h3 id=\"第-1-章-dialogue-on-the-book\"><a class=\"anchor\" href=\"#第-1-章-dialogue-on-the-book\">#</a> 第 1 章 - Dialogue on the Book</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003413903.png\" alt=\"image-20240402003413903\" /></p>\n<h3 id=\"第-2-章-introduction-to-operating-systems\"><a class=\"anchor\" href=\"#第-2-章-introduction-to-operating-systems\">#</a> 第 2 章 - Introduction to Operating Systems</h3>\n<p>虚拟化：操作系统将物理资源转化成更易使用的虚拟资源</p>\n<p>从应用程序的角度看，操作系统提供了各种 api；从物理资源的角度看，操作系统完成了资源（内存、磁盘、处理器等）的调度</p>\n<h4 id=\"虚拟化-cpu\"><a class=\"anchor\" href=\"#虚拟化-cpu\">#</a> 虚拟化 - cpu</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003421487.png\" alt=\"image-20240402003421487\" /></p>\n<p><code>-Wall</code>  参数表示编译后显示所有警告</p>\n<pre><code class=\"language-Shell\">ps aux | grep './cpu'\nkill PID    \nkill $(pgrep -f './cpu')\n</code></pre>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003428819.png\" alt=\"image-20240402003428819\" /></p>\n<p>电脑不是只有一个 cpu（也许不止），怎么能同时运行 4 个程序的？</p>\n<p>如果两个程序都要在一个特定的时间运行怎么办？</p>\n<h4 id=\"虚拟化-内存\"><a class=\"anchor\" href=\"#虚拟化-内存\">#</a> 虚拟化 - 内存</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20240402003438110.png\" alt=\"image-20240402003438110\" /></p>\n<p>为什么，看上去是同时修改了统一 addr 的值？</p>\n<h4 id=\"并发\"><a class=\"anchor\" href=\"#并发\">#</a> 并发</h4>\n<pre><code class=\"language-Shell\">gcc -o threads threads.c -Wall -pthread\n</code></pre>\n<p>这里的 <code>-pthread</code>  是使用 GCC 编译器编译包含 POSIX 线程（pthread）的 C 或 C++ 程序时使用。这个选项告诉编译器链接程序时要包含 POSIX 线程库。</p>\n<p>POSIX 线程（Portable Operating System Interface for uniX，POSIX Threads），简称为 Pthreads，是一个线程标准，定义了一套跨平台的线程相关的 API</p>\n<h4 id=\"持久化\"><a class=\"anchor\" href=\"#持久化\">#</a> 持久化</h4>\n<p>和 CPU 与内存不一样，OS 并没有创建私有、虚拟的磁盘为每一个应用。相反，他们需要共享文件。</p>\n",
            "tags": [
                "NJUSE",
                "OS",
                "OS"
            ]
        }
    ]
}