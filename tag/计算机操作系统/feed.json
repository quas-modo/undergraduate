{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/undergraduate/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io/undergraduate",
    "items": [
        {
            "id": "https://quas-modo.github.io/undergraduate/2023/06/21/NJUSE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
            "url": "https://quas-modo.github.io/undergraduate/2023/06/21/NJUSE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
            "title": "计算机操作系统期末复习",
            "date_published": "2023-06-21T06:43:47.000Z",
            "content_html": "<p>整理了一些 os 的选择题知识点、大题的重要知识点，还有一些简答的梳理。</p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"单元1-操作系统概论\"><a class=\"anchor\" href=\"#单元1-操作系统概论\">#</a> 单元 1 操作系统概论</h2>\n<h3 id=\"操作系统分类\"><a class=\"anchor\" href=\"#操作系统分类\">#</a> 操作系统分类</h3>\n<h4 id=\"批处理系统\"><a class=\"anchor\" href=\"#批处理系统\">#</a> 批处理系统</h4>\n<p>** 多道：** 在内存中同时存放多个作业，一个时刻只有一个作业运行，这些作业共享 CPU 和外部设备等资源。</p>\n<p>** 成批：** 用户和作业之间没有交互性。用户自己不能干预自己的作业的运行，发现作业错误不能及时改正。</p>\n<h4 id=\"分时操作系统\"><a class=\"anchor\" href=\"#分时操作系统\">#</a> 分时操作系统</h4>\n<p>它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。分时系统是指，<strong>在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机</strong>，共享主机中的资源。</p>\n<ol>\n<li>同时性：计算机系统能被多个用户同时使用；</li>\n<li>独立性：用户和用户之间都是独立操作系统的，在同时操作时并不会发生冲突，破坏，混淆等现象；</li>\n<li>及时性：系统能以最快的速度将结果显示给用户；</li>\n<li><strong>交互作用性</strong>：用户能和电脑进行人机对话。</li>\n</ol>\n<h4 id=\"实时操作系统\"><a class=\"anchor\" href=\"#实时操作系统\">#</a> 实时操作系统</h4>\n<p>所谓 “实时”，是表示 “及时”，而<strong>实时系统是指系统能及时响应外部事件的请求</strong>，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。其应用需求主要在实时控制和实时信息处理。</p>\n<p><strong>实时操作系统必须在规定时间内处理来自外部的事件</strong></p>\n<p>特点：</p>\n<p>高精度计时系统：计时精度是影响实时性的一个重要因素。在实时应用系统中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统实现的高精度计时功能。<br />\n多级中断机制：一个实时应用系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理。<br />\n实时调度机制：实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换，只能在确保 “安全切换” 的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多 “安全切换” 时间点，保证及时调度实时任务。</p>\n<h4 id=\"多用户操作系统\"><a class=\"anchor\" href=\"#多用户操作系统\">#</a> 多用户操作系统</h4>\n<h4 id=\"分布式系统\"><a class=\"anchor\" href=\"#分布式系统\">#</a> 分布式系统</h4>\n<p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。</p>\n<h3 id=\"特权指令\"><a class=\"anchor\" href=\"#特权指令\">#</a> 特权指令</h3>\n<p>能引起损害的机器指令作为特权指令</p>\n<ol>\n<li>允许和禁止中断，控制中断禁止屏蔽位</li>\n<li>在进程间切换处理</li>\n<li>存取用于主存保护的寄存器</li>\n<li>执行 I/O 操作</li>\n<li>停止一个中央处理器的工作</li>\n<li>清理内存</li>\n<li>设置时钟</li>\n<li>建立存储键</li>\n<li>加载 PSW</li>\n</ol>\n<h3 id=\"操作系统管理的资源\"><a class=\"anchor\" href=\"#操作系统管理的资源\">#</a> 操作系统管理的资源</h3>\n<ul>\n<li>所有硬件资源，如 CPU、存储器、输入输出设备</li>\n<li>软件资源等，如程序和数据等。</li>\n</ul>\n<h3 id=\"并发性\"><a class=\"anchor\" href=\"#并发性\">#</a> 并发性</h3>\n<p>共享性、虚拟性、异步性</p>\n<ul>\n<li>并行是指两个或多个事件可以在<strong>同一个时刻</strong>发生。</li>\n<li>并发是指两个或多个事件可以在<strong>同一个时间间隔</strong>发生。</li>\n</ul>\n<p>同一时刻即为并行，一定的时间间隔发生即为并发。</p>\n<h3 id=\"多道程序设计\"><a class=\"anchor\" href=\"#多道程序设计\">#</a> 多道程序设计</h3>\n<p>多道程序设计：<strong>允许多个程序（作业）同时进入一个计算机系统的内存并启动进行交替计算的方法</strong>，也就是，计算机中可以同时存放多道程序，从宏观上来看它们是并行的，多道程序都同时处于运行过程中，但都未运行结束，但是微观上是串行的，轮流占用 CPU 交替执行，引入多道程序设计技术的根本目的是提高 CPU 的利用率，充分发挥计算机系统部件的并行性。</p>\n<p>多道程序设计的特点</p>\n<ol>\n<li>CPU 与外部设备充分并行</li>\n<li>外部设备之间充分并行</li>\n<li>发挥 CPU、内存和设备的使用效率</li>\n<li>提高单位时间的算题量 (吞吐率)</li>\n</ol>\n<p>多道程序设计的主要缺点：</p>\n<ol>\n<li>延长了作业的周转时间。</li>\n</ol>\n<h3 id=\"spooling技术\"><a class=\"anchor\" href=\"#spooling技术\">#</a> SPOOLing 技术</h3>\n<p>SPOOLing 技术便可将一台物理 I/O 设备虚拟为多台逻辑 I/O 设备，同样允许多个用户共享一台物理 I/O 设备。</p>\n<h2 id=\"单元2-处理器管理\"><a class=\"anchor\" href=\"#单元2-处理器管理\">#</a> 单元 2 处理器管理</h2>\n<p><strong>目态</strong>：用户态</p>\n<p><strong>管态</strong>：特权态、系统态、核心态</p>\n<p><strong>进程与线程</strong></p>\n<ol>\n<li>进程是资源分配和管理的单位</li>\n<li>线程是处理器调度的基本单位。</li>\n</ol>\n<p><strong>PCB</strong>：进程控制块</p>\n<h3 id=\"进程概念\"><a class=\"anchor\" href=\"#进程概念\">#</a> 进程概念</h3>\n<p><strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。</p>\n<ol>\n<li>具有一定独立功能的程序：进程是相对独立的</li>\n<li>关于某个数据集合：对于不同数据集合的操作不是同一个进程。</li>\n<li>一次运行活动：有生命周期</li>\n</ol>\n<p>动态性、共享性、独立性、制约性、并发性</p>\n<h3 id=\"进程管理原语0\"><a class=\"anchor\" href=\"#进程管理原语0\">#</a> 进程管理原语，0</h3>\n<p>进程创建</p>\n<p>进程撤销</p>\n<p>进程阻塞</p>\n<p>进程唤醒</p>\n<p>进程挂起</p>\n<p>进程激活</p>\n<h3 id=\"进程转换模型\"><a class=\"anchor\" href=\"#进程转换模型\">#</a> 进程转换模型</h3>\n<p>运行态：进程占用处理器运行</p>\n<p>就绪态：进程具备运行条件等待处理器运行</p>\n<p>等待态：又称阻塞态、睡眠态，进程由于等待资源、输入输出、信号等而不具备运行条件</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230609103158553.png\" alt=\"image-20230609103158553\" /></p>\n<p>挂起态：挂起态与等待态有着本质区别，后者占有已申请到的资源处于等待，前者没有任何资源</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230609103911702.png\" alt=\"image-20230609103911702\" /></p>\n<h3 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h3>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/v2-01b5b9ac0ea5c15e050b302e39af5e33_r.jpg\" alt=\"v2-01b5b9ac0ea5c15e050b302e39af5e33_r\" /></p>\n<h4 id=\"用户级线程和内核级线程的区别\"><a class=\"anchor\" href=\"#用户级线程和内核级线程的区别\">#</a> 用户级线程和内核级线程的区别</h4>\n<ol>\n<li>ULT 适用于解决逻辑并行性问题</li>\n<li>KLT 适用于解决物理并行性问题</li>\n</ol>\n<h4 id=\"jacketing技术\"><a class=\"anchor\" href=\"#jacketing技术\">#</a> jacketing 技术</h4>\n<p>为了解决一个 ULT 的阻塞，将引起整个进程的阻塞的问题，出现了 jacketing 技术。</p>\n<p>jacketing 技术将阻塞式的系统调用改造成非阻塞式的，当线程陷入系统调用时，检查 jacketing 程序，由 jackting 程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程。</p>\n<p>比如说，当线程需要 I/O 资源时，它不直接去调用系统 I/O 例程，而是让线程调用一用户级的 I/O 的 Jacketing 例程，这个 jacket 例程中的代码用来检查并确定 I/O 设备是否忙。如果忙，该线程进入阻塞状态并将控制传送给另一个线程。当这个线程后来又重新获得控制时，jacketing 例程会再次检查 I/O 设备。</p>\n<h4 id=\"多线程实现的混合式策略\"><a class=\"anchor\" href=\"#多线程实现的混合式策略\">#</a> 多线程实现的混合式策略</h4>\n<ol>\n<li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li>\n<li>一个应用中的多个用户级线程被映射到一些 (小于等于用户级线程数目) 内核级线程上</li>\n</ol>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvMjAucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/20.png</span>&quot; alt=&quot;img&quot; style=&quot;zoom:33%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvMjEucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/21.png</span>&quot; alt=&quot;img&quot; style=&quot;zoom:33%;&quot; /&gt;</p>\n<h2 id=\"单元3-存储管理\"><a class=\"anchor\" href=\"#单元3-存储管理\">#</a> 单元 3 存储管理</h2>\n<p>存储分配：位进程分配内存空间以便运行，完成内存区的分配和去配工作。</p>\n<p>地址映射：内存被抽象为一维或二维地址空间；逻辑空间到物理空间映射。</p>\n<p>存储保护：系统隔离分配给进程的内存区，防止地址越界或操作越权。</p>\n<p>存储共享：系统允许多个进程共享内存区。</p>\n<p>存储扩充：形成虚拟存储器</p>\n<h3 id=\"静态重定位动态重定位\"><a class=\"anchor\" href=\"#静态重定位动态重定位\">#</a> 静态重定位 / 动态重定位</h3>\n<p><strong>地址转换</strong>：又称重定位，即把逻辑地址转换成绝对地址</p>\n<ol>\n<li><strong>静态重定位</strong>：在<strong>程序装入内存</strong>时进行地址转换：由装入程序执行，早期小型 OS 使用，基于地址固定值进行偏移。</li>\n<li><strong>动态重地位 (主流)</strong>：在<strong> CPU 执行程序时进行地址转换</strong>：从效率出发，依赖硬件地址转换机构，运行时正确的将其逻辑地址转换为物理地址。</li>\n</ol>\n<h3 id=\"存储保护\"><a class=\"anchor\" href=\"#存储保护\">#</a> 存储保护</h3>\n<p>为<strong>避免</strong>主存中的多个进程<strong>相互干扰</strong>，必须<strong>对主存中的程序和数据进行保护</strong></p>\n<ol>\n<li>私有主存区中的信息：可读可写</li>\n<li>公共区中的共享信息：根据授权</li>\n<li>非本进程信息：不可读写</li>\n</ol>\n<h3 id=\"内存碎片外存碎片\"><a class=\"anchor\" href=\"#内存碎片外存碎片\">#</a> 内存碎片 / 外存碎片</h3>\n<p>（1）性质不同：</p>\n<p>①内存碎片：指的是已经被分配出去的，但是却没有被使用的内存空间。 因为基本存储单位的限制</p>\n<p>②外存碎片：指的是还没有被分配的，但是由于太小或者是不连续，而导致不满足要求，所以没办法被分配的内存空间</p>\n<p>（2）存储位置不同：</p>\n<p>①内存碎片是存储于已分配区域内部的</p>\n<p>②外存碎片是存储于未分配区域的</p>\n<p>（3）状态不同：</p>\n<p>①内存碎片：其他进程没办法使用它，因为它被某一个进程占有</p>\n<p>②外存碎片：其他进程没办法使用它，因为它可存储的位置不连续或者是太小了</p>\n<p><strong>分页存储</strong>会产生<strong>内存碎片</strong>，不会产生外存碎片；</p>\n<p><strong>分段存储</strong>不会产生内存碎片，会产生<strong>外存碎片</strong>。</p>\n<p><strong>段页式</strong>存储：产生<strong>内存碎片、外存碎片</strong>。</p>\n<h3 id=\"存储扩充\"><a class=\"anchor\" href=\"#存储扩充\">#</a> 存储扩充</h3>\n<p><strong>对换技术</strong>：把部分不运行的进程调出</p>\n<p><strong>虚拟技术</strong>：只调入进程的部分内容，对单个进程不使用对换技术完成，特点是自动化、透明</p>\n<h3 id=\"内存不足的存储技术\"><a class=\"anchor\" href=\"#内存不足的存储技术\">#</a> 内存不足的存储技术</h3>\n<p><strong>移动技术</strong>：当未分配区表中找不到足够大的空闲区来装入新进程时，我们使用移动技术来完成内存紧凑，实现方法：</p>\n<ol>\n<li>全部移动到一侧</li>\n<li>移动直到有足够大的空闲区</li>\n</ol>\n<p>需要动态重定位支撑:</p>\n<p><strong>对换技术</strong>：如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用，；同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为<strong>对换</strong>。</p>\n<p><strong>内存覆盖技术</strong>：指程序执行过程中程序的不同模块在内存中相互替代，以达到小内存执行大程序的目的。</p>\n<h3 id=\"存储层次\"><a class=\"anchor\" href=\"#存储层次\">#</a> 存储层次</h3>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvMy5wbmc=\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/3.png</span>&quot; alt=&quot;3&quot; style=&quot;zoom:33%;&quot; /&gt;</p>\n<h3 id=\"页式存储\"><a class=\"anchor\" href=\"#页式存储\">#</a> 页式存储</h3>\n<p>逻辑地址 = 页号 + 页面偏移</p>\n<p>物理地址 = 页架号（页框号） + 单元号（页内偏移)</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610095628687.png\" alt=\"image-20230610095628687\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610095822503.png\" alt=\"image-20230610095822503\" /></p>\n<p><strong>页的共享</strong>：</p>\n<ol>\n<li><strong>数据共享</strong>：不同进程可以使用<strong>不同</strong>页号共享数据页</li>\n<li><strong>程序共享</strong>：不同进程必须使用<strong>相同</strong>页号共享代码页</li>\n</ol>\n<p><strong>页式存储管理的地址转换</strong></p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTAxMDA2MTQxOTIucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610100614192.png</span>&quot; alt=&quot;image-20230610100614192&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>页表控制寄存器存储了当前的页表的地址和长度</p>\n<p><strong>多级页表</strong></p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTAxMDEyMTQ4NDMucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610101214843.png</span>&quot; alt=&quot;image-20230610101214843&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>逻辑地址结构有三部分组成：页目录、页表页和位移</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTAxMDMzMTgzMTcucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610103318317.png</span>&quot; alt=&quot;image-20230610103318317&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p><strong>反置页表 IPT</strong></p>\n<p>正向页表：以<strong>页号</strong>为索引 (隐含)，完整连续排列，页表项中不含页号，每个进程单独一个页表</p>\n<p>反置页表：以<strong>页框号</strong>为索引 (隐含)，完整连续排列，每个页框填入的是哪个进程的哪个页号，索引进程共用一个反置页表。其页表项不包含页框号</p>\n<p>通过这个结构，哈希表和反向表中只有一项对应于一个实存页 (面向实存)，而不是虚拟页 (面向虚存)。<br />\n因此，不论由多少进程、支持多少虚拟页，页表都只需要<strong>实存中的一个固定部分</strong>。</p>\n<p>页表结构：页号、进程标识符、控制位、哈希链指针</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTAxMDQ0NTI3MjcucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610104452727.png</span>&quot; alt=&quot;image-20230610104452727&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTgxMDQ0MDkxNzcucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618104409177.png</span>&quot; alt=&quot;image-20230618104409177&quot; style=&quot;zoom: 25%;&quot; /&gt;</p>\n<h3 id=\"段式存储\"><a class=\"anchor\" href=\"#段式存储\">#</a> 段式存储</h3>\n<p>逻辑地址 = 段号 + 段内偏移</p>\n<p>页式存储管理中页的划分对程序员不可见。</p>\n<p>段式存储管理中段的划分对程序员可见。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTAxMDUwMTY3ODEucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610105016781.png</span>&quot; alt=&quot;image-20230610105016781&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h3 id=\"段页式存储管理\"><a class=\"anchor\" href=\"#段页式存储管理\">#</a> 段页式存储管理</h3>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTAxMDU0MTQxNDUucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230610105414145.png</span>&quot; alt=&quot;image-20230610105414145&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h3 id=\"页面调度未看\"><a class=\"anchor\" href=\"#页面调度未看\">#</a> 页面调度（未看）</h3>\n<p>OPT 页面调度算法（Belady 算法）</p>\n<p>先进先出页面调度算法 FIFO-Belady 异常 - 更多的页框导致了更高的缺页率，页框为 3 和 4 的时候</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTgxMDU2NTIxMjcucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618105652127.png</span>&quot; alt=&quot;image-20230618105652127&quot; style=&quot;zoom:25%;&quot; /&gt;</p>\n<p>页面缓冲算法</p>\n<p>最近最少用 LRU</p>\n<p>第二次机会页面替换算法 SCR</p>\n<p>最不常用 LFU</p>\n<p>时钟 CLOCK</p>\n<h2 id=\"单元4-设备管理\"><a class=\"anchor\" href=\"#单元4-设备管理\">#</a> 单元 4 设备管理</h2>\n<h3 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h3>\n<ol>\n<li>\n<p>按信息传输方向 (I/O 操作特性) 分类</p>\n<ol>\n<li>输入</li>\n<li>输出</li>\n<li>输入输出</li>\n</ol>\n</li>\n<li>\n<p>按交互功能划分</p>\n<ol>\n<li>人机交互</li>\n<li>存储</li>\n<li>机机通信</li>\n</ol>\n</li>\n<li>\n<p>按设备管理 (I/O 信息交换单位) 划分</p>\n<ol>\n<li>字符</li>\n<li>块</li>\n<li>网络</li>\n</ol>\n</li>\n<li>\n<p>按传输速率</p>\n<ol>\n<li>\n<p>低速设备，键盘、鼠标</p>\n<p><strong>大多数低速设备都属于独享设备</strong></p>\n</li>\n<li>\n<p>中速设备，激光打印机</p>\n</li>\n<li>\n<p>高速设备，磁盘机、光盘机</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"io控制方式\"><a class=\"anchor\" href=\"#io控制方式\">#</a> IO 控制方式</h3>\n<ol>\n<li>轮询（程序直接控制方式）\n<ul>\n<li>重复测试</li>\n<li>CPU 和设备串行工作</li>\n</ul>\n</li>\n<li>中断\n<ul>\n<li>CPU 和设备部分并行</li>\n</ul>\n</li>\n<li>DMA（Direct Memory Access 直接存储器访问）\n<ul>\n<li><strong>内存和设备</strong>之间有一条数据通路成块地传送数据，<strong>无需 CPU 参与</strong></li>\n<li>流程：\n<ul>\n<li>处理器向 DMA 模块发出 I/O 命令</li>\n<li>处理器继续执行其它工作，DMA 模块负责传送全部数据</li>\n<li>数据传送结束后，DMA 中断处理器</li>\n</ul>\n</li>\n<li>周期窃取：CPU 总是将总线的占有权让给 DMA 一个或几个主存周期，一般是 1 个存取周期，让设备和内存之间交换数据。</li>\n</ul>\n</li>\n<li>IO 通道\n<ul>\n<li>定义：\n<ul>\n<li>一个<strong>具有特殊功能的处理器</strong>，它有自己的指令和程序，专门负责数据输入输出的传输控制 (CPU 把传输控制的功能下放给通道)。通道受 CPU 的 I/O 指令启动、停止或改变其工作状态。</li>\n</ul>\n</li>\n<li>功能：\n<ul>\n<li>按 I/O 指令要求启动 I/O 设备</li>\n<li>执行通道指令</li>\n<li>组织 I/O 设备和主存进行数据传输</li>\n<li>向 CPU 报告中断</li>\n</ul>\n</li>\n<li>CPU 与通道高度并行</li>\n<li>IO 指令由 IO 通道所包含的处理器执行</li>\n<li>与 DMA 的区别：可以连接多个设备，读取多个数据块</li>\n<li><strong>通道指令</strong>：又叫通道控制字 (CCW)，它是通道用于执行 I/O 操作的指令，它可以由管理程序存放在主存的任何地方，由通道从主存取出并执行。【<strong>IO 指令是 CPU 指令系统的一部分，用于控制输入输出操作的指令，通道指令是通道本身的指令，用来执行 IO 操作</strong>】</li>\n<li><strong>通道程序</strong>：由<strong>通道指令</strong>组成，它完成某种外围设备与主存传送信息的操作，如将磁带记录区的部分内容送到指定地址的主存缓冲区内。</li>\n<li><strong>这是一种硬件机制。</strong></li>\n</ul>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>CPU 作用</th>\n<th>等待设备</th>\n<th>数据传送</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>轮询方式</td>\n<td>需要</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>中断方式</td>\n<td>不需要</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>DMA 方式</td>\n<td>不需要</td>\n<td>不需要</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616142618761.png\" alt=\"image-20230616142618761\" /></p>\n<p>一个有趣的例子 belike：</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616142349234.png\" alt=\"image-20230616142349234\" /></p>\n<ol start=\"5\">\n<li>总线\n<ol>\n<li>单总线</li>\n<li>传统的三级总线</li>\n<li>采用南北桥的多级总线</li>\n<li>采用 IO 通道的多级总线</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"io软件的实现todo再看看\"><a class=\"anchor\" href=\"#io软件的实现todo再看看\">#</a> IO 软件的实现【todo 再看看】</h3>\n<p><strong>同步 / 异步传输</strong>：支持<strong>阻塞和中断驱动</strong>两种工作方式</p>\n<p><strong>层次</strong>：</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616165104832.png\" alt=\"image-20230616165104832\" /></p>\n<h4 id=\"io中断处理程序\"><a class=\"anchor\" href=\"#io中断处理程序\">#</a> IO 中断处理程序</h4>\n<ol>\n<li><strong>处理 IO 中断</strong>：检查设备状态寄存器内容，判断产生中断的原因，根据 I/O 操作的完成情况进行相应的处理</li>\n<li><strong>报告错误</strong>：如果数据传输有错，向上层软件报告设备的出错信息，实施重新执行</li>\n<li><strong>唤醒驱动程序</strong>：如果正常结束，唤醒等待传输的进程，使其转换为<strong>就绪态</strong>设备驱动程序</li>\n</ol>\n<h4 id=\"设备驱动程序\"><a class=\"anchor\" href=\"#设备驱动程序\">#</a> 设备驱动程序</h4>\n<p><strong>任务</strong>：</p>\n<ol>\n<li>把用户提交的<strong>逻辑 I/O 请求</strong>转化为<strong>物理 I/O 操作</strong>的启动和执行，如设备名转换为端口等</li>\n<li>监督设备是否正确执行，管理<strong>数据缓冲区</strong>，进行必要的纠错处理</li>\n</ol>\n<p><strong>功能</strong>：</p>\n<ol>\n<li>设备初始化：在系统初次启动或设备传输数据时，预置设备和控制器以及通道状态</li>\n<li>执行设备驱动例程\n<ol>\n<li>负责启动设备，进行数据传输</li>\n<li>对于具有通道方式，还负责生成通道指令和通道程序，启动通道工作</li>\n</ol>\n</li>\n<li>调用和执行中断处理程序：负责处理设备和控制器及通道所发出的各种中断</li>\n</ol>\n<h4 id=\"独立于设备的io软件\"><a class=\"anchor\" href=\"#独立于设备的io软件\">#</a> 独立于设备的 IO 软件</h4>\n<h4 id=\"用户空间的io软件\"><a class=\"anchor\" href=\"#用户空间的io软件\">#</a> 用户空间的 IO 软件</h4>\n<p>SPOOLing 软件</p>\n<h3 id=\"缓冲技术\"><a class=\"anchor\" href=\"#缓冲技术\">#</a> 缓冲技术</h3>\n<p>缓冲区：在<strong>内存</strong>中开辟的存储区，专门用于临时存放 I/O 操作的数据</p>\n<p>解决<strong> CPU 与设备之间速度不匹配</strong>的矛盾</p>\n<p>基本思想：写缓冲、读缓冲</p>\n<p>实现：</p>\n<ol>\n<li>\n<p>单缓冲</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616145632492.png\" alt=\"image-20230616145632492\" /></p>\n<ul>\n<li>工作机制：\n<ul>\n<li>输入：将数据读至缓冲区，系统将缓冲区数据送至用户区，应用程序对数据进行处理；如此往复，系统读入后续的数据</li>\n<li>输出：把数据从用户区复制到缓冲区，再将数据输出后，应用程序继续请求输出</li>\n</ul>\n</li>\n<li>性能计算</li>\n</ul>\n</li>\n<li>\n<p>双缓冲</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616145655627.png\" alt=\"image-20230616145655627\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616145738740.png\" alt=\"image-20230616145738740\" /></p>\n</li>\n<li>\n<p>多缓冲</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616145234883.png\" alt=\"image-20230616145234883\" /></p>\n<p>多缓冲组成的循环缓冲技术，多缓冲的缓冲区是系统的公共资源，可供进程共享并由系统统一分配和管理。</p>\n</li>\n<li>\n<p>缓冲池</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616161718238.png\" alt=\"image-20230616161718238\" /></p>\n<p><strong>使多个进程能够有效地同时处理输入和输出</strong></p>\n</li>\n<li>\n<p>循环缓冲</p>\n</li>\n</ol>\n<h3 id=\"驱动调度技术\"><a class=\"anchor\" href=\"#驱动调度技术\">#</a> 驱动调度技术</h3>\n<p><strong>磁盘是一种直接存取存储设备</strong>，磁带是一种顺序存取存储设备</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616150524875.png\" alt=\"image-20230616150524875\" /></p>\n<ol>\n<li>三维地址（磁头号、柱面号、扇区号）\n<ol>\n<li>盘面号也被叫做<strong>磁头号</strong></li>\n<li>磁道号也被叫做<strong>柱面号</strong></li>\n<li>区别:&quot;0 面 0 道 1 扇区&quot; 中的 &quot;面&quot; 是指磁头，不是柱面\n<ol>\n<li><strong>面和道都是 0 开始</strong></li>\n<li><strong>扇区是从 1 开始</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>磁盘存取时间 = 寻道时间 + 旋转延迟 + 传送时间</li>\n</ol>\n<h3 id=\"磁盘的驱动调度\"><a class=\"anchor\" href=\"#磁盘的驱动调度\">#</a> 磁盘的驱动调度</h3>\n<ol>\n<li>旋转调度\n<ul>\n<li>目的:<strong> 使得旋转延迟的总时间最少</strong></li>\n<li>旋转排序\n<ul>\n<li>通过优化 I/O 请求<strong>排序</strong>，在<strong>最少旋转圈数</strong>内完成位于同一柱面的访问请求</li>\n</ul>\n</li>\n<li>优化分布\n<ul>\n<li>通过信息在存储空间的排列方式来减少旋转延迟</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>移臂调度</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616151146552.png\" alt=\"image-20230616151146552\" /></p>\n<ol start=\"3\">\n<li>磁盘冗余阵列</li>\n<li>cache / 替换</li>\n</ol>\n<h3 id=\"设备分配\"><a class=\"anchor\" href=\"#设备分配\">#</a> 设备分配</h3>\n<ol>\n<li>\n<p>设备的分类：</p>\n<ul>\n<li>独占设备：一次只能由一个进程独占使用</li>\n<li>共享设备：多个进程同时使用的设备，其管理工作主要是驱动调度和实施驱动，一般不必分配</li>\n<li><strong>虚拟设备</strong>：使用一类物理设备模拟另一类物理设备的技术，<strong>让独享型设备变为共享设备</strong></li>\n</ul>\n</li>\n<li>\n<p>设备独立性：</p>\n<ul>\n<li>用户通常不指定物理设备，而是指定<strong>逻辑设备</strong>，使得用户作业和物理设备分离开来，再通过其它途径建立逻辑设备和物理设备之间的映射</li>\n<li>设备管理的功能就是将<strong>逻辑设备名转换为物理设备名</strong>，为此系统需要提供逻辑设备名和物理设备名的对应表以供转换使用。\n<ul>\n<li><strong>逻辑设备号</strong>由用户定义。</li>\n<li><strong>物理设备号</strong>由系统规定，不可修改。</li>\n</ul>\n</li>\n<li><strong>绝对号 / 相对号</strong>\n<ul>\n<li>绝对号：就是将每一台设备确定一个编号（相当于一个绝对地址）</li>\n<li>相对号：就是为了用户程序的方便而设的，在用户请求使用时，采用 “设备类 - 相对号” 来提出使用设备要求。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>分配方式：</p>\n<ul>\n<li>静态分配：防止死锁</li>\n<li>动态分配：设备利用率高</li>\n</ul>\n</li>\n<li>\n<p>设备分配算法：</p>\n<ol>\n<li>先来先服务</li>\n<li>优先级高者优先</li>\n</ol>\n</li>\n<li>\n<p>SPOOLing 设备（假脱机技术）</p>\n<ul>\n<li>将<strong>独占设备改成共享设备</strong>的技术</li>\n<li>采用<strong>预输入、缓输出和井管理</strong>技术</li>\n<li>通过创建守护进程和特殊目录解决<strong>独占型设备</strong>的<strong>空占</strong>问题</li>\n<li><strong>目的：提高 IO 设备的使用效率</strong></li>\n<li>缓和 CPU 的高速性与 IO 设备低速性之间的矛盾，以空间换时间</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616153606908.png\" alt=\"image-20230616153606908\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616154208873.png\" alt=\"image-20230616154208873\" /></p>\n<p>例子：共享打印机</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616154132122.png\" alt=\"image-20230616154132122\" /></p>\n<p>打印机守护进程和 SPOOLing 打印目录</p>\n<ol>\n<li><strong>守护进程</strong>是唯一有<strong>特权</strong>使用打印机设备的进程</li>\n<li>打印文件前，用户进程先产生完整的<strong>待输出文件</strong>，并存放在打印目录下</li>\n<li>打印机空闲时，启动守护进程，打印<strong>待输出文件</strong></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"单元5-文件管理\"><a class=\"anchor\" href=\"#单元5-文件管理\">#</a> 单元 5 文件管理</h2>\n<h3 id=\"文件系统及其功能\"><a class=\"anchor\" href=\"#文件系统及其功能\">#</a> 文件系统及其功能</h3>\n<p><strong>主要目的：实现对文件的按名存取</strong></p>\n<p>同一个文件必须从<strong>逻辑文件</strong>和<strong>物理文件</strong>两个侧面来观察它</p>\n<ol>\n<li>对于用户，需要并遵守文件系统的规则来定义文件信息的逻辑结构，由文件系统提供<strong>按名存取</strong>方式来实现对文件信息的存储和检索。</li>\n<li>对于系统，必须采用<strong>特定数据结构和有效算法</strong>实现文件的<strong>逻辑结构到存储结构</strong>的映射，实现对文件存储空间和文件信息的管理，提供多种存取方法</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616172631369.png\" alt=\"image-20230616172631369\" /></p>\n<h3 id=\"文件的逻辑结构\"><a class=\"anchor\" href=\"#文件的逻辑结构\">#</a> 文件的逻辑结构</h3>\n<h4 id=\"逻辑文件\"><a class=\"anchor\" href=\"#逻辑文件\">#</a> 逻辑文件</h4>\n<p>独立于<strong>物理环境</strong>的，用户概念中的<strong>抽象信息组织方式</strong>是<strong>文件的逻辑结构</strong>，用户能观察到的，并加以处理的数据集合构成逻辑文件</p>\n<ol>\n<li><strong>流式文件</strong>\n<ul>\n<li><strong>无结构</strong>文件，指文件内的数据不再组成记录，只是由一串依次的<strong>字节</strong>组成的<strong>信息流序列</strong>，称为<strong>字节流文件</strong></li>\n<li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界，使用读写指针访问</li>\n<li>Linux 系统只提供流式文件</li>\n</ul>\n</li>\n<li><strong>记录式文件</strong>\n<ul>\n<li>记录式文件是一种<strong>有结构</strong>的文件，它是若干<strong>逻辑记录信息</strong>所组成的记录流文件\n<ol>\n<li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li>\n<li>每个职工的工资信息是一个逻辑记录；</li>\n<li>整个单位职工的工资信息便组成了该单位工资信息的记录式文件</li>\n</ol>\n</li>\n<li><strong>逻辑记录</strong>是文件内<strong>独立的最小信息单位</strong>，文件记录位置代替字节位置。</li>\n<li>记录是文件常用的记录组织和使用方法\n<ol>\n<li><strong>记录式顺序文件</strong>：文件的记录顺序生成并被顺序访问。</li>\n<li><strong>记录式索引文件</strong>：文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引文件便指向相应记录。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"物理结构\"><a class=\"anchor\" href=\"#物理结构\">#</a> 物理结构</h4>\n<p>文件的物理结构和组织是指<strong>逻辑文件在物理存储空间中的存放方法和组织关系</strong>。</p>\n<p>此时文件看做物理文件，即相关物理块的集合。文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等许多问题</p>\n<ol>\n<li>\n<p><strong>顺序文件</strong></p>\n<ul>\n<li>将一个文件中<strong>逻辑上连续</strong>的信息存放到<strong>存储介质的依次相邻的块</strong>中便形成顺序结构，这类文件叫顺序文件，又称连续文件</li>\n</ul>\n</li>\n<li>\n<p><strong>连接文件</strong></p>\n<ul>\n<li>\n<p>使用连接字 (指针) 来表示文件中各条记录之间的关系</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616200258444.png\" alt=\"image-20230616200258444\" /></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>直接文件、散列文件或哈希文件</strong></p>\n<ul>\n<li>在直接存取存储设备上，利用哈希法将记录的关键字与其地址之间建立某种对应关系，以便实现快速存取的文件</li>\n</ul>\n</li>\n<li>\n<p><strong>索引文件</strong></p>\n<ul>\n<li>索引文件为每个文件建立了一张<strong>索引表</strong>，索引表记录方式有多种：\n<ol>\n<li>记录组成文件的磁盘块号，适用于流式文件。</li>\n<li>所以表项包含记录键及其磁盘块号，适用于记录式文件。</li>\n</ol>\n</li>\n</ul>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616200222696.png\" alt=\"image-20230616200222696\" /></p>\n</li>\n</ol>\n<h3 id=\"存取方法\"><a class=\"anchor\" href=\"#存取方法\">#</a> 存取方法</h3>\n<p>文件存取方法在某种程度上依赖于<strong>文件的物理结构</strong></p>\n<ol>\n<li><strong>顺序存取</strong>\n<ul>\n<li>按<strong>记录顺序</strong>进行读 / 写操作的存取方法称顺序存取</li>\n<li><strong>磁带机</strong>是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和便于保存等优点，广泛用作存档</li>\n<li><strong>光盘</strong>也是一种顺序存取存储设备，光盘上的磁道不是同心圆，而是螺旋形的，本质的线性的。</li>\n</ul>\n</li>\n<li><strong>随机存取</strong>（直接存取）\n<ul>\n<li>可以非顺序地从文件中的任何位置存取文件内容</li>\n<li>要求快速地以<strong>任意次序</strong>直接<strong>读写</strong>某个记录</li>\n<li><strong>磁盘文件</strong></li>\n</ul>\n</li>\n<li><strong>索引存取</strong>\n<ul>\n<li>基于<strong>索引文件</strong>的索引存取方法</li>\n<li>文件的记录不按位置而是按其记录名和记录键来编址</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"文件操作\"><a class=\"anchor\" href=\"#文件操作\">#</a> 文件操作</h3>\n<h4 id=\"文件的创建create\"><a class=\"anchor\" href=\"#文件的创建create\">#</a> 文件的创建 create</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 创建成功后系统返回的文件描述符</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> mode<span class=\"token punctuation\">;</span>         <span class=\"token comment\">//mode 是文件所具有的权限</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>filenamep<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 指向要创建的文件路径名的字符串指针</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>fd <span class=\"token operator\">=</span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>filenamep<span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"文件的删除\"><a class=\"anchor\" href=\"#文件的删除\">#</a> 文件的删除</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">unlink</span><span class=\"token punctuation\">(</span>filenamep<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"文件的打开open\"><a class=\"anchor\" href=\"#文件的打开open\">#</a> 文件的打开 open</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> filenamep<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>fd <span class=\"token operator\">=</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span>filenamep<span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>输入是含路径的文件名</strong></p>\n<p>→→ 依据层次式目录结构解释与检索</p>\n<p>→→ 匹配文件名并读取目录项</p>\n<p>→→ 提取 inode 号</p>\n<p>→→ 按号定位，在 inode 区读取 inode 数据结构 (主存活动 inode)</p>\n<p>→→ <strong>输出是返回文件描述符（字）</strong>，即 file descriptor（成功打开文件，则会返回一个大于 0 的文件描述符；如果打开文件失败，则会返回 - 1）</p>\n<h4 id=\"文件的关闭close\"><a class=\"anchor\" href=\"#文件的关闭close\">#</a> 文件的关闭 close</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"文件的读取read\"><a class=\"anchor\" href=\"#文件的读取read\">#</a> 文件的读取 read</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> nr<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 系统调用后实际读入的字节数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 文件描述符</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 要求传送的字符</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 应该输入的用户数据区的首地址</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>nr <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"文件的写write\"><a class=\"anchor\" href=\"#文件的写write\">#</a> 文件的写 write</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> nw<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 系统调用后实际写入的字节数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 文件描述符</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 要求传送的字符</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 数据传送的源地址</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>nw <span class=\"token operator\">=</span> <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"文件的随机存取\"><a class=\"anchor\" href=\"#文件的随机存取\">#</a> 文件的随机存取</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 当前的 offset</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> whence<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 指向一个以读或写方式打开的文档</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">lseek</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> whence<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>文件描述字 fd 必须指向一个用读或写方式打开的文件</p>\n<ol>\n<li>当 whence 是 0 时，则 f_offset 被置为 offset，</li>\n<li>当 whence 是 1 时，则 f_offset 被置为文件当前位置加上 offset。</li>\n</ol>\n<h3 id=\"文件目录\"><a class=\"anchor\" href=\"#文件目录\">#</a> 文件目录</h3>\n<p>文件目录是实现文件的<strong>按名存取</strong>的关键数据结构</p>\n<h4 id=\"linux\"><a class=\"anchor\" href=\"#linux\">#</a> linux</h4>\n<p>linux 基本目录项：inode = 文件名 + inode 号</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616194928961.png\" alt=\"image-20230616194928961\" /></p>\n<p>嵌入在 inode 中的<strong>索引地址表</strong>不可以太大</p>\n<ol>\n<li>文件较小使用直接地址 (直接索引)</li>\n<li>文件较大使用间接索引</li>\n</ol>\n<p>f_count 和 i_count 分别反映进程动态地共享一个文件的两种方式</p>\n<ol>\n<li><strong>f_count</strong> 反映<strong>不同进程</strong>通过<strong>同一个</strong>系统打开文件表项共享一个文件的情况；</li>\n<li><strong>i_count</strong> 反映<strong>不同进程</strong>通过<strong>不同</strong>系统打开文件表项共享一个文件的情况。</li>\n</ol>\n<h4 id=\"多级层次目录结构\"><a class=\"anchor\" href=\"#多级层次目录结构\">#</a> 多级层次目录结构</h4>\n<p>易于规定不同层次或子树中文件的不同存取权限，便于文件的保护、保密和共共享</p>\n<p>为了解决不同用户文件 “<strong>命名冲突</strong>” 的问题，通常在文件系统中采用<strong>多级目录</strong>。</p>\n<h2 id=\"单元6-并行\"><a class=\"anchor\" href=\"#单元6-并行\">#</a> 单元 6 并行</h2>\n<h3 id=\"临界区\"><a class=\"anchor\" href=\"#临界区\">#</a> 临界区</h3>\n<p><strong>临界资源</strong>：<strong>互斥共享变量所代表的资源，即一次只能被一个进程使用的资源</strong></p>\n<ol>\n<li>举例：火车上的卫生间就是一种互斥使用的共享资源</li>\n<li>使用共享变量代表共享资源</li>\n</ol>\n<p><strong>临界区</strong> (critical section)：并发进程中与互斥共享变量相关的<strong>程序段</strong>，与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预见</p>\n<p><strong>临界区</strong>：每个进程中访问临界资源的<strong>那段代码</strong>称为临界区。</p>\n<h3 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h3>\n<p>P(s)：</p>\n<ol>\n<li>将信号量 s 减去 1，若结果小于 0，则调用 P (s) 的进程被置成等待信号量 s 的状态</li>\n<li>负数的绝对值就是等待的进程的个数</li>\n</ol>\n<p>V (s)：将信号量 s 加 1，若结果不大于 0，则释放 (唤醒) 一个等待信号量 s 的进程，使其转换为<strong>就绪态</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230617100634832.png\" alt=\"image-20230617100634832\" /></p>\n<h3 id=\"进程通信信息传递\"><a class=\"anchor\" href=\"#进程通信信息传递\">#</a> 进程通信（信息传递）</h3>\n<p>当进程互相交互时，必须满足两个基本要求：<strong>同步和通信</strong></p>\n<h4 id=\"进程直接通信\"><a class=\"anchor\" href=\"#进程直接通信\">#</a> 进程直接通信</h4>\n<ul>\n<li>\n<p>对称直接寻址，发送进程和接收进程必须<strong>命名对方</strong>以便通信</p>\n</li>\n<li>\n<p>非对称直接寻址，<strong>只要发送者命名接收者，而接收者不需要命名发送者</strong></p>\n<ul>\n<li>receive(<strong>id</strong>, message) 接收来自任何进程的消息，变量 id 置成与其通信的进程名称</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程间接通信\"><a class=\"anchor\" href=\"#进程间接通信\">#</a> 进程间接通信</h4>\n<p>发送或者接收信件通过<strong>一个信箱</strong>来进行，该信箱有<strong>唯一标识符</strong></p>\n<p>消息不是直接从发送者发送到接收者，而是发送到由<strong>临时保存这些消息的队列组成的一个共享数据结构</strong>，这些队列通常成为<strong>信箱</strong> (mailbox)</p>\n<h4 id=\"管道和套接字\"><a class=\"anchor\" href=\"#管道和套接字\">#</a> 管道和套接字</h4>\n<p>管道和套接字都是基于信箱的消息传递方式的一种<strong>变体</strong></p>\n<h3 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h3>\n<p>不仅与系统拥有的资源数量有关，而且与资源分配策略，进程对资源的使用要求以及并发进程的推进顺序有关</p>\n<h4 id=\"死锁产生的四个必要条件\"><a class=\"anchor\" href=\"#死锁产生的四个必要条件\">#</a> 死锁产生的四个必要条件</h4>\n<ol>\n<li><strong>互斥条件</strong>：进程应互斥使用资源，任一时刻一个资源仅为一个进程独占</li>\n<li><strong>占有和等待条件</strong>：一个进程请求资源得不到满足而等待时，不释放已占有的资源</li>\n<li><strong>不剥夺条件</strong>：任一进程不能从另一进程那里抢夺资源</li>\n<li><strong>循环等待条件</strong>：存在一个循环等待链，每一个进程分别等待它前一个进程所持有的资源</li>\n<li>前三个是死锁存在的必要条件，但不是充分条件，第四个条件是前三个条件同时存在时所产生的结果。</li>\n</ol>\n<h4 id=\"死锁防止\"><a class=\"anchor\" href=\"#死锁防止\">#</a> 死锁防止</h4>\n<ul>\n<li>破坏互斥条件：把独占型资源改造成共享性资源</li>\n<li>破坏占有和等待条件：\n<ul>\n<li>静态分配是指进程在执行中<strong>不再申请资源</strong>，就不会出现占有某些资源再等待另一些资源的情况。</li>\n<li>所有并发执行的进程要求的资源总和不超过系统拥有的资源数</li>\n</ul>\n</li>\n<li>破坏不剥夺条件\n<ul>\n<li>采用剥夺式调度方法</li>\n</ul>\n</li>\n<li>破坏循环等待条件\n<ul>\n<li>层次分配策略\n<ul>\n<li>一个进程得到某一层的一个资源后，它只能<strong>再申请在较高层</strong>的资源</li>\n<li>当一个进程要释放某层的一个资源时，必须先<strong>释放所占用的较高层</strong>的资源</li>\n<li>当一个进程获得了<strong>某一层</strong>的一个资源后，它想再申请该层中的另一个资源，那么，必须先释放该层中的已占资源</li>\n</ul>\n</li>\n<li>按序分配策略\n<ul>\n<li>把系统的所有资源排一个顺序，例如，系统若共有 n 个进程，共有 m 个资源，用 ri 表示第 i 个资源，于是这 m 个资源是：r1,r2,...,rm</li>\n<li>规定如果进程不得在占用资源 ri (1≤i≤m) 后再申请 rj (j&lt;i)。不难证明，按这种策略分配资源时系统不会发生死锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"死锁避免\"><a class=\"anchor\" href=\"#死锁避免\">#</a> 死锁避免</h4>\n<p>把资源分配给申请者会产生死锁的话，则拒绝分配，否则接收申请，为它分配资源</p>\n<ul>\n<li>银行家算法（todo）</li>\n</ul>\n<h4 id=\"死锁检测与恢复\"><a class=\"anchor\" href=\"#死锁检测与恢复\">#</a> 死锁检测与恢复</h4>\n<ul>\n<li>\n<p>检测</p>\n<ul>\n<li>\n<p>可设置两张表格来记录进程使用资源的情况</p>\n<ol>\n<li>等待资源表记录每个被<strong>阻塞进程等待</strong>的资源</li>\n<li>占用资源表记录每个进程<strong>占有</strong>的资源</li>\n</ol>\n<p>如果出现循环等待，则出现了死锁</p>\n</li>\n<li>\n<p>资源分配图</p>\n<p>看看这个理解理解：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI4NDM2L2FydGljbGUvZGV0YWlscy8xMTExMjM3Nzk=\">https://blog.csdn.net/qq_39328436/article/details/111123779</span></p>\n<ul>\n<li>\n<p>每个资源用一个<strong>方框</strong>表示</p>\n</li>\n<li>\n<p>方框中的<strong>黑圆点</strong>表示此资源类中的各个资源</p>\n</li>\n<li>\n<p>每个进程用一个<strong>圆圈</strong>表示</p>\n</li>\n<li>\n<p><strong>有向边</strong>表示进程申请资源和资源被分配情况</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230617104337516.png\" alt=\"image-20230617104337516\" /></p>\n<p>如果进程 - 资源分配图中无环路，此时系统没有发生死锁。</p>\n<p>如果进程 - 资源分配图中有环路，且每个资源都只有一个资源则发生死锁。</p>\n<p>如果进程 - 资源分配图中有环路，且所涉及资源有多个资源，则未必发生死锁。可以通过消去法来判断，消去既不阻塞其他进程又与其他进程相关的进程的所有请求边和分配边，得到一个孤立点。接着将等待资源的进程分配后再次消去，如果最后所有的进程都成为孤立点则是无死锁的，图是可完全简化的，否则图是不可以完全简化的。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>死锁定理</p>\n<ul>\n<li>系统为死锁状态的充分条件是：当且仅当该状态的进程 - 资源分配图是<strong>不可完全简化</strong>的。该充分条件称为死锁定理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>恢复</p>\n<ul>\n<li>资源剥夺法</li>\n<li>进程回退法</li>\n<li>进程撤销法</li>\n<li>系统重启法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"并发\"><a class=\"anchor\" href=\"#并发\">#</a> 并发</h3>\n<h4 id=\"bernstein条件\"><a class=\"anchor\" href=\"#bernstein条件\">#</a> Bernstein 条件</h4>\n<p>并发进程的无关性是进程的执行与时间无关的一个充分条件</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618212358786.png\" alt=\"image-20230618212358786\" /></p>\n<h4 id=\"peterson算法\"><a class=\"anchor\" href=\"#peterson算法\">#</a> peterson 算法</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618212455744.png\" alt=\"image-20230618212455744\" /></p>\n<p>举旗子，贴上对方的标签，如果对方举起且门上是对方的标签，则等待，否则进入</p>\n<h4 id=\"实现临界区管理的硬件设施\"><a class=\"anchor\" href=\"#实现临界区管理的硬件设施\">#</a> 实现临界区管理的硬件设施</h4>\n<ol>\n<li>关中断</li>\n<li>测试并建立指令</li>\n<li>对换指令</li>\n</ol>\n<h4 id=\"操作系统中并发问题解决方案的知识框架\"><a class=\"anchor\" href=\"#操作系统中并发问题解决方案的知识框架\">#</a> 操作系统中并发问题解决方案的知识框架</h4>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618212639129.png\" alt=\"image-20230618212639129\" /></p>\n<h1 id=\"大题\"><a class=\"anchor\" href=\"#大题\">#</a> 大题</h1>\n<ol>\n<li>\n<p><strong>多道程序设计</strong></p>\n</li>\n<li>\n<p><strong>CPU 调度算法</strong></p>\n<p>周转时间：作业结束时间 - 作业开始时间</p>\n<p>提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短</p>\n<p>响应比：（等待时间 + 期待时间）/ 期待时间</p>\n<ol>\n<li><strong>FCFS (先来先服务) 非抢占</strong>\n<ul>\n<li>一个短进程可能不得不等待很长时间才能获得执行</li>\n<li>偏袒计算为主的进程\n<ul>\n<li>I/O 多的进程不得不等待计算为主的进程做完</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>RR (时间片轮转) 抢占</strong> Round-Robin\n<ul>\n<li>基于时钟做<strong>抢占式调度</strong></li>\n<li>以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列中，然后<strong>基于 FCFS 策略</strong>选择下一个就绪进程运行</li>\n<li>延长短进程的等待时间</li>\n</ul>\n</li>\n<li><strong>SPN (最短进程优先)</strong> Shortest process\n<ul>\n<li>非抢占，真正操作系统没有办法使用</li>\n<li>选择所需处理时间最短的进程</li>\n<li>短进程将会越过长进程，优先获得调度</li>\n</ul>\n</li>\n<li><strong>SRT (最短剩余时间优先)</strong> Shortest Remaining Time\n<ul>\n<li>抢占，真正操作系统没有办法使用</li>\n<li>调度器总是选择预期剩余时间更短的进程，当一个新进程加入就绪队列，他可能比当前运行的进程具有更短的剩余时间，只要该新进就绪，调度器就可能抢占当前正在运行的进程</li>\n</ul>\n</li>\n<li><strong>HRRF</strong> (最高响应比优先) Highest Response Ratio Next\n<ul>\n<li>非抢占，真正操作系统没有办法使用</li>\n<li><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618082746653.png\" alt=\"image-20230618082746653\" /></li>\n</ul>\n</li>\n<li><strong>Feedback</strong> (多级反馈调度) 抢占\n<ul>\n<li>建立多个不同优先级的就绪进程队列</li>\n<li>多个就绪进程队列之间按照优先数调度</li>\n<li>高优先级的就绪进程，分配的时间片短</li>\n<li>单个就绪进程队列中的进程的优先数和时间片相同，按照先来先服务算法调度</li>\n<li><strong>2<sup>i</sup><strong> 的 i 是从</strong> 0</strong> 开始的，也就是<strong>最高优先级队列的时间片为 1</strong></li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/5f16b9b43f43c1c52159e01c40a2d96e.JPG\" alt=\"5f16b9b43f43c1c52159e01c40a2d96e\" /></p>\n<p>RR, q = 4 时答案有问题，应为 ABBBBCDDDDBBBBDDDDBD</p>\n</li>\n<li>\n<p><strong>死锁避免银行家算法 ，死锁检测</strong></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/D62410102ED0B8A94EE82582185FC8A9.png\" alt=\"D62410102ED0B8A94EE82582185FC8A9\" /></p>\n<p>做题思路：</p>\n<ol>\n<li>试探性地将 <code>available</code>  的资源分配给某个进程，满足它的 <code>Claim - Allocation</code>  的需求，进程结束后，归还所拥有的 <code>Allocation</code> ，系统未分配的资源增加，可分配资源为 <code>available + allocation</code> ，循环此过程，直至所有进程都被满足</li>\n<li>否则，系统将处于不安全状态</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620192317074.png\" alt=\"image-20230620192317074\" /></p>\n</li>\n<li>\n<p>连续分配，分区分配：适配算法，伙伴系统</p>\n<ol>\n<li>\n<p>可变分区存储</p>\n<p><strong>最先适应分配算法</strong>：</p>\n<ol>\n<li>最先适应就是从上向下查找，找到第一块区域放进去，将剩下的区域分割后仍作为空闲区。</li>\n<li>有利于大作业装入，但也使得内存低地址和高地址两端的分区利用不均衡，回收分区麻烦。</li>\n</ol>\n<p><strong>邻近适应分配算法</strong>：</p>\n<ol>\n<li>从上次查找结束的地方开始执行最先适应分配算法</li>\n<li>缩短平均查找时间，且存储空间利用率更均衡，不会使得小空闲区集中在内存一侧</li>\n</ol>\n<p><strong>最优适应分配算法</strong>：</p>\n<ol>\n<li>每次都是分配最接近需要使用大小的部分，会生成很多很小的内存内零头。</li>\n<li>通常会将空闲区按照长度递增顺序排列，等同于最先适应分配算法，查找时间最长</li>\n</ol>\n<p><strong>最坏适应分配算法</strong>：</p>\n<ol>\n<li>每次都是挑选最大的一块区域进行分配</li>\n<li>有利于中小型作业。</li>\n<li>可把空闲区按长度递减顺序排列，等同于最先适应分配算法。</li>\n</ol>\n<p><strong>快速适应分配算法</strong>：课本补充</p>\n<ol>\n<li>为经常用到的长度的空闲区设立单独的空闲区链表，查找非常快速</li>\n<li>归还内存空间时和邻近空闲区的合并复杂且耗时。</li>\n</ol>\n<p>最常用的是最先适应分配算法，其次是邻近适应分配算法和最优适应分配算法</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>地址转换计算：分页管理方式；分段管理方式。</strong></p>\n<ol>\n<li>\n<p>分页管理</p>\n<p>逻辑地址 = 页号 + 页面偏移</p>\n<p>物理地址 = 页架号（页框号） + 单元号（页内偏移)</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTgxMDI1NTc2NzgucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618102557678.png</span>&quot; alt=&quot;image-20230618102557678&quot; style=&quot;zoom:25%;&quot; /&gt;</p>\n</li>\n<li>\n<p>分段管理</p>\n<p>逻辑地址 = 段号 + 段内偏移</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTgxMDI1Mjc1NjQucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618102527564.png</span>&quot; alt=&quot;image-20230618102527564&quot; style=&quot;zoom: 25%;&quot; /&gt;</p>\n</li>\n<li>\n<p>段页式管理</p>\n<p>逻辑地址 = 段号 + 页号 + 单元号</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTgxMDMwMzM2MzMucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618103033633.png</span>&quot; alt=&quot;image-20230618103033633&quot; style=&quot;zoom: 15%;&quot; /&gt;</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>页面置换算法</strong></p>\n<ol>\n<li>\n<p><strong>OPT 页面调度算法</strong>（Belady 算法）</p>\n<p>当要调入新页面时，首先淘汰以后不再访问的页，然后选择<strong>距现在最长时间后再访问</strong>的页。</p>\n</li>\n<li>\n<p><strong>先进先出页面调度算法</strong> FIFO-Belady 异常</p>\n<p>首先淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页 (常驻的除外)</p>\n</li>\n<li>\n<p><strong>最近最少用</strong> LRU-Least Recently Used</p>\n<p>淘汰<strong>最近一段时间较久未被访问</strong>的那一页，即那些刚被使用过的页面，可以马上还要被使用到。</p>\n</li>\n<li>\n<p><strong>最不常用</strong> LFU-Least Frequently Used</p>\n</li>\n<li>\n<p><strong>时钟 CLOCK</strong></p>\n<p>采用循环队列机制构造页面队列，形成了一个类似钟表面的环形表，队列指针则相当于钟表面上的表针，指向可能要淘汰的页</p>\n</li>\n</ol>\n</li>\n<li>\n<p>抖动现象，工作集（不考）</p>\n<ol>\n<li>\n<p><strong>MIN</strong></p>\n<p>进程在时刻 t 访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框</p>\n</li>\n<li>\n<p><strong>工作集</strong></p>\n<p>向前看</p>\n<p>指 &quot;在某一段时间间隔内进程运行所需访问的页面集合&quot;，W (t，Δ) 表示在时刻 t-Δ 到时刻 t 之间 ( (t-Δ，t)) 所访问的页面集合，进程在时刻 t 的工作集</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>磁盘调度算法</strong></p>\n<ol>\n<li>\n<p>先来先服务 <strong>FCFS</strong></p>\n</li>\n<li>\n<p>最短查找时间优先 (最小短距离法) <strong>SSTF</strong>，Shortest Service Time First</p>\n</li>\n<li>\n<p>扫描算法<strong> SCAN</strong></p>\n<p>向一个方向，碰壁折返</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618101122512.png\" alt=\"image-20230618101122512\" /></p>\n</li>\n<li>\n<p>电梯调度 <strong>LOOK</strong></p>\n<p>不碰壁返回</p>\n</li>\n<li>\n<p><strong>C-LOOK</strong></p>\n<p>始终沿同一方向</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618102148934.png\" alt=\"image-20230618102148934\" /></p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>文件系统的计算</strong></p>\n<ol>\n<li>\n<p><strong>位示图</strong></p>\n<p>它将文件存储器的存储空间建立一张位示图，用以反映整个盘空间的分配情况。</p>\n<p>磁盘空间通常使用<strong>固定大小</strong>的块，<strong>可方便地用位示图管理，用若干字节构成一张位示图</strong>，其中每一字位对应一个物理块，字位的次序与块的相对次序一致，字位为‘1’表示相应块已占用，字位为‘0’表示该块空闲。</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230618115411308.png\" alt=\"image-20230618115411308\" /></p>\n</li>\n<li>\n<p>空白文件目录</p>\n<p>这种方法将盘空间的一个未分配区域称为一个空白文件，系统为所有的空白文件建立一个目录，每个空白文件在这个目录中建立一个表目。</p>\n</li>\n<li>\n<p>空白块链：</p>\n<p>这种方法将盘上的所有空白块用链接指针或索引结构组织成一个空白文件。</p>\n</li>\n<li>\n<p>Linux 文件管理</p>\n<ol>\n<li>直接地址索引</li>\n<li>间接地址索引</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>PV 操作</strong></p>\n</li>\n<li>\n<p><strong>管程</strong></p>\n</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620194458915.png\" alt=\"image-20230620194458915\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620194639190.png\" alt=\"image-20230620194639190\" />、<img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620194758530.png\" alt=\"image-20230620194758530\" /></p>\n<p>分区分配：</p>\n<ol>\n<li>\n<p>静态分配：进程运行前申请</p>\n<p>实现简单，能够防止系统发生死锁，</p>\n<p>但会降低设备利用率</p>\n</li>\n<li>\n<p>动态分配：进程随用随申请</p>\n<p>提高设备利用率</p>\n</li>\n</ol>\n<h1 id=\"简答\"><a class=\"anchor\" href=\"#简答\">#</a> 简答</h1>\n<ol>\n<li>\n<p>试述系统调用的定义、实现原理，陷阱机制和绘制系统调用的处理过程，并阐述系统调用的处理逻辑</p>\n<ol>\n<li>\n<p>定义：操作系统实现的完成某种特定功能的过程，为所有运行程序提供访问操作系统的接口</p>\n</li>\n<li>\n<p>实现原理：</p>\n<ol>\n<li>编写系统调用服务例程；</li>\n<li>设计系统调用入口地址表，每个入口地址都指向一个系统调用的服务例程，有些包含系统调用自带参数的个数；</li>\n<li>开辟现场保护区，以保存发生系统调用时应用程序的处理器现场</li>\n</ol>\n</li>\n<li>\n<p>陷阱机制：操作系统实现系统调用功能的机制称为系统陷阱，由于系统调用而引起处理器中断的机器指令称为陷入指令，在用户态下执行时会由用户态转换到内核态</p>\n</li>\n<li>\n<p>处理逻辑：</p>\n<ol>\n<li>应用程序执行系统调用，产生中断转向内核态，进入陷阱处理程序；</li>\n<li>按功能号查询入口地址表，并转至对应服务例程执行；</li>\n<li>完成后退出中断，返回应用程序断点继续运行</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620232723536.png\" alt=\"image-20230620232723536\" /></p>\n</li>\n<li>\n<p>试写出进程映像包括哪些组成部分</p>\n<p>程序块、数据块、核心栈、用户栈、进程控制块</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MjAyMzQ1NTA0NTYucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620234550456.png</span>&quot; alt=&quot;image-20230620234550456&quot; style=&quot;zoom: 25%;&quot; /&gt;</p>\n</li>\n<li>\n<p>试述操作系统中三个最基础的抽象，并回答为什么要引入它们</p>\n<ol>\n<li>进程抽象：对正在运行的程序在处理器上操作的状态集的抽象</li>\n<li>虚存抽象：对内存的抽象，使用虚拟地址引用物理存储单元</li>\n<li>文件抽象：对设备的抽象，按名存取</li>\n<li>原因：防止硬件资源被应用程序滥用，屏蔽复杂的硬件资源操作细节，为应用程序提供使用硬<br />\n件资源的简单且一致的方法</li>\n</ol>\n</li>\n<li>\n<p>简述 IO 软件的四层结构</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616165104832.png\" alt=\"image-20230616165104832\" /></p>\n</li>\n<li>\n<p>简述虚存分页的原理，并画出流程图<br />\n原理：</p>\n<ol>\n<li>主存被划分成大小固定相等的块，每个进程也被分成同样大小的块；</li>\n<li>进程中称为页的块可以指定到内存中称为页框或者页框的可用块；</li>\n<li>操作系统为每个进程维护一个页表，给出该进程的每一页对应的页框的位置</li>\n</ol>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MjEwMDQxMjI5NDgucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230621004122948.png</span>&quot; alt=&quot;image-20230621004122948&quot; style=&quot;zoom:33%;&quot; /&gt;</p>\n</li>\n<li>\n<p>create 系统调用的参数，返回值是什么，实现原理是什么</p>\n<p>实现原理：</p>\n<ol>\n<li>为新文件分配索引节点和活动索引节点，并把索引节点编号与文件分量名组成新目录项，记到目录中</li>\n<li>在新文件所对应的活动索引节点中设置初值，如置存取权限 i_mode，连接计数 i_nlink 等</li>\n<li>分配打开文件表项和系统打开文件表项，并为表项分配初值</li>\n<li>通过指针建立表项与活动索引节点间的联系。</li>\n<li>把文件描述字，即用户打开文件表中对应的表项序号返回给调用者</li>\n</ol>\n</li>\n<li>\n<p>open 系统调用的参数，返回值是什么，实现原理是什么</p>\n<p>参数：文件权限，文件路径名的字符串</p>\n<p>返回值：文件描述符</p>\n<p>实现原理：</p>\n<ol>\n<li>检索目录，把它的外存索引节点复制到活动索引节点中来</li>\n<li>根据参数 mode 核对权限，如果非法，则打开失败</li>\n<li>合法时，为文件分配用户打开文件表项和系统打开文件表项，并为表项分配初值</li>\n<li>通过指针建立表项与活动索引节点间的联系。</li>\n<li>把文件描述字，即用户打开文件表中对应的表项序号返回给调用者</li>\n</ol>\n</li>\n<li>\n<p>结合进程状态转换模型，解释操作系统是如何中断驱动的</p>\n<p>运行态：进程占用处理器运行</p>\n<p>就绪态：进程具备运行条件等待处理器运行</p>\n<p>等待态：又称阻塞态、睡眠态，进程由于等待资源、输入输出、信号等而不具备运行条件</p>\n<p>当操作系统遇到中断事件时，如键盘输入、I/O 操作完成时，它会将当前正在运行的进程切换到阻塞状态，并将 CPU 分配给一个已经处于就绪状态的进程。如果没有就绪状态的进程，则操作系统会将 CPU 保留在空闲状态，等待下一个进程变为就绪状态。<br />\n当事件完成后，操作系统会将被阻塞的进程重新切换到就绪状态，以便再次执行。在这个过程中，进程状态转换图的状态如下：</p>\n<ol>\n<li>从运行状态转换到阻塞状态：当操作系统接收到中断请求时，正在运行的进程会被中断和放入<br />\n阻塞状态。</li>\n<li>从阻塞状态转换到就绪状态：当操作系统完成中断请求时，进程将被重新放回就绪状态，等待<br />\n操作系统重新分配 CPU 时间。<br />\n通过这种方式，操作系统可以实现中断驱动的机制，以处理来自外部设备的事件或请求。该机制使<br />\n得操作系统可以在不阻塞当前进程的情况下同时响应多个事件，并实现了 CPU 的高效利用。</li>\n</ol>\n</li>\n<li>\n<p>画多级反馈队列的模型图、阐述多级反馈的原理，比 RR 的优点、缺陷以及改进方法</p>\n<p>原理：</p>\n<ul>\n<li>建立多个不同优先级的就绪进程队列：</li>\n<li>多个就绪进程队列之间按照优先数调度</li>\n<li>单个就绪进程队列中的进程的优先数和时间片相同，按照先来先服务算法调度</li>\n</ul>\n<p>比 RR 的优点：优先级课调整、时间片大小可调整、适应性强、响应时间短</p>\n<p>缺陷：长时间运行的进程，可能会一直在较低的优先级队列中等待；算法复杂度高</p>\n<p>改进方法：引入抢占式调度、加强进程优先级管理、动态调整时间片大小</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230621003159068.png\" alt=\"image-20230621003159068\" /></p>\n</li>\n<li>\n<p>请画出经典的三进程状态模型及其状态转换图并解释状态之间各类转换关系的含义</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230621001913099.png\" alt=\"image-20230621001913099\" /></p>\n<p>运行态 - 等待态：等待资源、IO、信号量</p>\n<p>等待态 - 就绪态：资源满足、IO 结束、信号量完成</p>\n<p>就绪态 - 运行态：处理器空闲时选择高优先权进程抢占</p>\n<p>运行态 - 就绪态：运行时间片到，被高优先权进程抢占</p>\n</li>\n<li>\n<p>请画出经典的五进程状态模型及其状态转换图并解释状态之间各类转换关系的含义</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230621002239523.png\" alt=\"image-20230621002239523\" /></p>\n</li>\n<li>\n<p>请画出经典的七进程状态模型及其状态转换图并解释状态之间各类转换关系的含义</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230621001848022.png\" alt=\"image-20230621001848022\" /></p>\n</li>\n<li>\n<p>Spooling 的设计思想，并画出系统组织结构图</p>\n</li>\n</ol>\n<ul>\n<li>将独占设备改成共享设备的技术</li>\n<li>采用预输入、缓输出和井管理技术</li>\n<li>通过创建守护进程和特殊目录解决独占型设备的空占问题</li>\n<li>缓和 CPU 的高速性与 IO 设备低速性之间的矛盾，以空间换时间</li>\n</ul>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMzA2MTYxNTQyMDg4NzMucG5n\">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230616154208873.png</span>&quot; alt=&quot;image-20230616154208873&quot; style=&quot;zoom: 15%;&quot; /&gt;</p>\n<h1 id=\"选择题补充除慕课\"><a class=\"anchor\" href=\"#选择题补充除慕课\">#</a> 选择题补充（除慕课）</h1>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620172430646.png\" alt=\"image-20230620172430646\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620171158492.png\" alt=\"image-20230620171158492\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620171708030.png\" alt=\"image-20230620171708030\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620172734904.png\" alt=\"image-20230620172734904\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620172944360.png\" alt=\"image-20230620172944360\" /></p>\n<p>实际物理地址 = (段寄存器 &lt;&lt; 4) + 偏移地址</p>\n<p>访问到的是实地址。.</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620172958818.png\" alt=\"image-20230620172958818\" /></p>\n<p><img data-src=\"C:/Users/QUAS/Desktop/image-20230620173008103.png\" alt=\"image-20230620173008103\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620173014448.png\" alt=\"image-20230620173014448\" /></p>\n<p>GDT LDT IDT（中断描述符表）</p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620173020164.png\" alt=\"image-20230620173020164\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620173209246.png\" alt=\"image-20230620173209246\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620173216653.png\" alt=\"image-20230620173216653\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620173226806.png\" alt=\"image-20230620173226806\" /></p>\n<p><img data-src=\"https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20230620183150718.png\" alt=\"image-20230620183150718\" /></p>\n",
            "tags": [
                "NJUSE",
                "计算机操作系统",
                "计算机操作系统"
            ]
        }
    ]
}