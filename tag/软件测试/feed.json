{
    "version": "https://jsonfeed.org/version/1",
    "title": "Carpe diem",
    "subtitle": "pluck the day",
    "icon": "https://quas-modo.github.io/undergraduate/images/favicon.ico",
    "description": "notes/thoughts/nonsense",
    "home_page_url": "https://quas-modo.github.io/undergraduate",
    "items": [
        {
            "id": "https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%952023%E5%9B%9E%E5%BF%86/",
            "url": "https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%952023%E5%9B%9E%E5%BF%86/",
            "title": "软件测试2023回忆",
            "date_published": "2024-01-15T04:11:03.000Z",
            "content_html": "<p>南京大学软件学院软件测试回忆。</p>\n<p><span id=\"more\"></span></p>\n<p>by cxy nyb</p>\n<h2 id=\"选择题\"><a class=\"anchor\" href=\"#选择题\">#</a> 选择题</h2>\n<ol>\n<li>基于生成的模糊测试容易破坏输入的结构、产生无效输入；生成的大部分输入都无法通过语义检查（x，是基于变异）</li>\n<li>这是隐式预言</li>\n</ol>\n<p><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM2ZTBjYzdhZmZjYzliMjM1ZDIzYjNhNmIwM2NkZmZfRmc4N0pyRTN0S3VLYmtPMXBaYTVBSEQ0QmRRVFFVTHBfVG9rZW46TVdOSGJOcEltb2J6NlB4WEYzT2N4Tk1ZbmZnXzE3MDUyOTI2Mzk6MTcwNTI5NjIzOV9WNA\" alt=\"img\" /></p>\n<ol>\n<li>非病灶区域要扩增吗？（要的）\n<ol>\n<li><img data-src=\"https://y6gbjg9hbn.feishu.cn/space/api/box/stream/download/asynccode/?code=NjRiMzUxNmYyZjc5M2MwZTk0OTBkNjY3YWJlNmZiYmJfbllnZWQ2bWxSWDFYOWIzMFFwSkxrUXZWZUFIcVEwOUlfVG9rZW46SWp1UmJvSmFibzZBQ3J4TmpYWGNId1NvbjVlXzE3MDUyOTI2Mzk6MTcwNTI5NjIzOV9WNA\" alt=\"img\" /></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"简答题\"><a class=\"anchor\" href=\"#简答题\">#</a> 简答题</h2>\n<ol>\n<li>举一例测试用例优先级排序</li>\n<li>举例说明差分测试及其适用场景</li>\n<li>简述一种基于文字识别和图像识别的测试用例选择方法</li>\n<li>有人说：软件测试的唯一目的就是为了找缺陷，对此你的看法是？</li>\n</ol>\n<h2 id=\"应用题\"><a class=\"anchor\" href=\"#应用题\">#</a> 应用题</h2>\n<ol>\n<li>测试优先级\n<ol>\n<li>贪心算法</li>\n<li>增量贪心，并计算 APFD</li>\n</ol>\n</li>\n<li>函数：X，Y 两个字符串求最长公共字符串\n<ol>\n<li>设计蜕变测试规则</li>\n<li>根据规则写出测试用例及预期结果</li>\n</ol>\n</li>\n<li>语音识别系统，设计模糊测试（要求至少 1 个种子选择策略，3 个变异方式、2 个评估标准）</li>\n</ol>\n",
            "tags": [
                "NJUSE",
                "软件测试",
                "软件测试"
            ]
        },
        {
            "id": "https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
            "url": "https://quas-modo.github.io/undergraduate/2024/01/15/NJUSE/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
            "title": "软件测试期末复习",
            "date_published": "2024-01-15T04:09:12.000Z",
            "content_html": "<p>南京大学软件学院软件测试期末复习。</p>\n<p><span id=\"more\"></span></p>\n<p>选择题 10 题（源码、移动、ai）433</p>\n<p>问答题</p>\n<p>应用题</p>\n<ul>\n<li>\n<p>测试用例优先级</p>\n</li>\n<li>\n<p>源码测试</p>\n<ul>\n<li>随机测试（选择、问答为主，优势、特点、过程）</li>\n<li>变异测试（与 ai 结合、变异测试的理解）</li>\n<li>差分测试（基本概念）\n<ul>\n<li>通过将同一测试用例运行到一系列相似的程序来发现错误</li>\n</ul>\n</li>\n<li>蜕变测试（基本概念）</li>\n</ul>\n</li>\n<li>\n<p>测试用例优先级</p>\n<ul>\n<li>主要算法的流程及复杂度（贪婪算法、额外贪心的复杂度）</li>\n<li>APFD 计算（给公式，用 2-3 个方法，并且计算 APFD 的值）</li>\n<li>算法应用</li>\n</ul>\n</li>\n<li>\n<p>测试用例选择</p>\n<ul>\n<li>主要方法</li>\n<li>动态静态</li>\n<li>与测试用例优先级的区别和联系</li>\n</ul>\n</li>\n<li>\n<p>测试用例优先级 vs 测试用例选择</p>\n</li>\n<li>\n<p>移动应用</p>\n<ul>\n<li>基于图像理解的移动应用自动化测试\n<ul>\n<li>能够了解各个任务的难点</li>\n<li>能够论述各个任务的解决方法\n<ul>\n<li>核心思想</li>\n<li>方法步骤</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于群智协同的众包测试\n<ul>\n<li>能够了解众包的难点</li>\n<li>能够了解基本的机制</li>\n<li>能够了解解决方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>AI 测试</p>\n<ul>\n<li>AI 测试概述\n<ul>\n<li>与传统测试的区别</li>\n<li>测试的难点</li>\n</ul>\n</li>\n<li>模糊测试\n<ul>\n<li>基本流程</li>\n<li>数据生成</li>\n<li>效果反馈</li>\n<li>简单应用</li>\n</ul>\n</li>\n<li>测试二\n<ul>\n<li>图像扩增</li>\n<li>公平性</li>\n<li>后门攻击</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"源码测试\"><a class=\"anchor\" href=\"#源码测试\">#</a> 源码测试</h1>\n<h2 id=\"自动化测试\"><a class=\"anchor\" href=\"#自动化测试\">#</a> 自动化测试</h2>\n<h3 id=\"软件缺陷的触发和传播机理\"><a class=\"anchor\" href=\"#软件缺陷的触发和传播机理\">#</a> 软件缺陷的触发和传播机理</h3>\n<ul>\n<li>Software Fault: A static defect in the software (i.e., defect) 软件缺陷：软件中的静态缺陷</li>\n<li>Software Error: An incorrect <strong>internal</strong> state that is the manifestation of some fault 软件错误：不正确的内部状态，是某些故障的表现</li>\n<li>Software Failure: <strong>External</strong>, incorrect behavior with respect to the requirements or other description of the expected behavior 软件故障：相对于需求或预期行为的其他描述的外部、不正确的行为</li>\n</ul>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167496-31.png\" alt=\"img\" /><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167470-1.png\" alt=\"img\" /><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167471-2.png\" alt=\"img\" /></p>\n<p>PIE 模型理论：Execution 运行、Infection 感染、Propagation 传播</p>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167471-3.png\" alt=\"img\" /></p>\n<h3 id=\"测试的局限性\"><a class=\"anchor\" href=\"#测试的局限性\">#</a> 测试的局限性</h3>\n<p>输入空间庞大：无法穷举所有输入</p>\n<p>实现逻辑复杂：无法想到所有场景</p>\n<p>测试语言未知：无法判定测试的预期输出</p>\n<h2 id=\"随机测试\"><a class=\"anchor\" href=\"#随机测试\">#</a> <strong>随机测试</strong></h2>\n<ol>\n<li>定义：随机生成测试数据并执行测试。\n<ol>\n<li>理论基础是大数定律，即在试验不变的条件下，重复试验多次，随机事件的频率近似于它的概率，这可以让概率低的偶然现象发生。</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167471-4.png\" alt=\"img\" /></li>\n</ol>\n</li>\n<li>应用场景：\n<ol>\n<li>断言失败</li>\n<li>异常崩溃</li>\n<li>无效输入：对无效的输入过滤，便于开发者进行防御式编程</li>\n<li>错误输出</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"变异测试\"><a class=\"anchor\" href=\"#变异测试\">#</a> <strong>变异测试</strong></h2>\n<ol>\n<li>定义：是将变异体视作测试目标，利用变异分析的结果来<strong>支持、评估、引导</strong>软件测试的过程</li>\n<li>目的：找出有用的测试用例，发现程序中真正的错误；可评估测试集的错误检测能力</li>\n<li>变异分析：\n<ol>\n<li>变异体：基于一定的<strong>语法变换规则</strong>，通过对源程序进行程序变换得到的一系列变体</li>\n<li>变异得分：对测试套件错误检测能力的量化，公式：杀死的变体占所有变体的百分比</li>\n<li>变异算子：一系列语法变换规则</li>\n<li>缺陷传播模型：RIPR 和 PIE\n<ol>\n<li>RIPR：<strong>R</strong>eachability, <strong>I</strong>nfection, <strong>P</strong>ropagation Revealability</li>\n<li>PIE：<strong>E</strong>xecution，<strong>I</strong>nfection, <strong>P</strong>ropagation</li>\n<li>解释：</li>\n<li>R &amp; E：缺陷所在的位置可以被执行到</li>\n<li>I：缺陷的执行影响了程序的状态</li>\n<li>P &amp; PR：程序状态的影响传播到了输出</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>变异的分类（根据<strong>杀死条件</strong>不同）\n<ol>\n<li>Weak mutation：变异导致<strong>紧随变化位置</strong>之后的程序状态发生了改变（R&amp;E）</li>\n<li>Firm Mutation: 变异导致<strong>远离变化位置</strong>的程序状态发生了改变（I）</li>\n<li>Strong Mutation：变异导致<strong>程序的输出</strong>发生了变化（P&amp;PR）</li>\n<li>变异要求变高，变异体质量提升</li>\n</ol>\n</li>\n<li>变异体的分类\n<ol>\n<li>有效变异体：符合需求，可以产生模拟缺陷的变异体</li>\n<li>夭折变异体：变异时遵循语法规则，但产生的变异体<strong>没有通过编译</strong></li>\n<li>冗余变异体：伴随着<strong>更强的变异体</strong>被杀死\n<ol>\n<li>等价变异体：语法不同、语义相同 (<strong>针对待测程序 P 与变异体 MUT</strong>)\n<ol>\n<li>语义相同：对于相同的输入，两个程序总能给出相同的输出</li>\n</ol>\n</li>\n<li>重复变异体：语义相同 （<strong>针对待测程序 P 的两个变异体 MUT1 和 MUT2</strong>）</li>\n<li>蕴含变异体：如果杀死 M1 的用例都能杀死 M2，那么 M1 蕴含 M2（针对两个变异体 MUT1 和 MUT2）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>基础假设：\n<ol>\n<li>缺陷是简单的，可模拟的：<strong>老练程序员假设</strong></li>\n<li>缺陷可叠加：复杂变异体通过耦合简单变异体得到\n<ol>\n<li>能够杀死简单变异体的测试用例可以杀死复杂变异体</li>\n<li>不是一直正确，同时修改时可能相互覆盖</li>\n</ol>\n</li>\n<li>缺陷检测有效性：\n<ol>\n<li>测试用例最重要的属性：<strong>缺陷检测能力</strong></li>\n<li><strong>传递性假设</strong>：杀死变异体的测试用例在真实世界中也有效（所以<strong>变异得分</strong>是很有用的）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>测试<strong>过程</strong>：\n<ol>\n<li><strong>变异体筛选 - 变异体生成 - 变异体优化 - 变异体执行 - 变异得分计算</strong></li>\n<li><strong>变异体筛选</strong>：分两种方式\n<ol>\n<li>对变异体筛选（即<strong>变异体约减</strong>），约减策略有三：\n<ol>\n<li>随机选取：<strong>随机扔掉</strong>一些变异体，丢失率损失不多</li>\n<li>基于类型：<strong>某些类型</strong>变异体更重要</li>\n<li>基于分布：AST 选取更<strong>分散</strong>的变异体</li>\n</ol>\n</li>\n<li>对<strong>变异算子</strong>筛选，再生成变异体\n<ol>\n<li>好处：减少无关变异体的生成，<strong>节省开销</strong></li>\n</ol>\n</li>\n<li>变异算子概念：是一系列程序变换规则，反映了特定的缺陷类型\n<ol>\n<li>分类：对源代码、对编译结果（中间表示）、元变异</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>变异体生成</strong>：将变异体实例化，为每个变体构建一个单独的源文件。生成技术有三：\n<ol>\n<li>元变异：核心是<strong>程序模式</strong>（程序模板 + 部分编译，只编译变异后的代码）</li>\n<li>基于字节码（中间表示）：避免编译，从而减少时间开销</li>\n<li>热替换</li>\n</ol>\n</li>\n<li><strong>变异体优化</strong>：去除<strong>等价和无效</strong>变异体\n<ol>\n<li>通过<strong>静态</strong>分析，识别并移除有问题的变异体</li>\n</ol>\n</li>\n<li><strong>变异体执行</strong>\n<ol>\n<li>变异体矩阵：用于记录执行情况，方便计算变异得分用于优化（矩阵：测试用例 * 变异体）\n<ol>\n<li>调整<strong>测试用例次序</strong>（TCP），使计算变异得分<strong>所需执行次数</strong>下降</li>\n</ol>\n</li>\n<li>优化策略：\n<ol>\n<li>改变执行顺序（TCP）</li>\n<li>匹配测试用例与变异体</li>\n<li>避免执行必定存活的变异体：静态分析可检测</li>\n<li>限定变异体执行时间</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>变异得分计算</strong>：\n<ol>\n<li>变异杀死的条件：确定一个变异体是否被杀死，核心是<strong>定义程序行为</strong></li>\n<li>测试预言的生成：生成更多、更好的测试语言来杀死更多变异体</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>变异体的应用：测试生成、预言生成、测试优化、debug 引导</li>\n<li>总结：</li>\n</ol>\n<h2 id=\"差分测试\"><a class=\"anchor\" href=\"#差分测试\">#</a> 差分测试</h2>\n<p>差分测试本质：<strong>利用相似 / 竞品软件系统进行测试</strong></p>\n<p>基本思想：差分测试也称差分模糊测试，是一种常用的软件测试技术，通过向一系列类似的应用程序（或同一应用程序的不同实现）提供相同的输入，根据这些相似程序执行结果是否存在差异来判定是否检测到缺陷。</p>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167471-5.png\" alt=\"img\" /></p>\n<h2 id=\"蜕变测试\"><a class=\"anchor\" href=\"#蜕变测试\">#</a> 蜕变测试</h2>\n<p>1998 年，由 Tsong Yueh Chen 提出，是一种测试用例生成的新思路</p>\n<p>蜕变测试本质：充分利用成功测试用例；对成功测试用例表现出的<strong>必要属性</strong>的复用</p>\n<p>基本思想：蜕变测试依据被测软件的领域知识和软件的实现方法建立蜕变关系，生成新的测试用例，通过验证蜕变关系是否被保持来决定测试是否通过。</p>\n<p>蜕变关系 MR：多次执行目标程序时，输入与输出之间期望遵循的关系</p>\n<ol>\n<li>确定输入输出</li>\n<li>确定<strong>蜕变关系</strong> R</li>\n<li>构建待验证的蜕变关系 R'</li>\n<li>构建<strong>蜕变集合</strong></li>\n<li>检查执行结果是否满足 R'</li>\n</ol>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167471-6.png\" alt=\"img\" /></p>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-7.png\" alt=\"img\" /></p>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-8.png\" alt=\"img\" /></p>\n<p>蜕变测试中的四大误解</p>\n<ul>\n<li>误解一：所有的必要属性都是蜕变关系 蜕变关系是和待测算法的多个输入以及这些输入对应的期望输出相关的必要属性，即蜕变关系应当和多个输入实例相关</li>\n<li>误解二：所有的蜕变关系都能够划分成输入端和输出端的两个子关系</li>\n<li>误解三：所有的蜕变关系都是等式关系</li>\n<li>误解四：蜕变测试只能应用在测试预言缺失的场景下</li>\n</ul>\n<h2 id=\"蜕变与差分\"><a class=\"anchor\" href=\"#蜕变与差分\">#</a> <strong>蜕变与差分</strong></h2>\n<ul>\n<li><strong>相同点：</strong>\n<ul>\n<li>都利用了待测程序中的<strong>必要属性</strong>；都是<strong>黑盒</strong>测试技术</li>\n</ul>\n</li>\n<li><strong>不同点：</strong>\n<ul>\n<li><strong>必要属性的类型不同</strong>：蜕变测试利用了单一待测程序的必要属性；差分测试则利用了多个相似待测程序间的必要属性；</li>\n<li><strong>正确性验证的准则不同</strong>：蜕变测试的正确性验证准则是可变的，由蜕变关系决定；差分测试的正确性准则是固定的，即不同相似待测程序在同一测试输入上的输出结果应该相同。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"回归测试概述\"><a class=\"anchor\" href=\"#回归测试概述\">#</a> <strong>回归测试概述</strong></h2>\n<p>回归测试作为一种有效的方法，可有效保证代码修改的正确性并避免代码修改对被测程序其他模块产生的副作用。在版本迭代过程中，常用的回归测试方法往往是重新执行之前已经积累的测试用例，但是这种简单的测试用例执行的策略，也导致了一些显而易见的问题。</p>\n<p>现有用例策略：重新执行已有测试用例</p>\n<p><strong>回归测试 **** 问题：用例庞大、冗余、失效、缺失</strong></p>\n<ul>\n<li>用例庞大：由于版本迭代，测试用例数量较多，则项目实际预算不允许执行完所有测试用例。</li>\n<li>用例冗余：在迭代过程中，存在多个用例的功能相似甚至相同。</li>\n<li>用例失效：部分代码修改会影响到被测模块的原有外部接口或内在语义，并导致部分测试用例失效。</li>\n<li>用例缺失：若代码修改生成新的测试需求，则需额外设计新的测试用例。</li>\n</ul>\n<p><strong>回归测试 **** 优化：测试用例修复、选择、扩充、约减、优先级</strong></p>\n<ul>\n<li>测试用例修复：识别出因相关模块的外部接口或内在语义发生变更变为失效的用例，并对其进行修复。</li>\n<li>测试用例选择：通过分析代码修改，从已有测试用例中选择出所有可检测代码修改的测试用例，并确保未被选择的测试用例在修改前后程序上的执行行为保持一致。</li>\n<li>测试用例扩充：在代码修改影响分析基础上，对已有测试用例集的充分性进行评估，若不充分则设计新的测试用例以确保对代码修改的充分测试。</li>\n<li>测试用例约减：在满足指定测试需求覆盖前提下，识别并移除冗余测试用例来降低回归测试用例集规模。</li>\n<li>测试用例优先级：当测试预算不足以执行完所有测试用例时，可以基于特定优先级准则，对测试用例进行优先级排序以优化其执行次序，旨在最大化优先级目标。</li>\n</ul>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-9.png\" alt=\"img\" /></p>\n<h1 id=\"移动应用\"><a class=\"anchor\" href=\"#移动应用\">#</a> 移动应用</h1>\n<h2 id=\"基于图像理解的移动应用自动化测试\"><a class=\"anchor\" href=\"#基于图像理解的移动应用自动化测试\">#</a> <strong>基于图像理解的移动应用自动化测试</strong></h2>\n<ol>\n<li><strong>能够了解各个任务的难点</strong>\n<ol>\n<li>深度图像理解测试工具的局限性</li>\n</ol>\n</li>\n<li><strong>能够论述各个任务的解决方法</strong>\n<ol>\n<li><strong>核心思想、方法步骤</strong></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"gui测试挑战\"><a class=\"anchor\" href=\"#gui测试挑战\">#</a> GUI 测试挑战</h3>\n<ol>\n<li>环境碎片化</li>\n<li>快速演化的开发平台</li>\n<li>设备、平台、网络多样化</li>\n</ol>\n<h3 id=\"gui测试必要性\"><a class=\"anchor\" href=\"#gui测试必要性\">#</a> GUI 测试必要性</h3>\n<ol>\n<li>增强测试可复用性</li>\n<li>保证测试的一致性</li>\n<li>提高测试效率，减少测试开销</li>\n<li>实现快速的回归测试，加快测试进度</li>\n<li>实现更广的测试覆盖度，提高测试可靠性，避免人为因素</li>\n</ol>\n<p>真是一堆废话啊。</p>\n<h3 id=\"自动化测试框架\"><a class=\"anchor\" href=\"#自动化测试框架\">#</a> 自动化测试框架</h3>\n<ul>\n<li>Selenium： 一个开源的自动化测试工具，专门用于<strong>自动化网页浏览器</strong>的操作</li>\n<li>Appium： 一个扩展了 Selenium 的 WebDriver 协议来支持移动应用自动化的工具，允许使用 Selenium 的客户端库来编写适用于 <strong>iOS 和 Android 应用</strong>的测试脚本</li>\n</ul>\n<h4 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题</h4>\n<ul>\n<li>测试脚本的执行依赖于操作系统接口，如 Android 的 ADB</li>\n<li>定位控件所需信息依赖于移动应用的 UI 层，如 Android 的 XML 布局文件</li>\n<li>人工编写脚本的时间开销大</li>\n<li>脚本随应用迭代的可维护性不强</li>\n</ul>\n<h4 id=\"优化\"><a class=\"anchor\" href=\"#优化\">#</a> 优化</h4>\n<ul>\n<li>减少依赖，降低成本，增加可维护性</li>\n</ul>\n<h4 id=\"解决方法\"><a class=\"anchor\" href=\"#解决方法\">#</a> 解决方法</h4>\n<h5 id=\"核心思想\"><a class=\"anchor\" href=\"#核心思想\">#</a> 核心思想</h5>\n<p>自动化测试网页、移动端应用</p>\n<h5 id=\"方法步骤\"><a class=\"anchor\" href=\"#方法步骤\">#</a> 方法步骤</h5>\n<p>编写脚本（控件定位 + 执行操作）</p>\n<h3 id=\"基于图像的简单控件定位\"><a class=\"anchor\" href=\"#基于图像的简单控件定位\">#</a> 基于图像的简单控件定位</h3>\n<ul>\n<li>Sikuli：来自 MIT 的 Sikuli 通过图像匹配算法来完成对 GUI 元素的识别和定位</li>\n<li>Airtest：来自网易的 Airtest 连接到某个窗口或移动设备上，然后进行 GUI 测试脚本的编写</li>\n</ul>\n<h4 id=\"sikuli-类-sikuli-工具存在的问题\"><a class=\"anchor\" href=\"#sikuli-类-sikuli-工具存在的问题\">#</a> <strong>Sikuli （类 Sikuli 工具）存在的问题</strong></h4>\n<ul>\n<li>测试脚本的执行仍依赖于操作系统接口，如 Android 的 ADB</li>\n<li>使用像素级方式定位控件的方式难以应对复杂场景，如不同分辨率的设备</li>\n<li>仍面临人工编写和维护脚本的成本</li>\n</ul>\n<h4 id=\"优化-2\"><a class=\"anchor\" href=\"#优化-2\">#</a> 优化</h4>\n<ul>\n<li>追求对图像更深入的理解</li>\n</ul>\n<h4 id=\"解决方案\"><a class=\"anchor\" href=\"#解决方案\">#</a> 解决方案</h4>\n<h5 id=\"核心思想-2\"><a class=\"anchor\" href=\"#核心思想-2\">#</a> 核心思想</h5>\n<p>用图像匹配算法识别和定位 GUI 元素，并执行测试操作</p>\n<h5 id=\"方法步骤-2\"><a class=\"anchor\" href=\"#方法步骤-2\">#</a> 方法步骤</h5>\n<ol>\n<li>捕获屏幕图像</li>\n<li>编写脚本</li>\n<li>图像识别</li>\n<li>相似度阈值</li>\n<li>执行操作</li>\n<li>反馈和调整</li>\n</ol>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-10.png\" alt=\"img\" /></p>\n<h3 id=\"深度图像理解\"><a class=\"anchor\" href=\"#深度图像理解\">#</a> <strong>深度图像理解</strong></h3>\n<h4 id=\"过程\"><a class=\"anchor\" href=\"#过程\">#</a> 过程</h4>\n<ul>\n<li>控件匹配\n<ul>\n<li>原分辨率 - 模板匹配： 根据相似度进行筛选， 选取距离最近的作为结果</li>\n<li>跨分辨率 – 特征点匹配：分别通过阈值、面积、斜率进行筛选</li>\n</ul>\n</li>\n<li>控件提取\n<ul>\n<li>设备截图、灰度转换、边缘检测、膨胀、边缘提取、轮廓矩形</li>\n</ul>\n</li>\n<li>文字识别\n<ul>\n<li>设备截屏、加载模型、区块检测、方向检测、文字识别</li>\n</ul>\n</li>\n<li>界面理解\n<ul>\n<li>空间图像提取 UIED</li>\n<li>控件属性识别、页面布局刻画、场景语义分析</li>\n</ul>\n</li>\n<li>控件理解\n<ul>\n<li>控件类型判断、控件文本提取、控件意图识别、控件关系提取</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基于深度图像理解的录制回放工具\"><a class=\"anchor\" href=\"#基于深度图像理解的录制回放工具\">#</a> <strong>基于深度图像理解的录制回放工具</strong></h4>\n<h5 id=\"问题-2\"><a class=\"anchor\" href=\"#问题-2\">#</a> 问题</h5>\n<ul>\n<li>碎片化问题，加大测试难度</li>\n<li>动态内容，相似控件难识别</li>\n</ul>\n<h5 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h5>\n<ul>\n<li>基于图像理解技术，录制和回放跨平台的测试脚本</li>\n</ul>\n<h4 id=\"基于深度图像理解的自动化探索工具\"><a class=\"anchor\" href=\"#基于深度图像理解的自动化探索工具\">#</a> <strong>基于深度图像理解的自动化探索工具</strong></h4>\n<ul>\n<li>AI 测试探索策略</li>\n<li>基于强化学习和图像理解的跨平台测试技术</li>\n</ul>\n<h5 id=\"深度图像理解测试工具侵入式的局限性\"><a class=\"anchor\" href=\"#深度图像理解测试工具侵入式的局限性\">#</a> <strong>深度图像理解测试工具（侵入式）的局限性</strong></h5>\n<ol>\n<li>无法感知异形屏幕对 UI 控件的遮挡</li>\n<li>难以模拟真实场景下人的交互操作</li>\n<li>仍依赖操作系统接口执行测试操作</li>\n</ol>\n<p>解决方案：侵入式 -&gt; 非侵入式</p>\n<h4 id=\"非侵入的-gui-测试机械臂-ai\"><a class=\"anchor\" href=\"#非侵入的-gui-测试机械臂-ai\">#</a> <strong>非侵入的 GUI 测试</strong>：机械臂 + AI</h4>\n<ul>\n<li>外置摄像头捕获屏幕，对接实现对屏幕的视觉理解</li>\n<li>AI 算法选择目标控件并生成测试操作</li>\n<li>调度机械臂执行各种类型的测试操作</li>\n<li>模拟人为交互，摆脱底层依赖</li>\n</ul>\n<p>还有一些图像理解的过程和机械臂的原理在 ppt</p>\n<h2 id=\"基于群智协同的众包测试\"><a class=\"anchor\" href=\"#基于群智协同的众包测试\">#</a> <strong>基于群智协同的众包测试</strong></h2>\n<h3 id=\"众包的难点\"><a class=\"anchor\" href=\"#众包的难点\">#</a> <strong>众包的难点</strong></h3>\n<h4 id=\"面临的挑战今年的\"><a class=\"anchor\" href=\"#面临的挑战今年的\">#</a> 面临的挑战（今年的）</h4>\n<ol>\n<li>任务分配</li>\n<li>任务奖励</li>\n<li>众测过程引导</li>\n<li>测试报告质量控制</li>\n</ol>\n<h4 id=\"具体表现为往年的\"><a class=\"anchor\" href=\"#具体表现为往年的\">#</a> 具体表现为（往年的）</h4>\n<ol>\n<li>竞争多、协同少</li>\n<li>测试力度分布不均匀、任务完成时呈 “长尾分布”</li>\n<li>测试报告数量庞大、人工审查过于耗时</li>\n<li>大量报告重复、不完善</li>\n<li>整理整合报告困难</li>\n</ol>\n<h3 id=\"众包的优势\"><a class=\"anchor\" href=\"#众包的优势\">#</a> 众包的优势</h3>\n<ol>\n<li>向开发者提供多种不同软硬件平台支持的真实用户数据和操作信息</li>\n<li>更充分的测试时间，更广泛的测试方法，更多样的测试环境</li>\n</ol>\n<h3 id=\"基本的机制流程\"><a class=\"anchor\" href=\"#基本的机制流程\">#</a> <strong>基本的机制（流程）</strong></h3>\n<ol>\n<li>申请上传：用户将自己的应用程序上传到众测平台，并指定相应的测试任务和酬劳信息。</li>\n<li>任务选择和环境设置：众测人员自由选择想要完成的任务。选择后测试人员从平台上下载应用程序进行测试。</li>\n<li>提交报告：众测人员根据选择的待测应用，对测试到的缺陷提交缺陷报告</li>\n<li>生成最终测试报告：平台生成最终的缺陷报告，包括：一般信息、设备信息、操作路径等。</li>\n<li>报告验证：客户验证报告，并决定如何酬劳</li>\n</ol>\n<h3 id=\"解决方法-2\"><a class=\"anchor\" href=\"#解决方法-2\">#</a> <strong>解决方法</strong></h3>\n<h4 id=\"协作式众包测试\"><a class=\"anchor\" href=\"#协作式众包测试\">#</a> <strong>协作式众包测试</strong></h4>\n<p>完成测试任务过程中进行信息共享与任务分配，用户在本系统中既承担测试任务也承担审核任务，充分利用用户协作，完成目标任务。</p>\n<ol>\n<li>信息共享：用户在提交报告时进行实时相似报告推荐，避免重复报告。</li>\n<li>任务分配：审核页面推荐待审核的报告列表，测试页面推荐待测页面</li>\n<li>协作方式：可以点赞点踩，利用用户的<strong>交叉审核</strong>，验证报告有效性。</li>\n<li>一键 Fork：Fork 他人结果后进行修改，利用多人协作提升报告质量</li>\n</ol>\n<h4 id=\"众测报告聚合\"><a class=\"anchor\" href=\"#众测报告聚合\">#</a> <strong>众测报告聚合</strong></h4>\n<p>目的：解决报告重复、报告无法搜索的问题。</p>\n<ul>\n<li>Aggregator：对所有的测试报告做聚类，将相同的或相似的测试报告聚为同类。</li>\n<li>Summarizer：对每一类测试报告做整合，将其中的相关信息以可视化的方式最大化的呈现给开发者。</li>\n</ul>\n<p>Aggregator 过程：</p>\n<ol>\n<li>距离矩阵计算\n<ol>\n<li>截屏集合的距离矩阵 DS distance of screen</li>\n<li>文本集合的距离矩阵 DT distance of text</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-11.png\" alt=\"img\" /></li>\n</ol>\n</li>\n<li>距离矩阵的合并\n<ol>\n<li>文本相同，0</li>\n<li>截屏相同，加权</li>\n<li>都不同，调和平均</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-12.png\" alt=\"img\" /></li>\n</ol>\n</li>\n<li>合成层次聚类\n<ol>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167472-13.png\" alt=\"img\" /></li>\n</ol>\n</li>\n</ol>\n<p>Summarize 过程：</p>\n<ol>\n<li>识别主报告 - pagerank 算法</li>\n<li>生成补充信息 - 识别提纯，补充信息、同源信息</li>\n<li>生成总结</li>\n</ol>\n<h4 id=\"众测报告排序\"><a class=\"anchor\" href=\"#众测报告排序\">#</a> <strong>众测报告排序</strong></h4>\n<p>众测报告的优势：向开发者提供多种不同软硬件平台支持的真实用户数据和操作信息</p>\n<p>众测报告质量管控问题：测试报告数量庞大、人工审查过于耗时</p>\n<p>普通测试报告的排序：文本描述或程序代码的执行树</p>\n<p>针对移动应用测试报告的排序：将截图和文本纳入考虑。</p>\n<ul>\n<li>使用文本 + 图片结合分析的方法</li>\n</ul>\n<p>报告排序原则：尽可能地发现有缺陷的报告，提高报告的审查效率</p>\n<ul>\n<li>通过自然语言处理算法计算文本的相似度\n<ul>\n<li>关键词、文本距离</li>\n<li>Jaccard 距离计算</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-14.png\" alt=\"img\" /></li>\n</ul>\n</li>\n<li>通过 SPM 算法（Spatial Pyramid Matching）识别缺陷截图相似度\n<ul>\n<li>特征直方图</li>\n<li>截图之间的距离\n<ul>\n<li>设置阈值 y，筛选内容相同图片</li>\n</ul>\n</li>\n<li>截图集合之间的距离\n<ul>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-15.png\" alt=\"img\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>通过使用一种多目标的优化算法结合文本与截图相似度完成针对测试报告的相似度比较\n<ul>\n<li>计算距离，公式同聚合</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-16.png\" alt=\"img\" /></p>\n<h4 id=\"深度众测报告排序\"><a class=\"anchor\" href=\"#深度众测报告排序\">#</a> 深度众测报告排序</h4>\n<p>解决主要分析文本、截图为辅、文本截图简单拼接的问题（传统众测报告排序的问题）。</p>\n<p>过程：特征提取 -&gt; 特征聚合 -&gt; 相似度计算 -&gt; 报告排序</p>\n<ul>\n<li>图片特征提取：CV 技术提取控件 - 问题控件、上下文控件</li>\n<li>文本特征提取：NLP 技术处理文本 - 缺陷描述、复现步骤</li>\n<li>将所有特征聚合为两种特征类型：\n<ul>\n<li>Bug Feature（BFT）：与缺陷直接相关，包括问题控件和缺陷描述</li>\n<li>Context Feature（CFT）：为缺陷构建上下文，包括上下文控件和复现步骤</li>\n</ul>\n</li>\n<li>相似度计算 deepsimilarity</li>\n<li>报告排序：\n<ul>\n<li>分为两个报告池：未排序报告池、已排序报告池</li>\n<li>初始化：所有报告 -&gt; 未排序报告池；Null Report-&gt; 已排序报告</li>\n<li>从未排序报告池中，找出一份和已排序报告池中最不相似的报告加入已排序报告池，循环调用</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-17.png\" alt=\"img\" /></p>\n<h4 id=\"众测报告半监督聚类\"><a class=\"anchor\" href=\"#众测报告半监督聚类\">#</a> <strong>众测报告半监督聚类</strong></h4>\n<p>存在问题：</p>\n<p>传统聚类方式的缺陷与不足</p>\n<ul>\n<li>未利用报告语义信息</li>\n<li>忽略图像文本关联</li>\n</ul>\n<p>过程：</p>\n<ol>\n<li>特征提取（应用截图 + 文本描述）</li>\n<li>特征距离计算</li>\n<li>利用图文语义绑定</li>\n<li>距离从小到大，将 index 与各类簇进行适配</li>\n</ol>\n<h4 id=\"众测报告一致性检测-文本和截图的一致性\"><a class=\"anchor\" href=\"#众测报告一致性检测-文本和截图的一致性\">#</a> <strong>众测报告一致性检测 （文本和截图的一致性）</strong></h4>\n<p>存在问题：</p>\n<ul>\n<li>众测工人能力与专业性参差不齐，众测报告质量参差不齐</li>\n<li>众测报告质量的底线：截图与文本的一致性</li>\n</ul>\n<p>解决方案：</p>\n<p>二阶段方法 - 先分类后检测</p>\n<ul>\n<li>一阶段：根据错误特征将基于文本描述的报告分类为不同类别</li>\n<li>二阶段：深入分析应用截图的 GUI 图像特征，然后应用不同的策略来处理不同类型的 Bug，以检测众包测试报告的一致性</li>\n</ul>\n<h1 id=\"ai测试\"><a class=\"anchor\" href=\"#ai测试\">#</a> AI 测试</h1>\n<h2 id=\"与传统测试的区别\"><a class=\"anchor\" href=\"#与传统测试的区别\">#</a> <strong>与传统测试的区别</strong></h2>\n<ol>\n<li>决策逻辑上：\n<ol>\n<li>传统软件的决策逻辑：程序代码控制</li>\n<li>智能软件的决策逻辑：使用深度学习模型的结构；训练后得到的权重节点</li>\n</ol>\n</li>\n<li>程序特征上：\n<ol>\n<li>传统软件：控制流和数据流构建的业务处理</li>\n<li>智能软件：数据驱动构建的参数化数值计算；</li>\n</ol>\n</li>\n<li>缺陷特征：\n<ol>\n<li>传统软件系统：给定输入，比较输出，若不相符，存在缺陷</li>\n<li>智能软件系统：往往不是显式的代码或参数错误</li>\n</ol>\n</li>\n<li>智能软件测试有领域性，而传统测试没有</li>\n</ol>\n<h2 id=\"ai测试的难点\"><a class=\"anchor\" href=\"#ai测试的难点\">#</a> AI 测试的难点</h2>\n<ol>\n<li>数据量不够</li>\n<li>低质量数据\n<ol>\n<li>脱离现实数据</li>\n<li>脱离目标数据</li>\n</ol>\n</li>\n<li>数据分布不均</li>\n<li>不充分测试（指面对恶意供给和随机数据）</li>\n</ol>\n<h2 id=\"图像扩增\"><a class=\"anchor\" href=\"#图像扩增\">#</a> <strong>图像扩增</strong></h2>\n<ol>\n<li>数据扩增：通过轻微变换现有数据或创建新的合成图像来得到新数据的技术。应用领域有图像扩增、文本扩增、雷达扩增……</li>\n<li>数据扩增的原因：</li>\n<li>领域数据紧缺</li>\n<li>数据标注困难</li>\n<li>数据分布挑战</li>\n<li>隐藏信息干扰：要考虑隐含条件 (人口基数等)</li>\n<li><strong>扩增方式</strong>：（这里特指 PPT 给的变异方式）</li>\n</ol>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-18.png\" alt=\"img\" /></p>\n<ol>\n<li>brightness 亮度</li>\n<li>contrast 对比度</li>\n<li>pixel noise 加噪</li>\n<li>blurring 模糊</li>\n<li>translation</li>\n<li>scaling 缩放</li>\n<li>horizontal shearing 错切</li>\n<li>rotation 旋转</li>\n</ol>\n<h2 id=\"公平性\"><a class=\"anchor\" href=\"#公平性\">#</a> <strong>公平性</strong></h2>\n<ol>\n<li>定义：鲁棒性边界因为数据集歧视（隐含条件的缺失）变得不公平</li>\n<li>修正：用各类方法修正数据，如改变字段（使用 01 表示性别字段）/ 人种（使用 PS 实现风格迁移）</li>\n</ol>\n<h2 id=\"后门攻击\"><a class=\"anchor\" href=\"#后门攻击\">#</a> <strong>后门攻击</strong></h2>\n<ol>\n<li>定义：根据潜在的失效点设计训练集，故意加入错误或误导性的信息，产生错误输出（训练集投毒）</li>\n<li>如何注入：</li>\n<li>数据投毒：训练集投毒，为一些图片添加触发器并更改标签</li>\n<li>训练神经网络，观察能否发现后门</li>\n</ol>\n<h1 id=\"大题\"><a class=\"anchor\" href=\"#大题\">#</a> 大题</h1>\n<h2 id=\"测试用例优先级tcptest-case-prioritization\"><a class=\"anchor\" href=\"#测试用例优先级tcptest-case-prioritization\">#</a> 测试用例优先级<strong> TCP（Test Case Prioritization）</strong></h2>\n<h3 id=\"主要算法流程和复杂度\"><a class=\"anchor\" href=\"#主要算法流程和复杂度\">#</a> 主要算法流程和复杂度</h3>\n<h4 id=\"基于贪心的tcptest-case-prioritization\"><a class=\"anchor\" href=\"#基于贪心的tcptest-case-prioritization\">#</a> <strong>基于贪心的 TCP（Test Case Prioritization）</strong></h4>\n<ul>\n<li>定义：通过设定特定优先级准则（执行时间，代码覆盖等），对测试用例进行优先级排序以优化其执行次序，旨在最大化优先级目标，例如最大化测试用例集的早期缺陷检测速率。</li>\n<li>全局贪心策略\n<ul>\n<li>每轮优先挑选<strong>覆盖最多代码单元</strong>的测试用例。</li>\n<li>多个用例相同<strong>随机</strong>选择。</li>\n</ul>\n</li>\n<li>增量贪心策略\n<ul>\n<li>每轮优先挑选覆盖最多，且<strong>未被已选择用例</strong>覆盖代码单元的测试用例。</li>\n<li>所有代码单元均已被覆盖则重置排序过程</li>\n<li>多个用例相同随机选择</li>\n</ul>\n</li>\n<li>特殊点：所有语句均被覆盖时要重置数组（但此时测过的不用再测）\n<ul>\n<li>假设有 n 个测试用例以及 m 个代码单元</li>\n<li>共需排序 n 轮，每轮选择一个测试用例</li>\n</ul>\n</li>\n<li>时间复杂度\n<ul>\n<li>假设有 n 个测试用例以及 m 个代码单元，共需排序 n 轮，每轮选择一个测试用例，第 k 轮时，存在 n-k+1 个待排序用例，每个用例需与 m 个代码单元计算情况，那么时间复杂度为<strong> O（n^2*m）</strong></li>\n</ul>\n</li>\n<li>改进 1：计算各个单元错误检测概率 + 计算各个用例加权覆盖评估值</li>\n<li>改进 2：因为覆盖了不一定安全 -&gt; 优先选择让覆盖少的语句执行的测试用例\n<ul>\n<li>前两轮用增量贪心选 t1/t2，得覆盖数组 cc</li>\n<li>后面假设选择 ti，比较<strong>产生的有序覆盖数组</strong>，选字典排序最大的（从左往右比）</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-19.png\" alt=\"img\" /></li>\n</ul>\n</li>\n<li>改进 3：给重要语句加权重</li>\n</ul>\n<h4 id=\"基于相似性的tcp策略\"><a class=\"anchor\" href=\"#基于相似性的tcp策略\">#</a> 基于相似性的 TCP 策略</h4>\n<ul>\n<li>因为故障通常聚在一起，所以让测试用例更均匀分布\n<ul>\n<li>如何计算测试用例之间的距离和测试集之间的距离？自适应随机策略！</li>\n<li>自适应随机策略\n<ul>\n<li>基本定义：每轮优先与已选择测试用例集差异性最大的测试用例。让测试用例均匀地分布在输入域中。</li>\n<li>执行步骤：\n<ul>\n<li>测试用例之间的距离计算\n<ol>\n<li><strong>Minimum</strong></li>\n<li><strong>Average</strong></li>\n<li><strong>Maximum</strong></li>\n</ol>\n</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-20.png\" alt=\"img\" /></li>\n</ul>\n</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-21.png\" alt=\"img\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基于搜索的tcp策略\"><a class=\"anchor\" href=\"#基于搜索的tcp策略\">#</a> 基于搜索的 TCP 策略</h4>\n<ul>\n<li>基本定义：探索用例优先级排序组合的状态空间，以此找到检测错误更快的用例序列</li>\n<li>执行步骤：\n<ul>\n<li><strong>初始种群构造</strong>：生成 N 个测试用例序列，解的编码形式为优先级排序的测试用例编号位置。如初始时对 6 个测试用例构造 2 个个体</li>\n<li><strong>交叉操作</strong>：使用单点交叉的方式。随机生成切割垫，互相交换两个用例序列切割点后部分的片段，仅交换相同测试用例的部分。</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-22.png\" alt=\"img\" /></li>\n<li><strong>变异操作</strong>：对种群中的个体进行基因值的改变操作。以一定概率选择测试用例，并随机生成两个测试用例位置，进行互换，产生新的测试用例序列。如示例对个体 1 进行变异算子生成新的个体。</li>\n<li><strong>适应度评估</strong>：以语句覆盖为例，给定程序包含 m 个语句 M={s1,s2,...,sm} 和 n 个测试用例 T={t1,t2,...,tn},T' 为某一次搜索中 T 的一个优先级序列，TSi 为该测试用例序列 T' 中第一个覆盖语句 si 的测试用例下标，那么其适应度计算为：</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-23.png\" alt=\"img\" /></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基于机器学习的tcp策略\"><a class=\"anchor\" href=\"#基于机器学习的tcp策略\">#</a> 基于机器学习的 TCP 策略</h4>\n<ol>\n<li>基本定义：对测试用例特征进行学习，根据预测的缺陷检测概率进行优先级排序</li>\n<li>排序步骤：</li>\n<li>特征提取：设计并提取测试程序中源码特征\n<ol>\n<li>存在特征：是否存在的特征（如表达式、变量特征）</li>\n<li>使用特征：被使用的特征（如获取变量地址的次数）</li>\n</ol>\n</li>\n<li>缺陷模型生成：建立模型预测测试程序检测缺陷的概率\n<ol>\n<li>提供标签，是否故障</li>\n<li>使用信息增益比筛选无用特征</li>\n<li>使用 minmax 正则化特征</li>\n<li>使用 SMO 算法训练模型，预测每个测试程序检测到缺陷的概率</li>\n</ol>\n</li>\n<li>开销模型生成：建立模型预测测试程序的运行时间\n<ol>\n<li>标签，运行时间</li>\n<li>使用信息增益比筛选无用特征</li>\n<li>使用 minmax 正则化特征</li>\n<li>使用高斯过程训练模型，预测每个测试程序运行的时间</li>\n</ol>\n</li>\n<li>测试优先级：基于单位时间内检测缺陷能力进行优先级排序</li>\n</ol>\n<h3 id=\"apfd计算\"><a class=\"anchor\" href=\"#apfd计算\">#</a> APFD 计算</h3>\n<h4 id=\"apfd\"><a class=\"anchor\" href=\"#apfd\">#</a> APFD</h4>\n<ol>\n<li>指标：平均故障检测百分比（Average Percentage of Faults Detected, APFD）</li>\n<li>说明：当给定测试用例的执行次序时，该评测指标可以给出测试用例执行过程中检测到缺陷的平均累计比例</li>\n<li>特点：其取值范围介于 0~100% 之间，取值越高，则缺陷检测速度越快</li>\n</ol>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167473-24.png\" alt=\"img\" /></p>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167474-25.png\" alt=\"img\" /></p>\n<h4 id=\"apfdc\"><a class=\"anchor\" href=\"#apfdc\">#</a> APFDc</h4>\n<ol>\n<li>开销感知平均故障检测百分比（cost-cognizant average percentage of aults detected APFDc）\n<ol>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167474-26.png\" alt=\"img\" /></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"napfd\"><a class=\"anchor\" href=\"#napfd\">#</a> NAPFD</h4>\n<ol>\n<li>归一化平均故障检测百分比（Normalized Average Percentage of Faults Detected, NAPFD）</li>\n<li>特点：考虑了实际优先级排序场景中\n<ol>\n<li>测试用例集不能检测到所有缺陷</li>\n<li>由于资源限制，无法执行所有测试用例</li>\n<li><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167474-27.png\" alt=\"img\" /></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"算法应用\"><a class=\"anchor\" href=\"#算法应用\">#</a> 算法应用</h3>\n<h2 id=\"测试用例选择tcs-test-case-selection\"><a class=\"anchor\" href=\"#测试用例选择tcs-test-case-selection\">#</a> 测试用例选择 TCS Test Case Selection</h2>\n<ol>\n<li>定义：旨在从已有测试用例集中选择出所有<strong>可检测代码修改</strong>的测试用例。（即选择<strong>执行到变更部分</strong>的用例）</li>\n<li>适用场景：适用于因测试预算不足以致<strong>不能执行完</strong>所有测试用例的测试场景。</li>\n</ol>\n<h3 id=\"基于程序分析的测试用例选择\"><a class=\"anchor\" href=\"#基于程序分析的测试用例选择\">#</a> <strong>基于程序分析的测试用例选择</strong></h3>\n<p><strong>简介</strong></p>\n<ol>\n<li>根据技术的基本定义以及程序分析技术的特点，该技术一般被认为是一种<strong>安全测试用例选择技术</strong></li>\n<li>通过程序分析技术计算出测试代码（方法、用例或套件）与生产代码之间的<strong>依赖关系</strong>，并在代码发生变更时，利用这些依赖关系将所有受到变更影响的测试代码自动选取出来，组成回归测试集。</li>\n<li>测试依赖：测试代码运行到某些生产代码而产生的联系</li>\n</ol>\n<h4 id=\"依赖分析\"><a class=\"anchor\" href=\"#依赖分析\">#</a> <strong>依赖分析</strong></h4>\n<p>看不同测试用例的函数依赖</p>\n<h4 id=\"方法\"><a class=\"anchor\" href=\"#方法\">#</a> 方法</h4>\n<h5 id=\"最小化测试用例选择\"><a class=\"anchor\" href=\"#最小化测试用例选择\">#</a> 最小化测试用例选择</h5>\n<ul>\n<li>选出最小的子集 Tmin，Tmin 能够覆盖被测程序 P 中所有本次修改的、或者受本次修改影响的部分</li>\n<li>每⼀条新增的或者被修改的语句都能够被至少⼀个来自原测试套件 T 的测试用例执行</li>\n</ul>\n<h5 id=\"安全测试用例选择技术\"><a class=\"anchor\" href=\"#安全测试用例选择技术\">#</a> 安全测试用例选择技术</h5>\n<ul>\n<li>目标：选出源测试套件 T 中能够暴露修改后被测程序 P' 中的一个或多个缺陷的所有测试用例，构成安全回归测试集 Ts</li>\n<li>要求：Ts 中的每个测试都能够满足以下条件之一：执行至少⼀条在 P' 中被删除的语句；执行至少⼀条在 P‘中新增的语句</li>\n</ul>\n<h5 id=\"基于数据流和覆盖的测试用例选择\"><a class=\"anchor\" href=\"#基于数据流和覆盖的测试用例选择\">#</a> 基于数据流和覆盖的测试用例选择</h5>\n<ul>\n<li>变更后的代码 P' 中使数据交互变化的语句构成语句集合 Si，选出所有覆盖到 Si 中某条语句的测试用例，组成测试集 Td</li>\n<li>Td 中的每个测试都能够满足以下条件之一：执行至少⼀个在 P’中被删除的 Define-Use 对；执行至少⼀个在 P‘中新增的 Define-Use 对</li>\n</ul>\n<h5 id=\"特质随机测试用例选择\"><a class=\"anchor\" href=\"#特质随机测试用例选择\">#</a> 特质 / 随机测试用例选择</h5>\n<ul>\n<li>随机测试用例选择：随机选出 m 个测试用例</li>\n<li>面向剖面测试用例选择：选出与某个剖面有关的测试用例</li>\n</ul>\n<h4 id=\"动态静态\"><a class=\"anchor\" href=\"#动态静态\">#</a> <strong>动态静态</strong></h4>\n<h5 id=\"静态程序分析\"><a class=\"anchor\" href=\"#静态程序分析\">#</a> <strong>静态程序分析</strong></h5>\n<ul>\n<li>定义：指在<strong>没有实际执行程序</strong>的情况下对计算机软件程序进行自动化分析的技术。</li>\n<li>分析材料：源代码（大多数情况），目标语言代码（少部分，如 java 字节码）</li>\n</ul>\n<h5 id=\"动态程序分析\"><a class=\"anchor\" href=\"#动态程序分析\">#</a> <strong>动态程序分析</strong></h5>\n<ul>\n<li>定义：通过在<strong>真实或虚拟处理器上执行程序</strong>来完成对程序行为的分析。</li>\n<li>限制：使用<strong>足够的测试输入</strong>来执行目标程序，以覆盖程序所有输出</li>\n<li>注意：进行动态分析时一般需要注意最小化插桩对目标程序的影响。</li>\n</ul>\n<h5 id=\"动态-vs-静态\"><a class=\"anchor\" href=\"#动态-vs-静态\">#</a> <strong>动态 V.S. 静态</strong></h5>\n<p>总体上，动态测试选择 &gt; 静态测试选择</p>\n<ul>\n<li>动态分析更容易获得更丰富 (运行时信息) 程序依赖信息，测试选择更精准、安全；静态分析开销更大，且存在过拟合现象；</li>\n<li>静态分析在运行测试阶段表现更好：静态分析不需要对代码进行插桩，在执行代码前就能获得测试选择所需要的测试依赖；</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>特征</strong></th>\n<th><strong>动态</strong></th>\n<th><strong>静态</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>总体</td>\n<td>好</td>\n<td></td>\n</tr>\n<tr>\n<td>（运行时）程序依赖信息</td>\n<td>更丰富</td>\n<td></td>\n</tr>\n<tr>\n<td>开销</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>过拟合</td>\n<td>不存在</td>\n<td>存在</td>\n</tr>\n<tr>\n<td>插桩</td>\n<td>需要</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>运行测试阶段</td>\n<td></td>\n<td>表现更好</td>\n</tr>\n<tr>\n<td>优点</td>\n<td><strong>测试用例选择更加精准、安全</strong></td>\n<td><strong>在执行代码前就能够获得测试用例选择所需的测试依赖</strong></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"粒度\"><a class=\"anchor\" href=\"#粒度\">#</a> <strong>粒度</strong></h4>\n<p>按照选取粒度的不同，基于程序分析的测试选择技术可划分为【基本块级、方法块级】、【文件级和模块级】。</p>\n<h5 id=\"细粒度\"><a class=\"anchor\" href=\"#细粒度\">#</a> <strong>细粒度</strong></h5>\n<ul>\n<li>基本块（Basic Block，BB）级：利用 BB 级变更和 BB 级测试依赖进行测试选取</li>\n<li>方法级：利用方法级变更和方法级测试依赖进行测试选取</li>\n</ul>\n<h5 id=\"粗粒度\"><a class=\"anchor\" href=\"#粗粒度\">#</a> <strong>粗粒度</strong></h5>\n<ul>\n<li>文件（类）级：利用文件级变更和文件级测试依赖进行测试选取。由于 Java 语言会将每一类编译成一个.class 文件，因此针对 Java 语言的文件级测试用例选择等同于类级别测试用例选择</li>\n<li>项目（模块）级：利用项目级变更和项目间依赖进行测试选取</li>\n</ul>\n<p>目前<strong>类级</strong>最好使用</p>\n<p>研究表明优势细粒度的程序分析会因为过于 “精准” 而漏选某些能够暴露缺陷的测试</p>\n<h4 id=\"流程\"><a class=\"anchor\" href=\"#流程\">#</a> <strong>流程</strong></h4>\n<ol>\n<li>A Phase – 分析阶段：分析代码变更、计算测试依赖</li>\n<li>E Phase – 执行阶段：运行选中测试</li>\n<li>C Phase – 收集阶段：收集测试信息。按照产生的时间点不同，信息可以分成两类：运行时信息（动态测试依赖、覆盖信息）和测试运行结果（测试运行结果、测试运行时间）</li>\n<li>三阶段（Offline Mode）：A -&gt; E -&gt; C，<strong>执行测试和收集信息分开进行</strong>。测试需要运行两遍，但是能够更早得到测试反馈</li>\n<li>两阶段（Online Mode）：A -&gt; EC，在执行测试的<strong>同时</strong>收集信息。延长了测试执行时间，但总时间更短</li>\n</ol>\n<h4 id=\"类防火墙算法\"><a class=\"anchor\" href=\"#类防火墙算法\">#</a> <strong>类防火墙算法</strong></h4>\n<ol>\n<li>使用对象关系图（Object Relation Graph）来描述测试类和生产类之间关系的算法。对象关系图描绘了面向对象程序中存在的继承、聚合以及关联关系。</li>\n<li>A 继承 B（<strong>A 是 B 的子类</strong>），则 B 改动，A 也要重新测试。</li>\n<li>A 聚合 B（<strong>A 是 B 的聚合类</strong>），则 B 改动，A 也要重新测试。</li>\n<li><strong>A 访问 B 的数据成员</strong> 或者 <strong>A 要向 B 传递信息</strong>，则 B 改动，A 也要重新测试。此外，A 和 B 要重新集成。</li>\n</ol>\n<h4 id=\"测试用例优先级vs测试用例选择\"><a class=\"anchor\" href=\"#测试用例优先级vs测试用例选择\">#</a> <strong>测试用例优先级 vs. 测试用例选择</strong></h4>\n<ol>\n<li>优先级技术是对测试用例集进行<strong>排序</strong>，以最快的速度找到缺陷，提高测试用例集的故障检测率</li>\n<li>选择技术是取测试用例集的<strong>子集</strong>，能覆盖修改过的代码，降低回归测试的开销并最大化缺陷探测能力</li>\n</ol>\n<h2 id=\"模糊测试\"><a class=\"anchor\" href=\"#模糊测试\">#</a> 模糊测试</h2>\n<p>定义：通过向目标程序提供非预期的输入并监视异常结果来发现软件漏洞的方法</p>\n<h3 id=\"基本流程\"><a class=\"anchor\" href=\"#基本流程\">#</a> 基本流程</h3>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167474-28.png\" alt=\"img\" /></p>\n<p>** 基本流程 ：** 选择种子 —— 数据生成 —— 执行测试 —— 结果分析 —— 结果反馈</p>\n<h3 id=\"数据生成\"><a class=\"anchor\" href=\"#数据生成\">#</a> 数据生成</h3>\n<ul>\n<li>种子集准备 **：** 初始种子 -&gt; 预处理 -&gt; 种子打包形成语料集 -&gt; 语料集筛选规则</li>\n<li>过程引导\n<ul>\n<li>种子采样：根据模糊测试变异方法从送入过程引导的语料集中形成符合变异方法输入的种子元组。</li>\n<li>能量分配：旨在通过对语料集进行变异成功率检测实现在同样的测试计算资源尽可能生成多的能够成功变异的测试数据。</li>\n<li>数据变异：根据所选用的变异方法，对选取的原始测试数据施加扰动，生成新的测试输入。</li>\n<li>健康测试：根据所测试的程序制定了一定的规则用来检测模糊测试变异的测试数据是否有效。</li>\n</ul>\n</li>\n<li>文本数据生成\n<ul>\n<li>基于生成：根据文本生成规则和模板</li>\n<li>基于变异：根据变异规则扩增\n<ul>\n<li>加噪：在原数据的基础上通过替换词、删除词等方式创造和原数据相类似的新数据。</li>\n<li>回译：将原有数据翻译为其他语言再翻译回原语言，由于语言逻辑顺序等的不同，回译的方法也往往能够得到和原数据差别较大的新数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>图像数据生成\n<ul>\n<li>基于生成：定义生成的规则或模板，如图像大小、像素范围、通道数</li>\n<li>基于变异：维持语义的前提下进行图像变换，如（水平 | 垂直）翻转、旋转、缩放（放大 | 缩小）、裁剪、平移、高斯噪声</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"效果反馈\"><a class=\"anchor\" href=\"#效果反馈\">#</a> 效果反馈</h3>\n<ul>\n<li>结果比对：结果参照物对比、是否产生运行崩溃</li>\n<li>结果分析：覆盖率分析、传统反馈</li>\n<li>模糊测试检测内容：无效输入、断言失败、错误输出、异常崩溃</li>\n<li>优先级排序：模糊测试一般以测试覆盖率划分语料集优先级\n<ul>\n<li>提高测试覆盖率 - 新的种子</li>\n<li>更易变异、被选取次数较少 - 更高的优先级</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"简单应用\"><a class=\"anchor\" href=\"#简单应用\">#</a> 简单应用</h3>\n<ol>\n<li>AI 模糊测试</li>\n<li>机器翻译、自动驾驶、医疗影像</li>\n</ol>\n<h3 id=\"怎么答题\"><a class=\"anchor\" href=\"#怎么答题\">#</a> 怎么答题</h3>\n<p>参考课上的例子</p>\n<ol>\n<li>定义输入输出</li>\n<li>种子调度\n<ol>\n<li>种子优先级排序</li>\n<li>能量分配</li>\n</ol>\n</li>\n<li>测试生成\n<ol>\n<li>基于生成、基于变异</li>\n</ol>\n</li>\n<li>执行测试</li>\n<li>输出分析\n<ol>\n<li>结果对比</li>\n<li>结果分析</li>\n<li>模糊测试检测内容</li>\n<li>优先级排序</li>\n</ol>\n</li>\n<li>结果反馈</li>\n</ol>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167474-29.png\" alt=\"img\" /></p>\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n<p><img data-src=\"C:/codedocuments/gh/hexo/source/_posts/NJUSE/assets/1729048167474-30.png\" alt=\"img\" /></p>\n",
            "tags": [
                "NJUSE",
                "软件测试",
                "软件测试"
            ]
        }
    ]
}