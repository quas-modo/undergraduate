<!-- build time:Mon Jan 15 2024 12:13:22 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Carpe diem" href="https://quas-modo.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Carpe diem" href="https://quas-modo.github.io/atom.xml"><link rel="alternate" type="application/json" title="Carpe diem" href="https://quas-modo.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="cpp"><link rel="canonical" href="https://quas-modo.github.io/2022/11/02/NJUSE/cpp/Lecture10-OOP/"><title>Lecture10-OOP - cpp - NJUSE | quas-modo = Carpe diem = pluck the day</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Lecture10-OOP</h1><div class="meta"><span class="item" title="创建时间：2022-11-02 20:40:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-02T20:40:09+08:00">2022-11-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">quas-modo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (5).jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-chinese-shadow-puppetry.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (3).jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/krenz-cushart-10.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/krenz-cushart-steampunk-color5-final.jpg"></li><li class="item" data-background-image="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/wenjun-lin-asset (4).jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/NJUSE/" itemprop="item" rel="index" title="分类于 NJUSE"><span itemprop="name">NJUSE</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/NJUSE/cpp/" itemprop="item" rel="index" title="分类于 cpp"><span itemprop="name">cpp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://quas-modo.github.io/2022/11/02/NJUSE/cpp/Lecture10-OOP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="quas-modo"><meta itemprop="description" content="pluck the day, notes/thoughts/nonsense"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Carpe diem"></span><div class="body md" itemprop="articleBody"><p>OOP 相关<br><span id="more"></span></p><h1 id="lecture10-oop"><a class="anchor" href="#lecture10-oop">#</a> Lecture10-OOP</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zcHJpY29kZXIuZ2l0aHViLmlvLzIwMjAvMDcvMDEvMjAyMC1DLXBsdXMtcGx1cy1hZHZhbmNlZC1wcm9ncmFtbWluZy9DKystT09QLzIwMjAtQy1wbHVzLXBsdXMtYWR2YW5jZWQtcHJvZ3JhbW1pbmctQysrJTIwJUU3JUIxJUJCJUU3JTlBJTg0JUU1JUIwJTgxJUU4JUEzJTg1LyM2LSVFNyVCMSVCQiVFNyU5QSU4NCVFNyVBNyVCQiVFNSU4QSVBOCVFNiU5RSU4NCVFOSU4MCVBMCVFNSU4NyVCRCVFNiU5NSVCMA==">https://spricoder.github.io/2020/07/01/2020-C-plus-plus-advanced-programming/C++-OOP/2020-C-plus-plus-advanced-programming-C++ 类的封装 /#6 - 类的移动构造函数</span></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101190551858.png" alt="image-20221101190551858"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221029222347755.png" alt="image-20221029222347755"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101190605135.png" alt="image-20221101190605135"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101190615624.png" alt="image-20221101190615624"></p><ol><li>encapsulation<ol><li>减少类之间的耦合</li><li>类内部的结构可以自由的进行修改</li><li>对成员进行控制</li><li>对代码的理解性更好</li></ol></li><li>information hidding：不需要知道如何初始化，只需要使用提供的接口</li><li>Cfront 第一个 C++ 的编译器，转为 C</li></ol><ul><li>基于对象：没有继承</li><li>面向对象：封装、继承、多态</li></ul><h2 id="类"><a class="anchor" href="#类">#</a> 类</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101140737002.png" alt="image-20221101140737002"></p><p>类中包含成员变量、成员函数</p><p>头文件、源文件：C++ 是一个个编译单元进行编译，所以需要提前知道其他编译单元的相关信息（存储在头文件中），只需要知道声明，不需要知道具体定义，减少编译复杂度</p><ol><li>如果直接将函数定义直接放在头文件里，会建议 compiler 将其作为 inline 函数进行编译。</li><li>如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。</li><li>随便使用内联函数可能是的代码很烂:get 和 set 函数我们选择使用 inline 方式</li><li>代码长度不超过 10 行，不包含 for、switch 等语句。</li></ol><h2 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101140754215.png" alt="image-20221101140754215"></p><h4 id="构造函数-2"><a class="anchor" href="#构造函数-2">#</a> 构造函数</h4><ul><li><p>当类中未提供构造函数的时候，编译系统会提供默认构造函数。</p></li><li><p>程序员无论提供有参数的还是无参数的构造函数，编译系统都不再提供，防止干扰程序员本身的意思。</p></li><li><p>成员变量如果是成员对象，则总是会初始化的，需要为成员对象设置构造函数</p></li></ul><h4 id="变量的初始化"><a class="anchor" href="#变量的初始化">#</a> 变量的初始化</h4><ul><li>全局变量和静态变量，未初始化，默认为 0</li><li>局部变量、成员变量，未初始化，默认为不确定的值</li><li>如果没有指定 c++ 默认初始化，则各种变量都会有不确定的值</li><li>编译系统提供的默认构造函数不会对成员变量进行处理，主要功能是<strong>完成对象的初始化，创建标识符，开辟内存空间</strong>，最后再根据传入的参数或者默认值进行对数据的处理。</li><li>构造函数可定义为 <code>private</code> ，避免在其他代码中创建该对象，所以<strong>只能通过类内部的方法进行创建</strong>，而类内部的方法是我自己写的，因此<strong>可以接管对象的创建</strong>，例如保证单例，或者保证只有十个对象创建</li></ul><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141207824.png" alt="image-20221101141207824"></p><p>按照参数列表来对应构造函数</p><h2 id="成员初始化表构造函数初始化成员变量的一种方法"><a class="anchor" href="#成员初始化表构造函数初始化成员变量的一种方法">#</a> 成员初始化表（构造函数初始化成员变量的一种方法）</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjEvYXJ0aWNsZS9kZXRhaWxzLzg1MDM2MDI1">https://blog.csdn.net/u010853261/article/details/85036025</span></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141220879.png" alt="image-20221101141220879"></p><h4 id="c构造函数的初始化列表定义"><a class="anchor" href="#c构造函数的初始化列表定义">#</a> C++ 构造函数的初始化列表定义</h4><p>C++ 的构造函数与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表<strong>以冒号开头，后跟一系列以逗号分隔的初始化字段</strong>。</p><p>比如下面的例子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Foo</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    string name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> id <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Foo</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> <span class="token comment">// 初始化列表</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol><li>构造函数的补充<ol><li>构造函数：先开辟空间并赋默认值</li><li>成员初始化表：开辟空间的时候就赋值</li></ol></li><li>执行：(常量和引用的声明和定义要放在一起，只能通过这个方法来完成)<ol><li><strong>先于构造函数执行</strong></li><li><strong>按类数据成员声明次序</strong>：下面的例子中先 x 再 y 再 z</li></ol></li><li><code>static const</code> : 常量数字，这个是可以在类内部进行初始化 ( <code>static const a = 1;</code> )</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 非静态成员可以初始化</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span><span class="token operator">&amp;</span> z<span class="token punctuation">;</span><span class="token comment">// 引用</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 签名的冒号后面，用变量 (值) 来进行初始化，这就是初始化表</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">z</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 赋值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="4"><li>减轻 Compiler 负担:</li></ol><ul><li>正常构造函数中赋值 <code>x = 100</code> ：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计 2 次</li><li>成员初始化表的时候，<strong>只进行了赋值一次</strong>。</li></ul><ol start="5"><li><strong>初始化顺序问题</strong>：先执行 p，再执行 size 有问题，按照字面序进行。</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CString</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">CString</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101191054488.png" alt="image-20221101191054488"></p><p>必须放在成员初始化表中：</p><ul><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的 class type，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ul><h2 id="析构函数"><a class="anchor" href="#析构函数">#</a> 析构函数</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141330420.png" alt="image-20221101141330420"></p><p><strong>程序员负责资源的申请和释放</strong></p><p>类的析构函数，它是类的一个成员函数，名字由波浪号加类名构成，是执行与构造函数相反的操作：释放对象使用的资源，并销毁非 static 成员。</p><p>同样的，我们来看看析构函数的几个特点：</p><ol><li>函数名是在类名前加上～，无参数且无返回值。</li><li>一个类只能有且有一个析构函数，如果没有显式的定义，系统会生成一个缺省的析构函数（合成析构函数）。</li><li>析构函数不能重载。<strong>每有一次构造函数的调用就会有一次析构函数的调用。</strong></li></ol><p><strong>声明为 private</strong></p><ol><li><p>系统无法调用析构函数，因为是自动消亡的，内存分配在栈中，<strong>离开作用域就会自动消亡</strong></p></li><li><p><strong>通过将对象的析构函数定义为</strong> <code>**private**</code> <strong>，强制在堆上分配内存</strong>，场景：栈的内存有限，对象的内存很大</p></li><li><p>better solution：这种方法也能够将 <code>p</code> 指针重新定义为空指针，更好</p></li></ol><p><strong>GC 垃圾回收</strong></p><ol><li>存在效率障碍，发生时间不确定</li><li>存在不能使用 GC 的场合</li><li>只能回收内存，不能回收文件操作的句柄等 <code>finalize</code></li><li>不能由程序员自己控制</li></ol><p>**RAII Resource Acquisition Is Initialization **</p><ol><li>什么时候获取什么时候释放都是确定的</li><li>对象获得的资源都是要在析构函数中释放的</li><li>栈上的内存资源自动释放，堆上的内存资源需要通过析构函数释放</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101191747419.png" alt="image-20221101191747419"></p><h2 id="拷贝构造函数-copy-constructor一种特殊的构造函数"><a class="anchor" href="#拷贝构造函数-copy-constructor一种特殊的构造函数">#</a> 拷贝构造函数 copy constructor—— 一种特殊的构造函数</h2><p>拷贝构造函数是来复制对象用的。一个对象，多个副本，副本之间是独立的关系。</p><p>将地址传递和值传递统一起来，归根结底还是传递的是 &quot;值&quot;(地址也是值，只不过通过它可以找到另一个值)！</p><ol><li>相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。</li><li>默认拷贝构造函数<ol><li><strong>逐个成员初始化</strong> (member-wise initialization)</li><li><strong>对于对象成员，该定义是递归的</strong></li></ol></li><li>什么时候需要拷贝构造函数:<ol><li>赋值拷贝构造</li><li>传参进行拷贝</li><li>返回值进行拷贝</li></ol></li><li>拷贝构造函数私有：目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递 (对象比较大)</li></ol><h3 id="拷贝函数的使用情况以及定义"><a class="anchor" href="#拷贝函数的使用情况以及定义">#</a> 拷贝函数的使用情况以及定义</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101192544506.png" alt="image-20221101192544506"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 赋值拷贝构造</span></pre></td></tr><tr><td data-num="2"></td><td><pre>A a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>A b<span class="token operator">=</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 传参进行拷贝</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>A b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 返回值进行拷贝</span></pre></td></tr><tr><td data-num="9"></td><td><pre>A <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    A a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 拷贝构造函数</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">//const 避免出现修改</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 一定要写引用，不然就递归调用了</span></pre></td></tr></table></figure><p>为什么对象是一个<strong>引用类型</strong>，而不是<strong>值传递</strong>？</p><p>不然会出现<strong>循环拷贝</strong>问题：如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝，也就是防止递归引用。</p><h3 id="拷贝构造函数的深浅拷贝"><a class="anchor" href="#拷贝构造函数的深浅拷贝">#</a> 拷贝构造函数的深 / 浅拷贝</h3><h4 id="默认拷贝构造函数"><a class="anchor" href="#默认拷贝构造函数">#</a> 默认拷贝构造函数</h4><p>“默认拷贝构造函数”，这个构造函数很简单，仅仅使用 “老对象” 的数据成员的值对 “新对象” 的数据成员一一进行赋值，它一般具有以下形式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Rect</span><span class="token double-colon punctuation">::</span><span class="token function">Rect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rect<span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	width <span class="token operator">=</span> r<span class="token punctuation">.</span>width<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	height <span class="token operator">=</span> r<span class="token punctuation">.</span>height<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>默认拷贝构造函数会在处理静态数据成员和指针数据成员的时候出现错误。</p><h4 id="深拷贝浅拷贝"><a class="anchor" href="#深拷贝浅拷贝">#</a> 深拷贝 / 浅拷贝</h4><p>深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，<strong>资源重新分配</strong>，这个过程就是<strong>深拷贝</strong>，反之，<strong>没有重新分配资源，就是浅拷贝。</strong></p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMjExMDExOTI1NTU3NDAucG5n">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101192555740.png</span>&quot; alt=&quot;image-20221101192555740&quot; style=&quot;zoom:200%;&quot; /&gt;</p><ol><li>原来 S1 和 S2 两个指针都指向 &quot;abcd&quot;, 但是随着 S1 的归还，S2 就变成了一个空指针了。</li><li>此时我们通过深拷贝完成拷贝</li><li>没有深拷贝需求的时候，使用编译器默认构造函数即可</li></ol><h3 id="拷贝构造函数的初始化问题"><a class="anchor" href="#拷贝构造函数的初始化问题">#</a> 拷贝构造函数的初始化问题</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141650806.png" alt="image-20221101141650806"></p><p>“接管编译器行为”</p><ol><li><p>包含成员对象的类</p><ol><li>默认拷贝构造函数：调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li><li>自定义拷贝构造函数：调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li></ol></li><li><p>拷贝函数的拷贝过程没有处理静态数据成员</p></li><li><p>默认拷贝构造函数:</p><ol><li><p>逐个成员初始化</p></li><li><p>对于对象成员，该定义是递归的</p></li></ol></li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM5MzcwNTExL2FydGljbGUvZGV0YWlscy85MTk4MTAzMw==">https://blog.csdn.net/sinat_39370511/article/details/91981033</span></p><h2 id="移动构造函数-move-constructor"><a class="anchor" href="#移动构造函数-move-constructor">#</a> 移动构造函数 move constructor</h2><p>官方文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL21vdmVfY29uc3RydWN0b3I=">https://en.cppreference.com/w/cpp/language/move_constructor</span></p><p>一些参考：</p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjU0MTIyNjI=">https://zhuanlan.zhihu.com/p/365412262</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1Mzk0MDQzL2FydGljbGUvZGV0YWlscy83ODcyODUwNA==">https://blog.csdn.net/sinat_25394043/article/details/78728504</span></p><p>所谓移动语义（Move 语义），指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以<strong>将其包含的指针成员指向的内存资源直接移给新对象所有</strong>，无需再新拷贝一份，这大大提高了初始化的执行效率。（看上去，原来的成员没有访问资源的权限了？</p><p>从一个对象拷贝到了另一个对象。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141853347.png" alt="image-20221101141853347"></p><ol><li><p><strong>左值和右值</strong></p><p>左值：赋值操作符左边的值。是可以赋值的，通常是一个变量</p><p>右值：赋值操作符右边的值。是一个值，通常是一个常数、表达式、函数调用</p><p>能出现在赋值号左边的表达式称为 “左值”，不能出现在赋值号左边的表达式称为 “右值”。一般来说，左值是可以取地址的，右值则不可以。</p><p>非 const 的变量都是左值。函数调用的返回值若不是引用，则该函数调用就是右值。一般的 “引用” 都是引用变量的，而变量是左值，因此它们都是 “左值引用”。</p><p>C++11 新增了一种引用，可以引用右值，因而称为 “右值引用”。无名的临时变量不能出现在赋值号左边，因而是右值。右值引用就可以引用无名的临时变量。</p></li><li><p>Const 只能被绑定到右值上</p><ol><li>不可以写成 <code>int &amp;x = 5</code></li><li>为什么不可以对非 const 引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。</li></ol></li><li><p>移动构造函数：直接将对应的右值移动过来 (我们已经将 vector 和 String 进行了是此岸)</p></li><li><p><strong>&amp;&amp; 是右值引用</strong>，不会被左值调用。</p></li><li><p>五删原则：拷贝构造、拷贝赋值、析构函数、移动构造、移动复制</p><ol><li>提供上面的 5 个函数之一，则需要自己提供默认函数</li></ol></li></ol><h2 id="临时变量与普通变量"><a class="anchor" href="#临时变量与普通变量">#</a> 临时变量与普通变量</h2><p>临时变量为右值，优先匹配移动构造函数【临时变量不能绑定到左值，改变临时变量的值不合理】；普通变量为左值，优先匹配拷贝构造函数。</p><p>const A ( &amp; A);</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5OTgzNS9hcnRpY2xlL2RldGFpbHMvMTA1NzgwNjI3">https://blog.csdn.net/weixin_45799835/article/details/105780627</span></p><h2 id="动态对象"><a class="anchor" href="#动态对象">#</a> 动态对象</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101143939590.png" alt="image-20221101143939590"></p><p>在<strong>堆</strong>上创建</p><p>引入 new 和 delete 操作符，除了可以分配内存，还可以调用构造函数，消除对象时，能归还内存，还可以调用析构函数。</p><p>malloc 不调用构造函数</p><p>new 可重载</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101144552660.png" alt="image-20221101144552660"></p><p>new 可以重载：开辟内存（new 的第一步）可以重载，调用构造函数初始化和返回地址赋值（new 的二三步）不能重载。</p><p>delete [] 告诉编译器，此指针带了一个头，存储了别的信息，有偏移量。</p><h3 id="创建对象"><a class="anchor" href="#创建对象">#</a> 创建对象</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101144604251.png" alt="image-20221101144604251"></p><ol><li><p>new（new 的时候一般带指针）</p><ol><li>使用原始类型</li><li>使用类类型</li></ol></li><li><p>Syntax 语法</p><ol><li>原始类型: <code>type* ptrName = new type;</code></li><li>使用类类型: <code>type* ptrName = new type(params);</code></li></ol></li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101145458897.png" alt="image-20221101145458897"></p><ol start="3"><li>注意：这是没有变量名字的物体【堆上的对象，只有通过指针去访问对象】；指针的大小都是一样的，无论数据有多大。</li></ol><h3 id="对象删除"><a class="anchor" href="#对象删除">#</a> 对象删除</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150246371.png" alt="image-20221101150246371"></p><ol><li><p>delete：</p><ol><li>唤起指向物体的指针</li><li>处理原始类型或类类型</li></ol></li><li><p>语法: <code>delete ptrName;</code></p></li><li><p>注意: <strong>删除之后，要将指针置为空指针</strong>，这样子之后可以继续使用，避免意外的引用对象，如果指针没有修改的话，可能是一个悬挂指针 (有可能出现段错误等等)</p><p>dangling pointer 悬垂指针</p><p>double free 两次删除</p><p>如果 delete 后指向 null，没有任何作用，可以防止很多的内存安全问题。这样写可以提高程序的鲁棒性。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">delete</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 如果没有办法确定 p 的类型，那么只会释放内存，但是不会调用析构函数</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 对于 cpp 这种编译语言来说，类型的声明是非常重要的</span></pre></td></tr></table></figure></li></ol><h3 id="动态对象数组"><a class="anchor" href="#动态对象数组">#</a> 动态对象数组</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150739939.png" alt="image-20221101150739939"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>A <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//p = new A;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 以上两种写法返回的都是 A 的指针</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">delete</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//[] 不能够省略，省略之后不知道指向的是一个 A，还是一个数组</span></pre></td></tr></table></figure><p>在指针前存储 4 个字节，存储了数据类型，如果没有 []，就不会去访问 4 个字节。那么后面的对象都没有调用析构函数，没有内存释放，造成内存泄漏。</p><p>同时，会出现段错误。段错误是指访问的内存超出了系统给这个程序所设定的内存空间，例如访问了不存在的内存地址、访问了系统保护的内存地址、访问了只读的内存地址等等情况。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">delete</span> p<span class="token punctuation">;</span></pre></td></tr></table></figure><p>以上这段代码没有问题，对于内置的类型 int，不需要存储 4 个字节，也不需要调用析构函数。p 是一块完整的内存。</p><p>但是，为了简单起见，<strong>new []</strong> 与 <strong>delete[]</strong> 搭配使用。</p><p><strong>注意</strong></p><p>在堆上分配的内存默认不进行初始化</p><ol><li><code>int *p1 = new int[5];</code> 默认不进行初始化</li><li><code>int *p2 = new int[5]();</code> 进行默认初始化</li><li><code>int *p2 = new int[5]&#123;0,1,2,3,4&#125;</code> : 进行显式对应函数初始化</li></ol><p><strong>隐式初始化 / 显式初始化</strong></p><p>显式初始化即为手工给予初值，否则为隐式初始化，将内容设置为默认值。</p><p>自动变量在运行时进入函数的时候，才进行分配空间赋值。非自动变量会自隐式清零，而自动变量是不会自隐式清零的。若没有在定义变量时显式初始化，未赋值前，该变量的内容是不确定值。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> F1<span class="token punctuation">;</span> <span class="token comment">// 初始化为 0 </span></pre></td></tr><tr><td data-num="2"></td><td><pre>string F2<span class="token punctuation">;</span> <span class="token comment">// 初始化为 null</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> F3 <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为 25 </span></pre></td></tr><tr><td data-num="6"></td><td><pre>string F4 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为 “abcd”</span></pre></td></tr></table></figure><h3 id="动态2d数组"><a class="anchor" href="#动态2d数组">#</a> 动态 2D 数组</h3><h4 id="创建"><a class="anchor" href="#创建">#</a> 创建</h4><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101152237726.png" alt="image-20221101152237726"></p><h4 id="删除"><a class="anchor" href="#删除">#</a> 删除</h4><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101152523993.png" alt="image-20221101152523993"></p><p>先 delete char*，再 delete char**</p><p>先 delete 三个粉红块块，再 delete 一个粉红块块</p><p>多维数组很少用现在这种方式做，都是用一维数组模拟多维数组。</p><h2 id="const成员"><a class="anchor" href="#const成员">#</a> Const 成员</h2><p>const 是程序中最稳定的部分。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101153137329.png" alt="image-20221101153137329"></p><ol><li>初始化放在构造函数的成员初始化表中进行：<ol><li>常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内</li><li>所以我们通过<strong>初始化表</strong>的方式完成。</li></ol></li><li><strong>不同的对象，可以有不同的 const 成员变量的值</strong>。对象一旦有了，在对象的生命周期内不变。不同的对象可以有不一样的值。A (1); A (2);</li><li><strong>所有的对象共享一个</strong> static const: 编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。</li></ol><p>静态成员变量一般在类外进行定义。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101153818760.png" alt="image-20221101153818760"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如何判断不是 const？</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">// 前后要保证一致，const 在后面，在不改变成员变量的函数后面增加 const。</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 编译器怎么能发现不是 const 的？转化为防止变量被赋值，见下面，所以 const 指针不能修改</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>A <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 上面的函数相当于这个</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span>x <span class="token operator">&lt;&lt;</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">//const 改变参数声明</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 上面的函数相当于这个，第一个 const 表示指向对象常量，后一个 const 表示指针本身是常量</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">const</span> A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 声明了一个常对象 a: 这个对象是不可以修改的</span></pre></td></tr><tr><td data-num="25"></td><td><pre>a<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误，常对象无法调用非常方法</span></pre></td></tr><tr><td data-num="26"></td><td><pre>a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正确</span></pre></td></tr></table></figure><p>我们将不修改对象内变量的值的时候，将对应方法声明为 const，如 <code>const A a(0,0);</code></p><p>const 成员函数，在声明编译的函数后面，增加关键字 const。 <code>void show(); const</code></p><p>当对象声明为 const 的时候，只能调用 const 成员函数；类似于对象声明为 static 时，只能调用 static 函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>A <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 指针不可变</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//this 指针所指向的内存的内容不可变</span></pre></td></tr></table></figure><p>const 有 <code>就近原则</code> ，const 靠近 this，this 不可变，const 靠近 A，A 的内容不可变</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">&amp;</span> indirect_int<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">indirect_int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">delete</span> <span class="token operator">&amp;</span>indirect_int<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 只要不是直接修改变量的值就 OK</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 引用本身是不能修改的，所以编译器认为没问题</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            indirect_int<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 只是指向的内容发生了变化</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>int &amp; —— 变量的引用：</p><ol><li>这里的 &amp; 不是取地址符号，而是引用符号，引用是 C++ 对 C 的一个重要补充。</li><li>声明引用时必须指定它代表的是哪一个变量，即对它初始化。</li><li>引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储单元；</li><li>对引用的初始化，可以是一个变量名，也可以是另一个引用。</li><li>引用初始化后不能再被重新声明为另一变量的别名</li></ol><p>对象外的内存与类没有什么关系。indirect_int 可以 ++。</p><p>如何解决用 a 做 indirect_int 初始化，并且改变 indirect_int 的引用对象的值：</p><ol><li>关键词 mutable: 表示成员可以在 <code>const</code> 中进行修改，而不是用间接的方式来做。给程序员一些自由度，语言设计逻辑自洽即可。</li><li>去掉 const 转换: <code>(const_cast)&lt;A*&gt;(this)-&gt;x</code> 转换后可以修改原来的成员。利用原有的语法实现 mutable，非常优雅。</li></ol><h2 id="静态成员"><a class="anchor" href="#静态成员">#</a> 静态成员</h2><p>类刻画了一组具有相同属性的对象。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108150231596.png" alt="image-20221108150231596"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108150545400.png" alt="image-20221108150545400"></p><p>静态成员变量放在类外的.cpp 文件中定义，只能定义一次。</p><p>const static 是个例外，是个符号，不在全局数据区，在声明的时候初始化，不在初始化表种初始化。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108151154641.png" alt="image-20221108151154641"></p><ol><li>f 只能存取静态成员变量，调用静态成员函数。</li><li>类访问控制（public\private\static...）：在类上直接访问只能是静态成员变量</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108151245618.png" alt="image-20221108151245618"></p><p>A::f (); 类似于 std::cout;</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108151737798.png" alt="image-20221108151737798"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108151757514.png" alt="image-20221108151757514"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单例模式</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span>  <span class="token class-name">singleton</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span><span class="token comment">// 构造函数外部不可以使用，可以控制类的对象的个数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		<span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> singleton <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token keyword">static</span> singleton <span class="token operator">*</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 每次访问的时候判断是否为 null，在这个名空间下，可以调用 new 创建对象</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">return</span>  m_instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">?</span> m_instance <span class="token operator">=</span> <span class="token keyword">new</span> singleton<span class="token operator">:</span> m_instance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span> <span class="token keyword">delete</span> m_instance<span class="token punctuation">;</span> m_instance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token keyword">static</span> singleton <span class="token operator">*</span>m_instance<span class="token punctuation">;</span><span class="token comment">// 保存对象的指针也是 static 的，指针指向本身</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>singleton <span class="token operator">*</span>singleton<span class="token double-colon punctuation">::</span>m_instance<span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">// 初始化</span></pre></td></tr></table></figure><h2 id="友元"><a class="anchor" href="#友元">#</a> 友元</h2><h3 id="简介"><a class="anchor" href="#简介">#</a> 简介</h3><ol><li>类外部不能访问该类的 private 成员<ol><li>通过该类的 public 方法</li><li>会降低对 private 成员的访问效率，缺乏灵活性：如果使用 public 方法使用这些成员则是实行调用函数，降低调用效率，消耗时间</li><li>例：矩阵类 (Matrix)、向量类 (Vector) 和全局函数 (multiply)，全局函数实现矩阵和向量相乘</li><li>隐藏细节、保持一致性</li></ol></li><li>友元是<strong>数据保护和访问效率</strong>的折衷方案</li><li>友元可以访问 private 和 protected 的成员</li></ol><h3 id="matrix-vector"><a class="anchor" href="#matrix-vector">#</a> matrix vector</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//Matrix</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Matrix</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>p_data<span class="token punctuation">;</span><span class="token comment">// 逻辑二维，一维存储</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> lin<span class="token punctuation">,</span>col<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            lin <span class="token operator">=</span> l<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            col <span class="token operator">=</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            p_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>lin<span class="token operator">*</span>col<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token operator">~</span><span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>p_data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>p_data<span class="token operator">+</span>i<span class="token operator">*</span>col<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 指针类型的偏移是根据指针指向对象的类型</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">dimension</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>l<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            l <span class="token operator">=</span> lin<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            c <span class="token operator">=</span> col<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span>p_data<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>lin<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    p<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">//Vector</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>p_data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">int</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            num <span class="token operator">=</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            p_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token operator">~</span><span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>p_data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> p_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">dimension</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token punctuation">&#123;</span> n <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span>p_data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span>p<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token comment">// 实现 矩阵和一个向量进行计算，效率比较</span></pre></td></tr><tr><td data-num="56"></td><td><pre><span class="token keyword">void</span> <span class="token function">multiply</span><span class="token punctuation">(</span>Matrix <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> Vector <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> Vector <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token keyword">int</span> lin<span class="token punctuation">,</span> col<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    m<span class="token punctuation">.</span><span class="token function">dimension</span><span class="token punctuation">(</span>lin<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>lin<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        r<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="62"></td><td><pre>            r<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+=</span> m<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token operator">*</span>v<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里的调用效率会比较低</span></pre></td></tr><tr><td data-num="63"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="65"></td><td><pre></pre></td></tr><tr><td data-num="66"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>    Matrix <span class="token function">m</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    Vector <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>    Vector <span class="token function">r</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>    <span class="token function">multiply</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>v<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>    m<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    v<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>    r<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="74"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108154057903.png" alt="image-20221108154057903"></p><p>没有 classC，可以声明友元吗？不可以，因为需要知道内存空间【先声明后使用】</p><p>没有 classB，可以声明友元吗？可以</p><p>第一种情况:friend class B:</p><ol><li>编译器会寻找有没有类 B</li><li>如果没有则会引入一个 B</li></ol><p>第二种情况:friend B</p><ol><li>省略关键字的时候不会引入 B，如果没有 B 会报错模板类</li><li>但是这种形式常用于模板类 (T 或者 typedef 的时候来写)</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108154417929.png" alt="image-20221108154417929"></p><p>需要前向声明：在 class Matrix 前声明 <code>class Vector</code></p><p>友元不具有传递性:</p><ol><li><p>不能说 A 是 B 的友元，B 是 C 的友元就可以得出 A 是 C 的友元</p></li><li><p>友元必须显式声明</p></li></ol><h3 id="相互引用的两个类"><a class="anchor" href="#相互引用的两个类">#</a> 相互引用的两个类</h3><p>如果两个类相互引用可能是出现了一些结构上的问题。一起用和只用一个类，拆开来没什么意思。</p><p>完整的定义必须在声明之后，必然有一个类缺少完整的声明。</p><p>复用和维护的考虑。（继承……，有派生和继承相互引用就有意义）</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221108155019945.png" alt="image-20221108155019945"></p><p>如果每一个数据都可以 get 和 set，并没有做好封装，相当于每一个 private 都是 public 的。所以要设置好类型的</p><h4 id="迪米特法则lod"><a class="anchor" href="#迪米特法则lod">#</a> 迪米特法则 LoD</h4><ul><li>Each unit should have only limited knowledge about other units: only units &quot;closely&quot; related to the current unit.</li><li>Each unit should only talk to its friends; don't talk to strangers.</li><li>Only talk to your immediate friends.</li></ul><p>迪米特法则 (Law of Demeter) 又叫做最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解。不和陌生人说话。英文简写为: LoD。</p><p>迪米特法则的目的在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系 —— 这在一定程度上增加了系统的复杂度。</p><div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i> cpp</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-02-08 17:46:43" itemprop="dateModified" datetime="2023-02-08T17:46:43+08:00">2023-02-08</time> </span><span id="2022/11/02/NJUSE/cpp/Lecture10-OOP/" class="item leancloud_visitors" data-flag-title="Lecture10-OOP" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="quas-modo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="quas-modo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="quas-modo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>quas-modo <i class="ic i-at"><em>@</em></i>Carpe diem</li><li class="link"><strong>本文链接：</strong> <a href="https://quas-modo.github.io/2022/11/02/NJUSE/cpp/Lecture10-OOP/" title="Lecture10-OOP">https://quas-modo.github.io/2022/11/02/NJUSE/cpp/Lecture10-OOP/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/01/NJUSE/cpp/Lecture09-%E6%8C%87%E9%92%88/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;quasdo.oss-cn-hangzhou.aliyuncs.com&#x2F;img&#x2F;wenjun-lin-asset (2).jpg" title="Lecture09-指针"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> cpp</span><h3>Lecture09-指针</h3></a></div><div class="item right"><a href="/2022/11/03/NJUSE/COA/Lecture08-cache/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;quasdo.oss-cn-hangzhou.aliyuncs.com&#x2F;img&#x2F;wenjun-lin-asset (3).jpg" title="Lecture08-cache"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机组成与结构</span><h3>Lecture08-cache</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lecture10-oop"><span class="toc-number">1.</span> <span class="toc-text">Lecture10-OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">变量的初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">成员初始化表（构造函数初始化成员变量的一种方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">C++ 构造函数的初始化列表定义</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-copy-constructor%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">拷贝构造函数 copy constructor—— 一种特殊的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">拷贝函数的使用情况以及定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.2.</span> <span class="toc-text">拷贝构造函数的深 &#x2F; 浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">默认拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">深拷贝 &#x2F; 浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">拷贝构造函数的初始化问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-move-constructor"><span class="toc-number">1.6.</span> <span class="toc-text">移动构造函数 move constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%B8%8E%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">临时变量与普通变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.</span> <span class="toc-text">动态对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4"><span class="toc-number">1.8.2.</span> <span class="toc-text">对象删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.3.</span> <span class="toc-text">动态对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%812d%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.4.</span> <span class="toc-text">动态 2D 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E6%88%90%E5%91%98"><span class="toc-number">1.9.</span> <span class="toc-text">Const 成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.10.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">1.11.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.11.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#matrix-vector"><span class="toc-number">1.11.2.</span> <span class="toc-text">matrix vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BB"><span class="toc-number">1.11.3.</span> <span class="toc-text">相互引用的两个类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99lod"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">迪米特法则 LoD</span></a></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/09/15/NJUSE/cpp/Lecture03-%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="bookmark" title="Lecture03-结构化程序设计">Lecture03-结构化程序设计</a></li><li><a href="/2022/09/21/NJUSE/cpp/Lecture04-%E7%AC%AC%E4%B8%80%E6%AC%A1cpp%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Lecture04-第一次cpp编程">Lecture04-第一次cpp编程</a></li><li><a href="/2022/09/22/NJUSE/cpp/105-STL/" rel="bookmark" title="105 STL">105 STL</a></li><li><a href="/2022/09/29/NJUSE/cpp/Lecture06-%E5%87%BD%E6%95%B0/" rel="bookmark" title="Lecture06-函数">Lecture06-函数</a></li><li><a href="/2022/10/04/NJUSE/cpp/Lecture07-%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/" rel="bookmark" title="Lecture07-程序组织">Lecture07-程序组织</a></li><li><a href="/2022/10/18/NJUSE/cpp/Lecture08-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/" rel="bookmark" title="Lecture08-数组和指针">Lecture08-数组和指针</a></li><li><a href="/2022/11/01/NJUSE/cpp/Lecture09-%E6%8C%87%E9%92%88/" rel="bookmark" title="Lecture09-指针">Lecture09-指针</a></li><li class="active"><a href="/2022/11/02/NJUSE/cpp/Lecture10-OOP/" rel="bookmark" title="Lecture10-OOP">Lecture10-OOP</a></li><li><a href="/2022/11/21/NJUSE/cpp/Homework4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="Homework4-内存管理">Homework4-内存管理</a></li><li><a href="/2023/02/08/NJUSE/cpp/Lecture11-%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0/" rel="bookmark" title="Lecture11-继承、虚函数">Lecture11-继承、虚函数</a></li><li><a href="/2023/02/08/NJUSE/cpp/Lecture12-%E5%A4%9A%E6%80%81/" rel="bookmark" title="Lecture12-多态">Lecture12-多态</a></li><li><a href="/2023/02/08/NJUSE/cpp/Lecture13-newdelete/" rel="bookmark" title="Lecture13-newdelete">Lecture13-newdelete</a></li><li><a href="/2023/02/08/NJUSE/cpp/Lecture14-%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="Lecture14-模板">Lecture14-模板</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="quas-modo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">quas-modo</p><div class="description" itemprop="description">notes/thoughts/nonsense</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">80</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">20</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXMtbW9kbw==" title="https:&#x2F;&#x2F;github.com&#x2F;quas-modo"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/01/NJUSE/cpp/Lecture09-%E6%8C%87%E9%92%88/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/03/NJUSE/COA/Lecture08-cache/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2023/02/08/NJUSE/internet-computer/Lecture10-%E5%B9%BF%E5%9F%9F%E7%BD%91/" title="Lecture10-广域网">Lecture10-广域网</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/10/18/NJUSE/cpp/Lecture08-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/" title="Lecture08-数组和指针">Lecture08-数组和指针</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/10/04/NJUSE/cpp/Lecture07-%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/" title="Lecture07-程序组织">Lecture07-程序组织</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="分类于 数据管理基础">数据管理基础</a></div><span><a href="/2023/06/14/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="数据管理基础期末复习">数据管理基础期末复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/12/01/NJUSE/dataStructure/Lecture04-%E6%A0%91/" title="Lecture04-树">Lecture04-树</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/01/15/%E7%A7%BB%E5%8A%A8%E7%AB%AF2023%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/" title="移动端2023期末回忆">移动端2023期末回忆</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="分类于 数据管理基础">数据管理基础</a></div><span><a href="/2023/06/21/NJUSE/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AE%80%E7%AD%94%E6%95%B4%E7%90%86/" title="数据管理基础简答整理">数据管理基础简答整理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2023/02/08/NJUSE/internet-computer/Lecture03-%E9%93%BE%E8%B7%AF%E5%B1%82/" title="Lecture03-链路层">Lecture03-链路层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2023/02/08/NJUSE/internet-computer/Lecture11-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" title="Lecture11-网络安全">Lecture11-网络安全</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/02/26/NJUSE/internet-computer/%E6%9C%9F%E6%9C%AB%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/" title="计网期末名词解释">计网期末名词解释</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-quas-modo"></i> </span><span class="author" itemprop="copyrightHolder">quas-modo @ quas-modo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">337k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:07</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/02/NJUSE/cpp/Lecture10-OOP/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->