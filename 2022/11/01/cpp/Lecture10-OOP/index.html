<!-- build time:Thu Nov 03 2022 21:04:14 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Carpe diem" href="https://quas-modo.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Carpe diem" href="https://quas-modo.github.io/atom.xml"><link rel="alternate" type="application/json" title="Carpe diem" href="https://quas-modo.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="cpp"><link rel="canonical" href="https://quas-modo.github.io/2022/11/01/cpp/Lecture10-OOP/"><title>Lecture10-OOP - cpp - NJUSE | quas-modo = Carpe diem = pluck the day</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Lecture10-OOP</h1><div class="meta"><span class="item" title="创建时间：2022-11-01 20:40:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-01T20:40:09+08:00">2022-11-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">quas-modo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipesrnqv3j20zk0m8ava.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/NJUSE/" itemprop="item" rel="index" title="分类于 NJUSE"><span itemprop="name">NJUSE</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/NJUSE/cpp/" itemprop="item" rel="index" title="分类于 cpp"><span itemprop="name">cpp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://quas-modo.github.io/2022/11/01/cpp/Lecture10-OOP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="quas-modo"><meta itemprop="description" content="pluck the day, notes/thoughts/nonsense"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Carpe diem"></span><div class="body md" itemprop="articleBody"><p>OOP 相关<br><span id="more"></span></p><h1 id="lecture10-oop"><a class="anchor" href="#lecture10-oop">#</a> Lecture10-OOP</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zcHJpY29kZXIuZ2l0aHViLmlvLzIwMjAvMDcvMDEvMjAyMC1DLXBsdXMtcGx1cy1hZHZhbmNlZC1wcm9ncmFtbWluZy9DKystT09QLzIwMjAtQy1wbHVzLXBsdXMtYWR2YW5jZWQtcHJvZ3JhbW1pbmctQysrJTIwJUU3JUIxJUJCJUU3JTlBJTg0JUU1JUIwJTgxJUU4JUEzJTg1LyM2LSVFNyVCMSVCQiVFNyU5QSU4NCVFNyVBNyVCQiVFNSU4QSVBOCVFNiU5RSU4NCVFOSU4MCVBMCVFNSU4NyVCRCVFNiU5NSVCMA==">https://spricoder.github.io/2020/07/01/2020-C-plus-plus-advanced-programming/C++-OOP/2020-C-plus-plus-advanced-programming-C++ 类的封装 /#6 - 类的移动构造函数</span></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101190551858.png" alt="image-20221101190551858"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221029222347755.png" alt="image-20221029222347755"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101190605135.png" alt="image-20221101190605135"></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101190615624.png" alt="image-20221101190615624"></p><ol><li>encapsulation<ol><li>减少类之间的耦合</li><li>类内部的结构可以自由的进行修改</li><li>对成员进行控制</li><li>对代码的理解性更好</li></ol></li><li>information hidding：不需要知道如何初始化，只需要使用提供的接口</li><li>Cfront 第一个 C++ 的编译器，转为 C</li></ol><ul><li>基于对象：没有继承</li><li>面向对象：封装、继承、多态</li></ul><h2 id="类"><a class="anchor" href="#类">#</a> 类</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101140737002.png" alt="image-20221101140737002"></p><ul><li><p>成员变量</p></li><li><p>成员函数</p></li><li><p>头文件、源文件：C++ 是一个个编译单元进行编译，所以需要提前知道其他编译单元的相关信息（存储在头文件中），只需要知道声明，不需要知道具体定义，减少编译复杂度</p></li></ul><ol><li>如果直接将函数定义直接放在头文件里，会建议 compiler 将其作为 inline 函数进行编译。</li><li>如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。</li><li>随便使用内联函数可能是的代码很烂:get 和 set 函数我们选择使用 inline 方式</li><li>代码长度不超过 10 行，不包含 for、switch 等语句。</li></ol><h2 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101140754215.png" alt="image-20221101140754215"></p><ul><li><p>当类中未提供构造函数的时候，编译系统会提供默认构造函数。</p></li><li><p>程序员无论提供有参数的还是无参数的构造函数，编译系统都不再提供，防止干扰程序员本身的意思。</p></li><li><p>如果没有指定 c++ 默认初始化，则各种变量都会有<strong>不确定的值</strong></p></li><li><p>成员变量如果是成员对象，则总是会初始化的，需要为成员对象设置构造函数</p></li><li><p>全局变量和静态变量，未初始化，默认为 0</p></li><li><p>局部变量、成员变量，未初始化，默认为不确定的值</p></li><li><p>编译系统提供的默认构造函数不会对成员变量进行处理，主要功能是<strong>完成对象的初始化，创建标识符，开辟内存空间</strong>，最后再根据传入的参数或者默认值进行对数据的处理。</p></li><li><p>构造函数可定义为 <code>private</code> ，避免在其他代码中创建该对象，所以<strong>只能通过类内部的方法进行创建</strong>，而类内部的方法是我自己写的，因此<strong>可以接管对象的创建</strong>，例如保证单例，或者保证只有十个对象创建</p></li></ul><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141207824.png" alt="image-20221101141207824"></p><ol><li>调用:<ol><li>自动按照参数列表来对应构造函数</li><li>具体调用方式参照以上。</li></ol></li></ol><h2 id="成员初始化表构造函数初始化成员变量的一种方法"><a class="anchor" href="#成员初始化表构造函数初始化成员变量的一种方法">#</a> 成员初始化表（构造函数初始化成员变量的一种方法）</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTMyNjEvYXJ0aWNsZS9kZXRhaWxzLzg1MDM2MDI1">https://blog.csdn.net/u010853261/article/details/85036025</span></p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141220879.png" alt="image-20221101141220879"></p><p>C++ 构造函数的初始化列表定义</p><p>C++ 的构造函数与其他函数不同，构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表<strong>以冒号开头，后跟一系列以逗号分隔的初始化字段</strong>。</p><p>比如下面的例子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Foo</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    string name <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> id <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Foo</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">id</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">;</span> <span class="token comment">// 初始化列表</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol><li>构造函数的补充<ol><li>构造函数：先开辟空间并赋默认值</li><li>成员初始化表：开辟空间的时候就赋值</li></ol></li><li>执行：(常量和引用的声明和定义要放在一起，只能通过这个方法来完成)<ol><li><strong>先于构造函数执行</strong></li><li><strong>按类数据成员声明次序</strong>：下面的例子中先 x 再 y 再 z</li></ol></li><li><code>static const</code> : 常量数字，这个是可以在类内部进行初始化 ( <code>static const a = 1;</code> )</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 非静态成员可以初始化</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span><span class="token operator">&amp;</span> z<span class="token punctuation">;</span><span class="token comment">// 引用</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 签名的冒号后面，用变量 (值) 来进行初始化，这就是初始化表</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">z</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 赋值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="4"><li>减轻 Compiler 负担:</li></ol><ul><li>正常构造函数中赋值 <code>x = 100</code> ：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计 2 次</li><li>成员初始化表的时候，<strong>只进行了赋值一次</strong>。</li></ul><ol start="5"><li><strong>初始化顺序问题</strong>：先执行 p，再执行 size 有问题，按照字面序进行。</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CString</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">CString</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101191054488.png" alt="image-20221101191054488"></p><p>必须放在成员初始化表中：</p><ul><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的 class type，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ul><h2 id="析构函数"><a class="anchor" href="#析构函数">#</a> 析构函数</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141330420.png" alt="image-20221101141330420"></p><p><strong>程序员负责资源的申请和释放</strong></p><p>类的析构函数，它是类的一个成员函数，名字由波浪号加类名构成，是执行与构造函数相反的操作：释放对象使用的资源，并销毁非 static 成员。</p><p>同样的，我们来看看析构函数的几个特点：</p><ol><li>函数名是在类名前加上～，无参数且无返回值。</li><li>一个类只能有且有一个析构函数，如果没有显式的定义，系统会生成一个缺省的析构函数（合成析构函数）。</li><li>析构函数不能重载。<strong>每有一次构造函数的调用就会有一次析构函数的调用。</strong></li></ol><p><strong>声明为 private</strong></p><ol><li><p>系统无法调用析构函数，因为是自动消亡的，内存分配在栈中，<strong>离开作用域就会自动消亡</strong></p></li><li><p><strong>通过将对象的析构函数定义为</strong> <code>**private**</code> <strong>，强制在堆上分配内存</strong>，场景：栈的内存有限，对象的内存很大</p></li><li><p>better solution：这种方法也能够将 <code>p</code> 指针重新定义为空指针，更好</p></li></ol><p><strong>GC 垃圾回收</strong></p><ol><li>存在效率障碍，发生时间不确定</li><li>存在不能使用 GC 的场合</li><li>只能回收内存，不能回收文件操作的句柄等 <code>finalize</code></li><li>不能由程序员自己控制<br>&lt;a name=&quot;dC6ui&quot;&gt;&lt;/a&gt;</li></ol><p>**RAII Resource Acquisition Is Initialization **</p><ol><li>什么时候获取什么时候释放都是确定的</li><li>对象获得的资源都是要在析构函数中释放的</li><li>栈上的内存资源自动释放，堆上的内存资源需要通过析构函数释放</li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101191747419.png" alt="image-20221101191747419"></p><h2 id="拷贝构造函数-copy-constructor一种特殊的构造函数"><a class="anchor" href="#拷贝构造函数-copy-constructor一种特殊的构造函数">#</a> 拷贝构造函数 copy constructor—— 一种特殊的构造函数</h2><p>拷贝构造函数是来复制对象用的。</p><p>将地址传递和值传递统一起来，归根结底还是传递的是 &quot;值&quot;(地址也是值，只不过通过它可以找到另一个值)！</p><ol><li>相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。</li><li>默认拷贝构造函数<ol><li><strong>逐个成员初始化</strong> (member-wise initialization)</li><li><strong>对于对象成员，该定义是递归的</strong></li></ol></li><li>什么时候需要拷贝构造函数:<ol><li>赋值拷贝构造</li><li>传参进行拷贝</li><li>返回值进行拷贝</li></ol></li><li>拷贝构造函数私有：目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递 (对象比较大)</li></ol><h3 id="拷贝函数的使用情况以及定义"><a class="anchor" href="#拷贝函数的使用情况以及定义">#</a> 拷贝函数的使用情况以及定义</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101192544506.png" alt="image-20221101192544506"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 赋值拷贝构造</span></pre></td></tr><tr><td data-num="2"></td><td><pre>A a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>A b<span class="token operator">=</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 传参进行拷贝</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>A b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 返回值进行拷贝</span></pre></td></tr><tr><td data-num="9"></td><td><pre>A <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    A a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 拷贝构造函数</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">//const 避免出现修改</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 一定要写引用，不然就递归调用了</span></pre></td></tr></table></figure><p>为什么对象是一个<strong>引用类型</strong>，而不是<strong>值传递</strong>？</p><p>不然会出现<strong>循环拷贝</strong>问题：如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝，也就是防止递归引用。</p><h3 id="拷贝构造函数的深浅拷贝"><a class="anchor" href="#拷贝构造函数的深浅拷贝">#</a> 拷贝构造函数的深 / 浅拷贝</h3><h4 id="默认拷贝构造函数"><a class="anchor" href="#默认拷贝构造函数">#</a> 默认拷贝构造函数</h4><p>“默认拷贝构造函数”，这个构造函数很简单，仅仅使用 “老对象” 的数据成员的值对 “新对象” 的数据成员一一进行赋值，它一般具有以下形式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Rect</span><span class="token double-colon punctuation">::</span><span class="token function">Rect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rect<span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	width <span class="token operator">=</span> r<span class="token punctuation">.</span>width<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	height <span class="token operator">=</span> r<span class="token punctuation">.</span>height<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>默认拷贝构造函数会在处理静态数据成员和指针数据成员的时候出现错误。</p><h4 id="深拷贝浅拷贝"><a class="anchor" href="#深拷贝浅拷贝">#</a> 深拷贝 / 浅拷贝</h4><p>深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，<strong>资源重新分配</strong>，这个过程就是<strong>深拷贝</strong>，反之，<strong>没有重新分配资源，就是浅拷贝。</strong></p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9xdWFzZG8ub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMjExMDExOTI1NTU3NDAucG5n">https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101192555740.png</span>&quot; alt=&quot;image-20221101192555740&quot; style=&quot;zoom:200%;&quot; /&gt;</p><ol><li>原来 S1 和 S2 两个指针都指向 &quot;abcd&quot;, 但是随着 S1 的归还，S2 就变成了一个空指针了。</li><li>此时我们通过深拷贝完成拷贝</li><li>没有深拷贝需求的时候，使用编译器默认构造函数即可</li></ol><h3 id="拷贝构造函数的初始化问题"><a class="anchor" href="#拷贝构造函数的初始化问题">#</a> 拷贝构造函数的初始化问题</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141650806.png" alt="image-20221101141650806"></p><p>“接管编译器行为”</p><ol><li><p>包含成员对象的类</p><ol><li>默认拷贝构造函数：调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li><li>自定义拷贝构造函数：调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li></ol></li><li><p>拷贝函数的拷贝过程没有处理静态数据成员</p></li><li><p>默认拷贝构造函数:</p><ol><li><p>逐个成员初始化</p></li><li><p>对于对象成员，该定义是递归的</p></li></ol></li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM5MzcwNTExL2FydGljbGUvZGV0YWlscy85MTk4MTAzMw==">https://blog.csdn.net/sinat_39370511/article/details/91981033</span></p><h2 id="移动构造函数-move-constructor"><a class="anchor" href="#移动构造函数-move-constructor">#</a> 移动构造函数 move constructor</h2><p>官方文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL21vdmVfY29uc3RydWN0b3I=">https://en.cppreference.com/w/cpp/language/move_constructor</span></p><p>一些参考：</p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjU0MTIyNjI=">https://zhuanlan.zhihu.com/p/365412262</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI1Mzk0MDQzL2FydGljbGUvZGV0YWlscy83ODcyODUwNA==">https://blog.csdn.net/sinat_25394043/article/details/78728504</span></p><p>所谓移动语义（Move 语义），指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以<strong>将其包含的指针成员指向的内存资源直接移给新对象所有</strong>，无需再新拷贝一份，这大大提高了初始化的执行效率。（看上去，原来的成员没有访问资源的权限了？</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101141853347.png" alt="image-20221101141853347"></p><ol><li><p><strong>左值和右值</strong></p><p>左值：赋值操作符左边的值。是可以赋值的，通常是一个变量</p><p>右值：赋值操作符右边的值。是一个值，通常是一个常数、表达式、函数调用</p><p>能出现在赋值号左边的表达式称为 “左值”，不能出现在赋值号左边的表达式称为 “右值”。一般来说，左值是可以取地址的，右值则不可以。</p><p>非 const 的变量都是左值。函数调用的返回值若不是引用，则该函数调用就是右值。一般的 “引用” 都是引用变量的，而变量是左值，因此它们都是 “左值引用”。</p><p>C++11 新增了一种引用，可以引用右值，因而称为 “右值引用”。无名的临时变量不能出现在赋值号左边，因而是右值。右值引用就可以引用无名的临时变量。</p></li><li><p>Const 只能被绑定到右值上</p><ol><li>不可以写成 <code>int &amp;x = 5</code></li><li>为什么不可以对非 const 引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。</li></ol></li><li><p>移动构造函数：直接将对应的右值移动过来 (我们已经将 vector 和 String 进行了是此岸)</p></li><li><p><strong>&amp;&amp; 是右值引用</strong>，不会被左值调用。</p></li><li><p>五删原则：拷贝构造、拷贝赋值、析构函数、移动构造、移动复制</p><ol><li>提供上面的 5 个函数之一，则需要自己提供默认函数</li></ol></li></ol><h2 id="动态对象"><a class="anchor" href="#动态对象">#</a> 动态对象</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101143939590.png" alt="image-20221101143939590"></p><p>在<strong>堆</strong>上创建</p><p>引入 new 和 delete 操作符，除了可以分配内存，还可以调用构造函数，消除对象时，能归还内存，还可以调用析构函数。</p><p>malloc 不调用构造函数</p><p>new 可重载</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101144552660.png" alt="image-20221101144552660"></p><h3 id="创建对象"><a class="anchor" href="#创建对象">#</a> 创建对象</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101144604251.png" alt="image-20221101144604251"></p><ol><li><p>new:</p><ol><li>使用原始类型</li><li>使用类类型</li></ol></li><li><p>Syntax: 语法</p><ol><li>原始类型: <code>type* ptrName = new type;</code></li><li>使用类类型: <code>type* ptrName = new type(params);</code></li></ol></li></ol><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101145458897.png" alt="image-20221101145458897"></p><ol start="3"><li>注意：这是没有变量名字的物体【堆上的对象，只有通过指针去访问对象】</li></ol><h3 id="对象删除"><a class="anchor" href="#对象删除">#</a> 对象删除</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150246371.png" alt="image-20221101150246371"></p><ol><li><p>delete：</p><ol><li>唤起指向物体的指针</li><li>处理原始类型或类类型</li></ol></li><li><p>语法: <code>delete ptrName;</code></p></li><li><p>注意: <strong>删除之后，要将指针置为空指针</strong>，这样子之后可以继续使用，避免意外的引用对象，如果指针没有修改的话，可能是一个悬挂指针 (有可能出现段错误等等)</p><p>dangling pointer 悬垂指针</p><p>double free 两次删除</p><p>如果 delete 后指向 null，没有任何作用，可以防止很多的内存安全问题。这样写可以提高程序的鲁棒性。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">delete</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 如果没有办法确定 p 的类型，那么只会释放内存，但是不会调用析构函数</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 对于 cpp 这种编译语言来说，类型的声明是非常重要的</span></pre></td></tr></table></figure></li></ol><h3 id="动态对象数组"><a class="anchor" href="#动态对象数组">#</a> 动态对象数组</h3><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150739939.png" alt="image-20221101150739939"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>A <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//p = new A;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 以上两种写法返回的都是 A 的指针</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">delete</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//[] 不能够省略，省略之后不知道指向的是一个 A，还是一个数组</span></pre></td></tr></table></figure><p>在指针前存储 4 个字节，存储了数据类型，如果没有 []，就不会去访问 4 个字节。那么后面的对象都没有调用析构函数，没有内存释放，造成内存泄漏。</p><p>同时，会出现段错误。段错误是指访问的内存超出了系统给这个程序所设定的内存空间，例如访问了不存在的内存地址、访问了系统保护的内存地址、访问了只读的内存地址等等情况。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">delete</span> p<span class="token punctuation">;</span></pre></td></tr></table></figure><p>以上这段代码没有问题，对于内置的类型 int，不需要存储 4 个字节，也不需要调用析构函数。p 是一块完整的内存。</p><p>但是，为了简单起见，<strong>new []</strong> 与 <strong>delete[]</strong> 搭配使用。</p><p><strong>注意</strong></p><p>在堆上分配的内存默认不进行初始化</p><ol><li><code>int *p1 = new int[5];</code> 默认不进行初始化</li><li><code>int *p2 = new int[5]();</code> 进行默认初始化</li><li><code>int *p2 = new int[5]&#123;0,1,2,3,4&#125;</code> : 进行显式对应函数初始化</li></ol><h3 id="动态2d数组"><a class="anchor" href="#动态2d数组">#</a> 动态 2D 数组</h3><h4 id="创建"><a class="anchor" href="#创建">#</a> 创建</h4><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101152237726.png" alt="image-20221101152237726"></p><h4 id="删除"><a class="anchor" href="#删除">#</a> 删除</h4><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101152523993.png" alt="image-20221101152523993"></p><p>先 delete char*，再 delete char**</p><p>先 delete 三个粉红块块，再 delete 一个粉红块块</p><p>多维数组很少用现在这种方式做，都是用一维数组模拟多维数组。</p><h2 id="const成员"><a class="anchor" href="#const成员">#</a> Const 成员</h2><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101153137329.png" alt="image-20221101153137329"></p><ol><li><p>初始化放在构造函数的成员初始化表中进行：</p><ol><li>常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内</li><li>所以我们通过初始化表的方式完成。</li></ol></li><li><p><strong>不同的对象，可以有不同的 const 成员变量的值</strong>。对象一旦有了，在对象的生命周期内不变。不同的对象可以有不一样的值。A (1); A (2);</p></li><li><p><strong>所有的对象共享一个</strong> static const: 编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。</p></li></ol><p>静态成员变量一般在类外进行定义。</p><p><img data-src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221101153818760.png" alt="image-20221101153818760"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">// 前后要保证一致，const 在后面</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 编译器怎么能发现不是 const 的？转化为防止变量被赋值，见下面，所以 const 指针不能修改</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>A <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 上面的函数相当于这个</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span>x <span class="token operator">&lt;&lt;</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 上面的函数相当于这个，第一个 const 表示指向对象常量，后一个 const 表示指针本身是常量</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">const</span> A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 常对象：这个对象是不可以修改的</span></pre></td></tr><tr><td data-num="17"></td><td><pre>a<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误，常对象无法调用非常方法</span></pre></td></tr><tr><td data-num="18"></td><td><pre>a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 正确</span></pre></td></tr></table></figure><p>我们将不修改对象内变量的值的时候，将对应方法声明为 const，如 <code>const A a(0,0);</code></p><p>const 成员函数，在声明编译的函数后面，增加关键字 const。 <code>void show(); const</code></p><div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i> cpp</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-11-01 20:41:04" itemprop="dateModified" datetime="2022-11-01T20:41:04+08:00">2022-11-01</time> </span><span id="2022/11/01/cpp/Lecture10-OOP/" class="item leancloud_visitors" data-flag-title="Lecture10-OOP" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="quas-modo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="quas-modo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="quas-modo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>quas-modo <i class="ic i-at"><em>@</em></i>Carpe diem</li><li class="link"><strong>本文链接：</strong> <a href="https://quas-modo.github.io/2022/11/01/cpp/Lecture10-OOP/" title="Lecture10-OOP">https://quas-modo.github.io/2022/11/01/cpp/Lecture10-OOP/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicm07ih54j20zk0m84qp.jpg" title="Lecture07-存储器"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机组成与结构</span><h3>Lecture07-存储器</h3></a></div><div class="item right"><a href="/2022/11/01/cpp/Lecture09-%E6%8C%87%E9%92%88/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipex2cdtbj20zk0m8x6p.jpg" title="Lecture09-指针"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> cpp</span><h3>Lecture09-指针</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lecture10-oop"><span class="toc-number">1.</span> <span class="toc-text">Lecture10-OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">成员初始化表（构造函数初始化成员变量的一种方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-copy-constructor%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">拷贝构造函数 copy constructor—— 一种特殊的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">拷贝函数的使用情况以及定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.2.</span> <span class="toc-text">拷贝构造函数的深 &#x2F; 浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">默认拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">深拷贝 &#x2F; 浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">拷贝构造函数的初始化问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-move-constructor"><span class="toc-number">1.6.</span> <span class="toc-text">移动构造函数 move constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.</span> <span class="toc-text">动态对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">对象删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">动态对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%812d%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.4.</span> <span class="toc-text">动态 2D 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E6%88%90%E5%91%98"><span class="toc-number">1.8.</span> <span class="toc-text">Const 成员</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/09/15/cpp/Lecture03-%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="bookmark" title="Lecture03-结构化程序设计">Lecture03-结构化程序设计</a></li><li><a href="/2022/09/21/cpp/Lecture04-%E7%AC%AC%E4%B8%80%E6%AC%A1cpp%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Lecture04-第一次cpp编程">Lecture04-第一次cpp编程</a></li><li><a href="/2022/09/22/cpp/105-STL/" rel="bookmark" title="105 STL">105 STL</a></li><li><a href="/2022/09/29/cpp/Lecture06-%E5%87%BD%E6%95%B0/" rel="bookmark" title="Lecture06-函数">Lecture06-函数</a></li><li><a href="/2022/10/04/cpp/Lecture07-%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/" rel="bookmark" title="Lecture07-程序组织">Lecture07-程序组织</a></li><li><a href="/2022/10/18/cpp/Lecture08-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/" rel="bookmark" title="Lecture08-数组和指针">Lecture08-数组和指针</a></li><li class="active"><a href="/2022/11/01/cpp/Lecture10-OOP/" rel="bookmark" title="Lecture10-OOP">Lecture10-OOP</a></li><li><a href="/2022/11/01/cpp/Lecture09-%E6%8C%87%E9%92%88/" rel="bookmark" title="Lecture09-指针">Lecture09-指针</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="quas-modo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">quas-modo</p><div class="description" itemprop="description">notes/thoughts/nonsense</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">29</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">7</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXMtbW9kbw==" title="https:&#x2F;&#x2F;github.com&#x2F;quas-modo"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/24/COA/Lecture07-%E5%AD%98%E5%82%A8%E5%99%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/01/cpp/Lecture09-%E6%8C%87%E9%92%88/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%85%B6%E4%BB%96/" title="分类于 其他">其他</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%85%B6%E4%BB%96/%E8%A5%BF%E6%96%B9%E7%BE%8E%E6%9C%AF%E5%8F%B2/" title="分类于 西方美术史">西方美术史</a></div><span><a href="/2022/10/10/%E8%A5%BF%E6%96%B9%E7%BE%8E%E6%9C%AF%E5%8F%B2/Lecture02-03-%E5%8F%A4%E5%85%B8%E6%97%B6%E6%9C%9F-%E5%8F%A4%E7%BD%97%E9%A9%AC%E6%97%B6%E6%9C%9F/" title="Lecture02&#x2F;03 古典时期 古罗马时期">Lecture02/03 古典时期 古罗马时期</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9D%82%E8%B0%88/" title="分类于 杂谈">杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%9D%82%E8%B0%88/%E4%B9%A6%E5%BD%B1%E9%9F%B3/" title="分类于 书影音">书影音</a></div><span><a href="/2022/10/15/thoughts/to-the-moon/" title="to the moon">to the moon</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/" title="分类于 计算机组成与结构">计算机组成与结构</a></div><span><a href="/2022/09/15/COA/Lecture02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Lecture02-计算机体系结构的问题及解决方案">Lecture02-计算机体系结构的问题及解决方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9D%82%E8%B0%88/" title="分类于 杂谈">杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%9D%82%E8%B0%88/%E4%B9%A6%E5%BD%B1%E9%9F%B3/" title="分类于 书影音">书影音</a></div><span><a href="/2022/09/15/thoughts/%E8%87%AA%E6%9D%80%E4%B8%93%E5%8D%96%E5%BA%97/" title="自杀专卖店">自杀专卖店</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/09/29/cpp/Lecture06-%E5%87%BD%E6%95%B0/" title="Lecture06-函数">Lecture06-函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/11/01/cpp/Lecture10-OOP/" title="Lecture10-OOP">Lecture10-OOP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%85%B6%E4%BB%96/" title="分类于 其他">其他</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%85%B6%E4%BB%96/%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6/" title="分类于 行业研究">行业研究</a></div><span><a href="/2022/10/14/%E9%83%91%E9%92%A2%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6%E8%AE%AD%E7%BB%83%E8%90%A5/20221013-%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="20221013-计算机">20221013-计算机</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/10/04/cpp/Lecture07-%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87/" title="Lecture07-程序组织">Lecture07-程序组织</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9D%82%E8%B0%88/" title="分类于 杂谈">杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%9D%82%E8%B0%88/%E4%B9%A6%E5%BD%B1%E9%9F%B3/" title="分类于 书影音">书影音</a></div><span><a href="/2022/09/17/thoughts/%E4%B8%89%E5%92%8C/" title="三和">三和</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/NJUSE/" title="分类于 NJUSE">NJUSE</a> <i class="ic i-angle-right"></i> <a href="/categories/NJUSE/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/09/15/cpp/Lecture03-%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="Lecture03-结构化程序设计">Lecture03-结构化程序设计</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-quas-modo"></i> </span><span class="author" itemprop="copyrightHolder">quas-modo @ quas-modo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">54k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">49 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/01/cpp/Lecture10-OOP/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->